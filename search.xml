<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>如何理性看待AI发展：一把双刃剑</title>
    <url>/2025/02/06/ai-ai-development-perspective/</url>
    <content><![CDATA[引言人工智能(AI)正以前所未有的速度发展，从ChatGPT到DALL-E，从自动驾驶到智能医疗，AI技术正在重塑我们的生活方式和工作模式。作为21世纪最具革命性的技术之一，AI就像一把双刃剑，既能创造巨大价值，也可能带来意想不到的挑战。本文将深入分析AI发展的方方面面，帮助我们以更理性的态度看待AI技术的发展。
AI发展的积极影响1. 效率提升
工作自动化

自动处理重复性文档工作，提高办公效率
智能客服24小时在线，提升服务质量
工业自动化生产，提高产能和精确度


决策优化

大数据分析辅助决策，降低决策风险
预测模型提供决策参考，提高准确率
实时数据处理，支持快速响应


资源配置

智能调度系统优化物流配送
能源使用智能管理，降低资源浪费
智能算法优化人力资源分配



2. 创新突破
医疗健康

AI辅助诊断提高疾病识别准确率
药物研发周期大幅缩短
个性化治疗方案制定
远程医疗服务普及


科研进展

加速科学计算和模拟
发现新材料和新物质
气候变化预测更准确
空间探索取得新突破


产品创新

智能产品快速迭代
个性化定制更便捷
新产品研发周期缩短
用户体验持续优化



3. 生活改善
智能家居

家电智能控制，提升生活便利性
能源使用更环保高效
居家安全保障增强
老人和儿童照护更周到


教育革新

个性化学习计划制定
教育资源普惠化
在线教育更加智能
终身学习更加便捷


娱乐体验

游戏体验更加真实
虚拟现实技术提升
内容创作更加丰富
个性化推荐更准确



AI发展的潜在风险1. 就业冲击
岗位替代

基础性工作岗位加速消失
传统行业面临转型压力
就业结构急剧变化


技能挑战

现有技能快速过时
新技能学习压力增大
职业转型难度加大


就业市场变化

人才需求结构性失衡
就业竞争加剧
收入差距可能扩大



2. 伦理挑战
隐私安全

个人数据被过度收集
隐私边界日益模糊
数据安全风险增加
个人信息滥用问题


算法公平

AI决策可能存在偏见
算法歧视问题
责任归属难以界定
社会公平受到挑战


人机关系

人类自主性可能受限
过度依赖AI的风险
人际关系疏离化
心理健康新挑战



3. 社会影响
数字鸿沟

贫富差距可能扩大
教育资源获取不均
技术普及度差异
区域发展不平衡


社会结构

传统社会关系改变
社会价值观转变
文化传承面临挑战
社会治理新课题



如何理性应对1. 个人层面
终身学习

持续更新知识储备
培养跨领域能力
提升数字化素养
保持学习积极性


能力培养

强化创造性思维
提升批判性思考
发展情商和共情能力
培养人机协作能力



2. 社会层面
制度建设

完善AI伦理准则
建立监管框架
保护个人权益
促进公平发展


教育改革

更新教育理念
改革课程体系
加强技能培训
普及AI教育



3. 发展方向
以人为本

强调技术向善
注重人文关怀
维护人类尊严
促进共同发展


可持续发展

平衡效率与公平
注重环境保护
促进包容性增长
维护社会稳定



结语AI发展是一把真正的双刃剑，它既能带来前所未有的发展机遇，也可能产生难以预料的风险。关键在于我们如何趋利避害，在享受技术红利的同时，也要未雨绸缪，防范潜在风险。
我们需要以开放、包容但审慎的态度拥抱AI技术，在个人、企业和社会层面都要做好充分准备。只有正确认识和把握这把双刃剑，在发展中坚持以人为本，注重可持续发展，我们才能在AI时代走得更稳、走得更远。
让我们携手共建一个人机协作、互惠共赢的美好未来。 
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>人工智能</tag>
        <tag>技术发展</tag>
        <tag>AI伦理</tag>
        <tag>未来发展</tag>
      </tags>
  </entry>
  <entry>
    <title>== 和 ===区别，分别在什么情况使用</title>
    <url>/2024/04/16/JavaScript/</url>
    <content><![CDATA[ 
一、等于操作符等于操作符用两个等于号（ &#x3D;&#x3D; ）表示，如果操作数相等，则会返回 true
前面文章，我们提到在JavaScript中存在隐式转换。等于操作符（&#x3D;&#x3D;）在比较中会先进行类型转换，再确定操作数是否相等
遵循以下规则：
如果任一操作数是布尔值，则将其转换为数值再比较是否相等
let result1 = (true == 1); // true

如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等
let result1 = (&quot;55&quot; == 55); // true

如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf() 方法取得其原始值，再根据前面的规则进行比较
let obj = &#123;valueOf:function()&#123;return 1&#125;&#125;let result1 = (obj == 1); // true

null 和undefined相等
let result1 = (null == undefined ); // true

如果有任一操作数是 NaN ，则相等操作符返回 false 
let result1 = (NaN == NaN ); // false

如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true
let obj1 = &#123;name:&quot;xxx&quot;&#125;let obj2 = &#123;name:&quot;xxx&quot;&#125;let result1 = (obj1 == obj2 ); // false

下面进一步做个小结：

两个都为简单类型，字符串和布尔值都会转换成数值，再比较

简单类型与引用类型比较，对象转化成其原始类型的值，再比较

两个都为引用类型，则比较它们是否指向同一个对象

null 和 undefined 相等

存在 NaN 则返回 false


二、全等操作符全等操作符由 3 个等于号（ &#x3D;&#x3D;&#x3D; ）表示，只有两个操作数在不转换的前提下相等才返回 true。即类型相同，值也需相同
let result1 = (&quot;55&quot; === 55); // false，不相等，因为数据类型不同let result2 = (55 === 55); // true，相等，因为数据类型相同值也相同

undefined 和 null 与自身严格相等
let result1 = (null === null)  //truelet result2 = (undefined === undefined)  //true



三、区别相等操作符（&#x3D;&#x3D;）会做类型转换，再进行值的比较，全等运算符不会做类型转换
let result1 = (&quot;55&quot; === 55); // false，不相等，因为数据类型不同let result2 = (55 === 55); // true，相等，因为数据类型相同值也相同

null 和 undefined 比较，相等操作符（&#x3D;&#x3D;）为true，全等为false
let result1 = (null == undefined ); // truelet result2 = (null  === undefined); // false



小结相等运算符隐藏的类型转换，会带来一些违反直觉的结果
&#x27;&#x27; == &#x27;0&#x27; // false0 == &#x27;&#x27; // true0 == &#x27;0&#x27; // truefalse == &#x27;false&#x27; // falsefalse == &#x27;0&#x27; // truefalse == undefined // falsefalse == null // falsenull == undefined // true&#x27; \t\r\n&#x27; == 0 // true

但在比较null的情况的时候，我们一般使用相等操作符==
const obj = &#123;&#125;;if(obj.x == null)&#123;  console.log(&quot;1&quot;);  //执行&#125;

等同于下面写法
if(obj.x === null || obj.x === undefined) &#123;    ...&#125;

使用相等操作符（&#x3D;&#x3D;）的写法明显更加简洁了
所以，除了在比较对象属性为null或者undefined的情况下，我们可以使用相等操作符（&#x3D;&#x3D;），其他情况建议一律使用全等操作符（&#x3D;&#x3D;&#x3D;）
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ajax原理是什么？如何实现？</title>
    <url>/2024/04/18/JavaScript-ajax/</url>
    <content><![CDATA[ 
一、是什么AJAX 全称(Async Javascript and XML)
即异步的 JavaScript 和 XML，是一种创建交互式网页应用的网页开发技术，可以在不重新加载整个网页的情况下，与服务器交换数据，并且更新部分网页
Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面
流程图如下：
 
下面举个例子：
领导想找小李汇报一下工作，就委托秘书去叫小李，自己就接着做其他事情，直到秘书告诉他小李已经到了，最后小李跟领导汇报工作
Ajax请求数据流程与”领导想找小李汇报一下工作”类似，上述秘书就相当于XMLHttpRequest对象，领导相当于浏览器，响应数据相当于小李
浏览器可以发送HTTP请求后，接着做其他事情，等收到XHR返回来的数据再进行操作
二、实现过程实现 Ajax 异步交互需要服务器逻辑进行配合，需要完成以下步骤：

创建 Ajax 的核心对象 XMLHttpRequest 对象

通过 XMLHttpRequest 对象的 open() 方法与服务端建立连接

构建请求所需的数据内容，并通过 XMLHttpRequest 对象的 send() 方法发送给服务器端

通过 XMLHttpRequest 对象提供的 onreadystatechange 事件监听服务器端你的通信状态

接受并处理服务端向客户端响应的数据结果

将处理结果更新到 HTML 页面中


创建XMLHttpRequest对象通过XMLHttpRequest() 构造函数用于初始化一个 XMLHttpRequest 实例对象
const xhr = new XMLHttpRequest();



与服务器建立连接通过 XMLHttpRequest 对象的 open() 方法与服务器建立连接
xhr.open(method, url, [async][, user][, password])

参数说明：

method：表示当前的请求方式，常见的有GET、POST

url：服务端地址

async：布尔值，表示是否异步执行操作，默认为true

user: 可选的用户名用于认证用途；默认为&#96;null

password: 可选的密码用于认证用途，默认为&#96;null


给服务端发送数据通过 XMLHttpRequest 对象的 send() 方法，将客户端页面的数据发送给服务端
xhr.send([body])

body: 在 XHR 请求中要发送的数据体，如果不传递数据则为 null
如果使用GET请求发送数据的时候，需要注意如下：

将请求数据添加到open()方法中的url地址中
发送请求数据中的send()方法中参数设置为null

绑定onreadystatechange事件onreadystatechange 事件用于监听服务器端的通信状态，主要监听的属性为XMLHttpRequest.readyState ,
关于XMLHttpRequest.readyState属性有五个状态，如下图显示

只要 readyState 属性值一变化，就会触发一次 readystatechange 事件
XMLHttpRequest.responseText属性用于接收服务器端的响应结果
举个例子：
const request = new XMLHttpRequest()request.onreadystatechange = function(e)&#123;    if(request.readyState === 4)&#123; // 整个请求过程完毕        if(request.status &gt;= 200 &amp;&amp; request.status &lt;= 300)&#123;            console.log(request.responseText) // 服务端返回的结果        &#125;else if(request.status &gt;=400)&#123;            console.log(&quot;错误信息：&quot; + request.status)        &#125;    &#125;&#125;request.open(&#x27;POST&#x27;,&#x27;http://xxxx&#x27;)request.send()





三、封装通过上面对XMLHttpRequest 对象的了解，下面来封装一个简单的ajax请求
//封装一个ajax请求function ajax(options) &#123;    //创建XMLHttpRequest对象    const xhr = new XMLHttpRequest()    //初始化参数的内容    options = options || &#123;&#125;    options.type = (options.type || &#x27;GET&#x27;).toUpperCase()    options.dataType = options.dataType || &#x27;json&#x27;    const params = options.data    //发送请求    if (options.type === &#x27;GET&#x27;) &#123;        xhr.open(&#x27;GET&#x27;, options.url + &#x27;?&#x27; + params, true)        xhr.send(null)    &#125; else if (options.type === &#x27;POST&#x27;) &#123;        xhr.open(&#x27;POST&#x27;, options.url, true)        xhr.send(params)    //接收请求    xhr.onreadystatechange = function () &#123;        if (xhr.readyState === 4) &#123;            let status = xhr.status            if (status &gt;= 200 &amp;&amp; status &lt; 300) &#123;                options.success &amp;&amp; options.success(xhr.responseText, xhr.responseXML)            &#125; else &#123;                options.fail &amp;&amp; options.fail(status)            &#125;        &#125;    &#125;&#125;

使用方式如下
ajax(&#123;    type: &#x27;post&#x27;,    dataType: &#x27;json&#x27;,    data: &#123;&#125;,    url: &#x27;https://xxxx&#x27;,    success: function(text,xml)&#123;//请求成功后的回调函数        console.log(text)    &#125;,    fail: function(status)&#123;////请求失败后的回调函数        console.log(status)    &#125;&#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>数组的常用方法有哪些？</title>
    <url>/2024/04/20/JavaScript-array-api/</url>
    <content><![CDATA[ 
一、操作方法数组基本操作可以归纳为 增、删、改、查，需要留意的是哪些方法会对原数组产生影响，哪些方法不会
下面对数组常用的操作方法做一个归纳
增下面前三种是对原数组产生影响的增添方法，第四种则不会对原数组产生影响

push()
unshift()
splice()
concat()

push()push()方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度
let colors = []; // 创建一个数组let count = colors.push(&quot;red&quot;, &quot;green&quot;); // 推入两项console.log(count) // 2



unshift()unshift()在数组开头添加任意多个值，然后返回新的数组长度
let colors = new Array(); // 创建一个数组let count = colors.unshift(&quot;red&quot;, &quot;green&quot;); // 从数组开头推入两项alert(count); // 2



splice传入三个参数，分别是开始位置、0（要删除的元素数量）、插入的元素，返回空数组
let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];let removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;)console.log(colors) // red,yellow,orange,green,blueconsole.log(removed) // []


concat()首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组
let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];let colors2 = colors.concat(&quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]);console.log(colors); // [&quot;red&quot;, &quot;green&quot;,&quot;blue&quot;]console.log(colors2); // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;]



删下面三种都会影响原数组，最后一项不影响原数组：

pop()
shift()
splice()
slice()

pop() pop() 方法用于删除数组的最后一项，同时减少数组的 length 值，返回被删除的项
let colors = [&quot;red&quot;, &quot;green&quot;]let item = colors.pop(); // 取得最后一项console.log(item) // greenconsole.log(colors.length) // 1



shift()shift()方法用于删除数组的第一项，同时减少数组的 length 值，返回被删除的项
let colors = [&quot;red&quot;, &quot;green&quot;]let item = colors.shift(); // 取得第一项console.log(item) // redconsole.log(colors.length) // 1



splice()传入两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组
let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];let removed = colors.splice(0,1); // 删除第一项console.log(colors); // green,blueconsole.log(removed); // red，只有一个元素的数组



slice() slice() 用于创建一个包含原有数组中一个或多个元素的新数组，不会影响原始数组
let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;];let colors2 = colors.slice(1);let colors3 = colors.slice(1, 4);console.log(colors)   // red,green,blue,yellow,purpleconcole.log(colors2); // green,blue,yellow,purpleconcole.log(colors3); // green,blue,yellow



改即修改原来数组的内容，常用splice
splice()传入三个参数，分别是开始位置，要删除元素的数量，要插入的任意多个元素，返回删除元素的数组，对原数组产生影响
let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];let removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;); // 插入两个值，删除一个元素console.log(colors); // red,red,purple,blueconsole.log(removed); // green，只有一个元素的数组



查即查找元素，返回元素坐标或者元素值

indexOf()
includes()
find()

indexOf()返回要查找的元素在数组中的位置，如果没找到则返回 -1
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];numbers.indexOf(4) // 3



includes()返回要查找的元素在数组中的位置，找到返回true，否则false
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];numbers.includes(4) // true

find()返回第一个匹配的元素
const people = [    &#123;        name: &quot;Matt&quot;,        age: 27    &#125;,    &#123;        name: &quot;Nicholas&quot;,        age: 29    &#125;];people.find((element, index, array) =&gt; element.age &lt; 28) // // &#123;name: &quot;Matt&quot;, age: 27&#125;



二、排序方法数组有两个方法可以用来对元素重新排序：

reverse() 
sort()

reverse()顾名思义，将数组元素方向反转
let values = [1, 2, 3, 4, 5];values.reverse();alert(values); // 5,4,3,2,1



sort()sort()方法接受一个比较函数，用于判断哪个值应该排在前面
function compare(value1, value2) &#123;    if (value1 &lt; value2) &#123;        return -1;    &#125; else if (value1 &gt; value2) &#123;        return 1;    &#125; else &#123;        return 0;    &#125;&#125;let values = [0, 1, 5, 10, 15];values.sort(compare);alert(values); // 0,1,5,10,15



三、转换方法常见的转换方法有：
join()join() 方法接收一个参数，即字符串分隔符，返回包含所有项的字符串
let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];alert(colors.join(&quot;,&quot;)); // red,green,bluealert(colors.join(&quot;||&quot;)); // red||green||blue





四、迭代方法常用来迭代数组的方法（都不改变原数组）有如下：

some()
every()
forEach()
filter()
map()

some()对数组每一项都运行传入的测试函数，如果至少有1个元素返回 true ，则这个方法返回 true
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];let someResult = numbers.some((item, index, array) =&gt; item &gt; 2);console.log(someResult) // true



every()对数组每一项都运行传入的测试函数，如果所有元素都返回 true ，则这个方法返回 true
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];let everyResult = numbers.every((item, index, array) =&gt; item &gt; 2);console.log(everyResult) // false



forEach()对数组每一项都运行传入的函数，没有返回值
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];numbers.forEach((item, index, array) =&gt; &#123;    // 执行某些操作&#125;);



filter()对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];let filterResult = numbers.filter((item, index, array) =&gt; item &gt; 2);console.log(filterResult); // 3,4,5,4,3



map()对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];let mapResult = numbers.map((item, index, array) =&gt; item * 2);console.log(mapResult) // 2,4,6,8,10,8,6,4,2
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>BOM的理解？</title>
    <url>/2024/04/28/JavaScript-BOM/</url>
    <content><![CDATA[ 
一、是什么BOM (Browser Object Model)，浏览器对象模型，提供了独立于内容与浏览器窗口进行交互的对象
其作用就是跟浏览器做一些交互效果,比如如何进行页面的后退，前进，刷新，浏览器的窗口发生变化，滚动条的滚动，以及获取客户的一些信息如：浏览器品牌版本，屏幕分辨率
浏览器的全部内容可以看成DOM，整个浏览器可以看成BOM。区别如下：

二、windowBom的核心对象是window，它表示浏览器的一个实例
在浏览器中，window对象有双重角色，即是浏览器窗口的一个接口，又是全局对象
因此所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法
var name = &#x27;js每日一题&#x27;;function lookName()&#123;  alert(this.name);&#125;console.log(window.name);  //js每日一题lookName();                //js每日一题window.lookName();         //js每日一题

关于窗口控制方法如下：

moveBy(x,y)：从当前位置水平移动窗体x个像素，垂直移动窗体y个像素，x为负数，将向左移动窗体，y为负数，将向上移动窗体
moveTo(x,y)：移动窗体左上角到相对于屏幕左上角的(x,y)点
resizeBy(w,h)：相对窗体当前的大小，宽度调整w个像素，高度调整h个像素。如果参数为负值，将缩小窗体，反之扩大窗体
resizeTo(w,h)：把窗体宽度调整为w个像素，高度调整为h个像素
scrollTo(x,y)：如果有滚动条，将横向滚动条移动到相对于窗体宽度为x个像素的位置，将纵向滚动条移动到相对于窗体高度为y个像素的位置
scrollBy(x,y)： 如果有滚动条，将横向滚动条向左移动x个像素，将纵向滚动条向下移动y个像素

 window.open() 既可以导航到一个特定的url，也可以打开一个新的浏览器窗口
如果 window.open() 传递了第二个参数，且该参数是已有窗口或者框架的名称，那么就会在目标窗口加载第一个参数指定的URL
window.open(&#x27;htttp://www.vue3js.cn&#x27;,&#x27;topFrame&#x27;)==&gt; &lt; a href=&quot; &quot; target=&quot;topFrame&quot;&gt;&lt;/ a&gt;

window.open() 会返回新窗口的引用，也就是新窗口的 window 对象
const myWin = window.open(&#x27;http://www.vue3js.cn&#x27;,&#x27;myWin&#x27;)

window.close() 仅用于通过 window.open() 打开的窗口
新创建的 window 对象有一个 opener 属性，该属性指向打开他的原始窗口对象
三、locationurl地址如下：
http://foouser:barpassword@www.wrox.com:80/WileyCDA/?q=javascript#contents

location属性描述如下：



属性名
例子
说明



hash
“#contents”
utl中#后面的字符，没有则返回空串


host
www.wrox.com:80
服务器名称和端口号


hostname
www.wrox.com
域名，不带端口号


href
http://www.wrox.com:80/WileyCDA/?q=javascript#contents
完整url


pathname
“&#x2F;WileyCDA&#x2F;“
服务器下面的文件路径


port
80
url的端口号，没有则为空


protocol
http:
使用的协议


search
?q&#x3D;javascript
url的查询字符串，通常为？后面的内容


除了 hash 之外，只要修改location的一个属性，就会导致页面重新加载新 URL
location.reload()，此方法可以重新刷新当前页面。这个方法会根据最有效的方式刷新页面，如果页面自上一次请求以来没有改变过，页面就会从浏览器缓存中重新加载
如果要强制从服务器中重新加载，传递一个参数true即可
四、navigatornavigator 对象主要用来获取浏览器的属性，区分浏览器类型。属性较多，且兼容性比较复杂
下表列出了navigator对象接口定义的属性和方法：
 
 
五、screen保存的纯粹是客户端能力信息，也就是浏览器窗口外面的客户端显示器的信息，比如像素宽度和像素高度
 
六、historyhistory对象主要用来操作浏览器URL的历史记录，可以通过参数向前，向后，或者向指定URL跳转
常用的属性如下：

history.go()

接收一个整数数字或者字符串参数：向最近的一个记录中包含指定字符串的页面跳转，
history.go(&#x27;maixaofei.com&#x27;)

当参数为整数数字的时候，正数表示向前跳转指定的页面，负数为向后跳转指定的页面
history.go(3) //向前跳转三个记录history.go(-1) //向后跳转一个记录


history.forward()：向前跳转一个页面
history.back()：向后跳转一个页面
history.length：获取历史记录数

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>bind、call、apply 区别？如何实现一个bind?</title>
    <url>/2024/04/22/JavaScript-bind-call-apply/</url>
    <content><![CDATA[ 
一、作用call 、apply 、bind 作用是改变函数执行时的上下文，简而言之就是改变函数运行时的this指向
那么什么情况下需要改变this的指向呢？下面举个例子
var name = &quot;lucy&quot;;var obj = &#123;    name: &quot;martin&quot;,    say: function () &#123;        console.log(this.name);    &#125;&#125;;obj.say(); // martin，this 指向 obj 对象setTimeout(obj.say,0); // lucy，this 指向 window 对象

从上面可以看到，正常情况say方法输出martin
但是我们把say放在setTimeout方法中，在定时器中是作为回调函数来执行的，因此回到主栈执行时是在全局执行上下文的环境中执行的，这时候this指向window，所以输出lucy
我们实际需要的是this指向obj对象，这时候就需要该改变this指向了
setTimeout(obj.say.bind(obj),0); //martin，this指向obj对象



二、区别下面再来看看apply、call、bind的使用
applyapply接受两个参数，第一个参数是this的指向，第二个参数是函数接受的参数，以数组的形式传入
改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次
function fn(...args)&#123;    console.log(this,args);&#125;let obj = &#123;    myname:&quot;张三&quot;&#125;fn.apply(obj,[1,2]); // this会变成传入的obj，传入的参数必须是一个数组；fn(1,2) // this指向window

当第一个参数为null、undefined的时候，默认指向window(在浏览器中)
fn.apply(null,[1,2]); // this指向windowfn.apply(undefined,[1,2]); // this指向window



callcall方法的第一个参数也是this的指向，后面传入的是一个参数列表
跟apply一样，改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次
function fn(...args)&#123;    console.log(this,args);&#125;let obj = &#123;    myname:&quot;张三&quot;&#125;fn.call(obj,1,2); // this会变成传入的obj，传入的参数必须是一个数组；fn(1,2) // this指向window

同样的，当第一个参数为null、undefined的时候，默认指向window(在浏览器中)
fn.call(null,[1,2]); // this指向windowfn.call(undefined,[1,2]); // this指向window



bindbind方法和call很相似，第一参数也是this的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入)
改变this指向后不会立即执行，而是返回一个永久改变this指向的函数
function fn(...args)&#123;    console.log(this,args);&#125;let obj = &#123;    myname:&quot;张三&quot;&#125;const bindFn = fn.bind(obj); // this 也会变成传入的obj ，bind不是立即执行需要执行一次bindFn(1,2) // this指向objfn(1,2) // this指向window


小结从上面可以看到，apply、call、bind三者的区别在于：

三者都可以改变函数的this对象指向
三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为undefined或null，则默认指向全局window
三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入
bind 是返回绑定this之后的函数，apply 、call 则是立即执行

三、实现实现bind的步骤，我们可以分解成为三部分：

修改this指向
动态传递参数

// 方式一：只在bind中传递函数参数fn.bind(obj,1,2)()// 方式二：在bind中传递函数参数，也在返回函数中传递参数fn.bind(obj,1)(2)


兼容new关键字

整体实现代码如下：
Function.prototype.myBind = function (context) &#123;    // 判断调用对象是否为函数    if (typeof this !== &quot;function&quot;) &#123;        throw new TypeError(&quot;Error&quot;);    &#125;    // 获取参数    const args = [...arguments].slice(1),          fn = this;    return function Fn() &#123;        // 根据调用方式，传入不同绑定值        return fn.apply(this instanceof Fn ? new fn(...arguments) : context, args.concat(...arguments));     &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript本地存储的方式有哪些？区别及应用场景？</title>
    <url>/2024/05/18/JavaScript-cache/</url>
    <content><![CDATA[ 
一、方式javaScript本地缓存的方法我们主要讲述以下四种：

cookie
sessionStorage
localStorage
indexedDB

cookieCookie，类型为「小型文本文件」，指某些网站为了辨别用户身份而储存在用户本地终端上的数据。是为了解决 HTTP 无状态导致的问题
作为一段一般不超过 4KB 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 cookie 有效期、安全性、使用范围的可选属性组成
但是cookie在每次请求中都会被发送，如果不使用 HTTPS 并对其加密，其保存的信息很容易被窃取，导致安全风险。举个例子，在一些使用 cookie 保持登录态的网站上，如果 cookie 被窃取，他人很容易利用你的 cookie 来假扮成你登录网站
关于cookie常用的属性如下：

Expires 用于设置 Cookie 的过期时间

Expires=Wed, 21 Oct 2015 07:28:00 GMT


Max-Age 用于设置在 Cookie 失效之前需要经过的秒数（优先级比Expires高）

Max-Age=604800


Domain 指定了 Cookie 可以送达的主机名
Path 指定了一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部

Path=/docs   # /docs/Web/ 下的资源会带 Cookie 首部


标记为 Secure 的 Cookie 只应通过被HTTPS协议加密过的请求发送给服务端

通过上述，我们可以看到cookie一开始的作用并不是为了缓存而设计出来，只是借用了cookie的特性实现缓存
关于cookie的使用如下：
document.cookie = &#x27;名字=值&#x27;;

关于cookie的修改，首先要确定domain和path属性都是相同的才可以，其中有一个不同得时候都会创建出一个新的cookie
Set-Cookie:name=aa; domain=aa.net; path=/  # 服务端设置document.cookie =name=bb; domain=aa.net; path=/  # 客户端设置

最后cookie的删除，最常用的方法就是给cookie设置一个过期的时间，这样cookie过期后会被浏览器删除
localStorageHTML5新方法，IE8及以上浏览器都兼容
特点
生命周期：持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的
存储的信息在同一域中是共享的
当本页操作（新增、修改、删除）了localStorage的时候，本页面不会触发storage事件,但是别的页面会触发storage事件。
大小：5M（跟浏览器厂商有关系）
localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡
受同源策略的限制

下面再看看关于localStorage的使用
设置
localStorage.setItem(&#x27;username&#x27;,&#x27;cfangxu&#x27;);

获取
localStorage.getItem(&#x27;username&#x27;)

获取键名
localStorage.key(0) //获取第一个键名

删除
localStorage.removeItem(&#x27;username&#x27;)

一次性清除所有存储
localStorage.clear()

localStorage 也不是完美的，它有两个缺点：

无法像Cookie一样设置过期时间
只能存入字符串，无法直接存对象

localStorage.setItem(&#x27;key&#x27;, &#123;name: &#x27;value&#x27;&#125;);console.log(localStorage.getItem(&#x27;key&#x27;)); // &#x27;[object, Object]&#x27;



sessionStoragesessionStorage 和 localStorage 使用方法基本一致，唯一不同的是生命周期，一旦页面（会话）关闭，sessionStorage 将会删除数据
扩展的前端存储方式indexedDB 是一种低级API，用于客户端存储大量结构化数据(包括, 文件&#x2F; blobs)。该API使用索引来实现对该数据的高性能搜索
虽然 Web Storage 对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB提供了一个解决方案
优点：
储存量理论上没有上限
所有操作都是异步的，相比 LocalStorage 同步操作性能更高，尤其是数据量较大时
原生支持储存JS的对象
是个正经的数据库，意味着数据库能干的事它都能干

缺点：
操作非常繁琐
本身有一定门槛

关于indexedDB的使用基本使用步骤如下：

打开数据库并且开始一个事务

创建一个 object store

构建一个请求来执行一些数据库操作，像增加或提取数据等。

通过监听正确类型的 DOM 事件以等待操作完成。

在操作结果上进行一些操作（可以在 request 对象中找到）


关于使用indexdb的使用会比较繁琐，大家可以通过使用Godb.js库进行缓存，最大化的降低操作难度
二、区别关于cookie、sessionStorage、localStorage三者的区别主要如下：

存储大小： cookie数据大小不能超过4k，sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大

有效时间：localStorage  存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage  数据在当前浏览器窗口关闭后自动删除；cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭

数据与服务器之间的交互方式，  cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端； sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存


三、应用场景在了解了上述的前端的缓存方式后，我们可以看看针对不对场景的使用选择：

标记用户与跟踪用户行为的情况，推荐使用cookie
适合长期保存在本地的数据（令牌），推荐使用localStorage
敏感账号一次性登录，推荐使用sessionStorage
存储大量数据的情况、在线文档（富文本编辑器）保存编辑历史的情况，推荐使用indexedDB

相关连接
https://mp.weixin.qq.com/s/mROjtpoXarN--UDfEMqwhQ
https://github.com/chenstarx/GoDB.js

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包的理解？闭包使用场景</title>
    <url>/2024/05/24/JavaScript-closure/</url>
    <content><![CDATA[ 
一、是什么一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）
也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域
在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来，作为函数内部与外部连接起来的一座桥梁
下面给出一个简单的例子
function init() &#123;    var name = &quot;Mozilla&quot;; // name 是一个被 init 创建的局部变量    function displayName() &#123; // displayName() 是内部函数，一个闭包        alert(name); // 使用了父函数中声明的变量    &#125;    displayName();&#125;init();

displayName() 没有自己的局部变量。然而，由于闭包的特性，它可以访问到外部函数的变量
二、使用场景任何闭包的使用场景都离不开这两点：

创建私有变量
延长变量的生命周期


一般函数的词法环境在函数返回后就被销毁，但是闭包会保存对创建时所在词法环境的引用，即便创建时所在的执行上下文被销毁，但创建时所在词法环境依然存在，以达到延长变量的生命周期的目的

下面举个例子：
在页面上添加一些可以调整字号的按钮
function makeSizer(size) &#123;  return function() &#123;    document.body.style.fontSize = size + &#x27;px&#x27;;  &#125;;&#125;var size12 = makeSizer(12);var size14 = makeSizer(14);var size16 = makeSizer(16);document.getElementById(&#x27;size-12&#x27;).onclick = size12;document.getElementById(&#x27;size-14&#x27;).onclick = size14;document.getElementById(&#x27;size-16&#x27;).onclick = size16;



柯里化函数柯里化的目的在于避免频繁调用具有相同参数函数的同时，又能够轻松的重用
// 假设我们有一个求长方形面积的函数function getArea(width, height) &#123;    return width * height&#125;// 如果我们碰到的长方形的宽老是10const area1 = getArea(10, 20)const area2 = getArea(10, 30)const area3 = getArea(10, 40)// 我们可以使用闭包柯里化这个计算面积的函数function getArea(width) &#123;    return height =&gt; &#123;        return width * height    &#125;&#125;const getTenWidthArea = getArea(10)// 之后碰到宽度为10的长方形就可以这样计算面积const area1 = getTenWidthArea(20)// 而且如果遇到宽度偶尔变化也可以轻松复用const getTwentyWidthArea = getArea(20)



使用闭包模拟私有方法在JavaScript中，没有支持声明私有变量，但我们可以使用闭包来模拟私有方法
下面举个例子：
var Counter = (function() &#123;  var privateCounter = 0;  function changeBy(val) &#123;    privateCounter += val;  &#125;  return &#123;    increment: function() &#123;      changeBy(1);    &#125;,    decrement: function() &#123;      changeBy(-1);    &#125;,    value: function() &#123;      return privateCounter;    &#125;  &#125;&#125;)();var Counter1 = makeCounter();var Counter2 = makeCounter();console.log(Counter1.value()); /* logs 0 */Counter1.increment();Counter1.increment();console.log(Counter1.value()); /* logs 2 */Counter1.decrement();console.log(Counter1.value()); /* logs 1 */console.log(Counter2.value()); /* logs 0 */

上述通过使用闭包来定义公共函数，并令其可以访问私有函数和变量，这种方式也叫模块方式
两个计数器 Counter1 和 Counter2 是维护它们各自的独立性的，每次调用其中一个计数器时，通过改变这个变量的值，会改变这个闭包的词法环境，不会影响另一个闭包中的变量
其他例如计数器、延迟调用、回调等闭包的应用，其核心思想还是创建私有变量和延长变量的生命周期
三、注意事项如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响
例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。
原因在于每个对象的创建，方法都会被重新赋值
function MyObject(name, message) &#123;  this.name = name.toString();  this.message = message.toString();  this.getName = function() &#123;    return this.name;  &#125;;  this.getMessage = function() &#123;    return this.message;  &#125;;&#125;

上面的代码中，我们并没有利用到闭包的好处，因此可以避免使用闭包。修改成如下：
function MyObject(name, message) &#123;  this.name = name.toString();  this.message = message.toString();&#125;MyObject.prototype.getName = function() &#123;  return this.name;&#125;;MyObject.prototype.getMessage = function() &#123;  return this.message;&#125;;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM常见的操作有哪些？</title>
    <url>/2024/07/04/JavaScript-Dom/</url>
    <content><![CDATA[ 
一、DOM文档对象模型 (DOM) 是 HTML 和 XML 文档的编程接口
它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容
任何 HTML 或XML文档都可以用 DOM 表示为一个由节点构成的层级结构
节点分很多类型，每种类型对应着文档中不同的信息和（或）标记，也都有自己不同的特性、数据和方法，而且与其他类型有某种关系，如下所示：
&lt;html&gt;    &lt;head&gt;        &lt;title&gt;Page&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;p&gt;Hello World!&lt;/p &gt;    &lt;/body&gt;&lt;/html&gt;

DOM像原子包含着亚原子微粒那样，也有很多类型的DOM节点包含着其他类型的节点。接下来我们先看看其中的三种：
&lt;div&gt;    &lt;p title=&quot;title&quot;&gt;        content    &lt;/p &gt;&lt;/div&gt;

上述结构中，div、p就是元素节点，content就是文本节点，title就是属性节点
二、操作日常前端开发，我们都离不开DOM操作
在以前，我们使用Jquery，zepto等库来操作DOM，之后在vue，Angular，React等框架出现后，我们通过操作数据来控制DOM（绝大多数时候），越来越少的去直接操作DOM
但这并不代表原生操作不重要。相反，DOM操作才能有助于我们理解框架深层的内容
下面就来分析DOM常见的操作，主要分为：

创建节点
查询节点
更新节点
添加节点
删除节点

创建节点createElement创建新元素，接受一个参数，即要创建元素的标签名
const divEl = document.createElement(&quot;div&quot;);



createTextNode创建一个文本节点
const textEl = document.createTextNode(&quot;content&quot;);



createDocumentFragment用来创建一个文档碎片，它表示一种轻量级的文档，主要是用来存储临时节点，然后把文档碎片的内容一次性添加到DOM中
const fragment = document.createDocumentFragment();

当请求把一个DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点
createAttribute创建属性节点，可以是自定义属性
const dataAttribute = document.createAttribute(&#x27;custom&#x27;);consle.log(dataAttribute);



获取节点querySelector传入任何有效的 css 选择器，即可选中单个 DOM 元素（首个）：
document.querySelector(&#x27;.element&#x27;)document.querySelector(&#x27;#element&#x27;)document.querySelector(&#x27;div&#x27;)document.querySelector(&#x27;[name=&quot;username&quot;]&#x27;)document.querySelector(&#x27;div + p &gt; span&#x27;)

如果页面上没有指定的元素时，返回 null
querySelectorAll返回一个包含节点子树内所有与之相匹配的Element节点列表，如果没有相匹配的，则返回一个空节点列表
const notLive = document.querySelectorAll(&quot;p&quot;);

需要注意的是，该方法返回的是一个 NodeList 的静态实例，它是一个静态的“快照”，而非“实时”的查询
关于获取DOM元素的方法还有如下，就不一一述说
document.getElementById(&#x27;id属性值&#x27;);返回拥有指定id的对象的引用document.getElementsByClassName(&#x27;class属性值&#x27;);返回拥有指定class的对象集合document.getElementsByTagName(&#x27;标签名&#x27;);返回拥有指定标签名的对象集合document.getElementsByName(&#x27;name属性值&#x27;); 返回拥有指定名称的对象结合document/element.querySelector(&#x27;CSS选择器&#x27;);  仅返回第一个匹配的元素document/element.querySelectorAll(&#x27;CSS选择器&#x27;);   返回所有匹配的元素document.documentElement;  获取页面中的HTML标签document.body; 获取页面中的BODY标签document.all[&#x27;&#x27;];  获取页面中的所有元素节点的对象集合型

除此之外，每个DOM元素还有parentNode、childNodes、firstChild、lastChild、nextSibling、previousSibling属性，关系图如下图所示
 
更新节点innerHTML不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树
// 获取&lt;p id=&quot;p&quot;&gt;...&lt;/p &gt;var p = document.getElementById(&#x27;p&#x27;);// 设置文本为abc:p.innerHTML = &#x27;ABC&#x27;; // &lt;p id=&quot;p&quot;&gt;ABC&lt;/p &gt;// 设置HTML:p.innerHTML = &#x27;ABC &lt;span style=&quot;color:red&quot;&gt;RED&lt;/span&gt; XYZ&#x27;;// &lt;p&gt;...&lt;/p &gt;的内部结构已修改



innerText、textContent自动对字符串进行HTML编码，保证无法设置任何HTML标签
// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p &gt;var p = document.getElementById(&#x27;p-id&#x27;);// 设置文本:p.innerText = &#x27;&lt;script&gt;alert(&quot;Hi&quot;)&lt;/script&gt;&#x27;;// HTML被自动编码，无法设置一个&lt;script&gt;节点:// &lt;p id=&quot;p-id&quot;&gt;&amp;lt;script&amp;gt;alert(&quot;Hi&quot;)&amp;lt;/script&amp;gt;&lt;/p &gt;

两者的区别在于读取属性时，innerText不返回隐藏元素的文本，而textContent返回所有文本
styleDOM节点的style属性对应所有的CSS，可以直接获取或设置。遇到-需要转化为驼峰命名
// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p &gt;const p = document.getElementById(&#x27;p-id&#x27;);// 设置CSS:p.style.color = &#x27;#ff0000&#x27;;p.style.fontSize = &#x27;20px&#x27;; // 驼峰命名p.style.paddingTop = &#x27;2em&#x27;;





添加节点innerHTML如果这个DOM节点是空的，例如，&lt;div&gt;&lt;/div&gt;，那么，直接使用innerHTML = &#39;&lt;span&gt;child&lt;/span&gt;&#39;就可以修改DOM节点的内容，相当于添加了新的DOM节点
如果这个DOM节点不是空的，那就不能这么做，因为innerHTML会直接替换掉原来的所有子节点
appendChild把一个子节点添加到父节点的最后一个子节点
举个例子
&lt;!-- HTML结构 --&gt;&lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p &gt;&lt;div id=&quot;list&quot;&gt;    &lt;p id=&quot;java&quot;&gt;Java&lt;/p &gt;    &lt;p id=&quot;python&quot;&gt;Python&lt;/p &gt;    &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p &gt;&lt;/div&gt;

添加一个p元素
const js = document.getElementById(&#x27;js&#x27;)js.innerHTML = &quot;JavaScript&quot;const list = document.getElementById(&#x27;list&#x27;);list.appendChild(js);

现在HTML结构变成了下面
&lt;!-- HTML结构 --&gt;&lt;div id=&quot;list&quot;&gt;    &lt;p id=&quot;java&quot;&gt;Java&lt;/p &gt;    &lt;p id=&quot;python&quot;&gt;Python&lt;/p &gt;    &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p &gt;    &lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p &gt;  &lt;!-- 添加元素 --&gt;&lt;/div&gt;

上述代码中，我们是获取DOM元素后再进行添加操作，这个js节点是已经存在当前文档树中，因此这个节点首先会从原先的位置删除，再插入到新的位置
如果动态添加新的节点，则先创建一个新的节点，然后插入到指定的位置
const list = document.getElementById(&#x27;list&#x27;),const haskell = document.createElement(&#x27;p&#x27;);haskell.id = &#x27;haskell&#x27;;haskell.innerText = &#x27;Haskell&#x27;;list.appendChild(haskell);



insertBefore把子节点插入到指定的位置，使用方法如下：
parentElement.insertBefore(newElement, referenceElement)

子节点会插入到referenceElement之前
setAttribute在指定元素中添加一个属性节点，如果元素中已有该属性改变属性值
const div = document.getElementById(&#x27;id&#x27;)div.setAttribute(&#x27;class&#x27;, &#x27;white&#x27;);//第一个参数属性名，第二个参数属性值。



删除节点删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的removeChild把自己删掉
// 拿到待删除节点:const self = document.getElementById(&#x27;to-be-removed&#x27;);// 拿到父节点:const parent = self.parentElement;// 删除:const removed = parent.removeChild(self);removed === self; // true

删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置
相关链接https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中执行上下文和执行栈是什么？</title>
    <url>/2024/06/24/JavaScript-context-stack/</url>
    <content><![CDATA[
一、执行上下文简单的来说，执行上下文是一种对Javascript代码执行环境的抽象概念，也就是说只要有Javascript代码运行，那么它就一定是运行在执行上下文中
执行上下文的类型分为三种：

全局执行上下文：只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象
函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文
Eval 函数执行上下文： 指的是运行在 eval 函数中的代码，很少用而且不建议使用

下面给出全局上下文和函数上下文的例子：
 
紫色框住的部分为全局上下文，蓝色和橘色框起来的是不同的函数上下文。只有全局上下文（的变量）能被其他任何上下文访问
可以有任意多个函数上下文，每次调用函数创建一个新的上下文，会创建一个私有作用域，函数内部声明的任何变量都不能在当前函数作用域外部直接访问
二、生命周期执行上下文的生命周期包括三个阶段：创建阶段 → 执行阶段 → 回收阶段
创建阶段创建阶段即当函数被调用，但未执行任何其内部代码之前
创建阶段做了三件事：

确定 this 的值，也被称为 This Binding
LexicalEnvironment（词法环境） 组件被创建
VariableEnvironment（变量环境） 组件被创建

伪代码如下：
ExecutionContext = &#123;    ThisBinding = &lt;this value&gt;,     // 确定this   LexicalEnvironment = &#123; ... &#125;,   // 词法环境  VariableEnvironment = &#123; ... &#125;,  // 变量环境&#125;



This Binding确定this的值我们前面讲到，this的值是在执行的时候才能确认，定义的时候不能确认
词法环境词法环境有两个组成部分：

全局环境：是一个没有外部环境的词法环境，其外部环境引用为 null，有一个全局对象，this 的值指向这个全局对象

函数环境：用户在函数中定义的变量被存储在环境记录中，包含了arguments 对象，外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境


伪代码如下：
GlobalExectionContext = &#123;  // 全局执行上下文  LexicalEnvironment: &#123;       // 词法环境    EnvironmentRecord: &#123;     // 环境记录      Type: &quot;Object&quot;,           // 全局环境      // 标识符绑定在这里       outer: &lt;null&gt;           // 对外部环境的引用  &#125;  &#125;FunctionExectionContext = &#123; // 函数执行上下文  LexicalEnvironment: &#123;     // 词法环境    EnvironmentRecord: &#123;    // 环境记录      Type: &quot;Declarative&quot;,      // 函数环境      // 标识符绑定在这里      // 对外部环境的引用      outer: &lt;Global or outer function environment reference&gt;    &#125;  &#125;



变量环境变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性
在 ES6 中，词法环境和变量环境的区别在于前者用于存储函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）绑定
举个例子
let a = 20;  const b = 30;  var c;function multiply(e, f) &#123;   var g = 20;   return e * f * g;  &#125;c = multiply(20, 30);

执行上下文如下：
GlobalExectionContext = &#123;  ThisBinding: &lt;Global Object&gt;,  LexicalEnvironment: &#123;  // 词法环境    EnvironmentRecord: &#123;        Type: &quot;Object&quot;,        // 标识符绑定在这里        a: &lt; uninitialized &gt;,        b: &lt; uninitialized &gt;,        multiply: &lt; func &gt;      &#125;      outer: &lt;null&gt;    &#125;,  VariableEnvironment: &#123;  // 变量环境    EnvironmentRecord: &#123;        Type: &quot;Object&quot;,        // 标识符绑定在这里        c: undefined,      &#125;      outer: &lt;null&gt;    &#125;  &#125;FunctionExectionContext = &#123;       ThisBinding: &lt;Global Object&gt;,  LexicalEnvironment: &#123;      EnvironmentRecord: &#123;        Type: &quot;Declarative&quot;,        // 标识符绑定在这里        Arguments: &#123;0: 20, 1: 30, length: 2&#125;,      &#125;,      outer: &lt;GlobalLexicalEnvironment&gt;    &#125;,  VariableEnvironment: &#123;      EnvironmentRecord: &#123;        Type: &quot;Declarative&quot;,        // 标识符绑定在这里        g: undefined      &#125;,      outer: &lt;GlobalLexicalEnvironment&gt;    &#125;  &#125;

留意上面的代码，let和const定义的变量a和b在创建阶段没有被赋值，但var声明的变量从在创建阶段被赋值为undefined
这是因为，创建阶段，会在代码中扫描变量和函数声明，然后将函数声明存储在环境中
但变量会被初始化为undefined(var声明的情况下)和保持uninitialized(未初始化状态)(使用let和const声明的情况下)
这就是变量提升的实际原因
执行阶段在这阶段，执行变量赋值、代码执行
如果 Javascript 引擎在源代码中声明的实际位置找不到变量的值，那么将为其分配 undefined 值
回收阶段执行上下文出栈等待虚拟机回收执行上下文
二、执行栈执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文
 
当Javascript引擎开始执行你第一行脚本代码的时候，它就会创建一个全局执行上下文然后将它压到执行栈中
每当引擎碰到一个函数的时候，它就会创建一个函数执行上下文，然后将这个执行上下文压到执行栈中
引擎会执行位于执行栈栈顶的执行上下文(一般是函数执行上下文)，当该函数执行结束后，对应的执行上下文就会被弹出，然后控制流程到达执行栈的下一个执行上下文
举个例子：
let a = &#x27;Hello World!&#x27;;function first() &#123;  console.log(&#x27;Inside first function&#x27;);  second();  console.log(&#x27;Again inside first function&#x27;);&#125;function second() &#123;  console.log(&#x27;Inside second function&#x27;);&#125;first();console.log(&#x27;Inside Global Execution Context&#x27;);

转化成图的形式
 
简单分析一下流程：

创建全局上下文请压入执行栈
first函数被调用，创建函数执行上下文并压入栈
执行first函数过程遇到second函数，再创建一个函数执行上下文并压入栈
second函数执行完毕，对应的函数执行上下文被推出执行栈，执行下一个执行上下文first函数
first函数执行完毕，对应的函数执行上下文也被推出栈中，然后执行全局上下文
所有代码执行完毕，全局上下文也会被推出栈中，程序结束

参考文献
https://zhuanlan.zhihu.com/p/107552264

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>大文件上传如何做断点续传？</title>
    <url>/2024/06/25/JavaScript-continue-to-upload/</url>
    <content><![CDATA[ 
一、是什么不管怎样简单的需求，在量级达到一定层次时，都会变得异常复杂
文件上传简单，文件变大就复杂
上传大文件时，以下几个变量会影响我们的用户体验

服务器处理数据的能力
请求超时
网络波动

上传时间会变长，高频次文件上传失败，失败后又需要重新上传等等
为了解决上述问题，我们需要对大文件上传单独处理
这里涉及到分片上传及断点续传两个概念
分片上传分片上传，就是将所要上传的文件，按照一定的大小，将整个文件分隔成多个数据块（Part）来进行分片上传
如下图
 
上传完之后再由服务端对所有上传的文件进行汇总整合成原始的文件
大致流程如下：

将需要上传的文件按照一定的分割规则，分割成相同大小的数据块；
初始化一个分片上传任务，返回本次分片上传唯一标识；
按照一定的策略（串行或并行）发送各个分片数据块；
发送完成后，服务端根据判断数据上传是否完整，如果完整，则进行数据块合成得到原始文件

断点续传断点续传指的是在下载或上传时，将下载或上传任务人为的划分为几个部分
每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载未完成的部分，而没有必要从头开始上传下载。用户可以节省时间，提高速度
一般实现方式有两种：

服务器端返回，告知从哪开始
浏览器端自行处理

上传过程中将文件在服务器写为临时文件，等全部写完了（文件上传完），将此临时文件重命名为正式文件即可
如果中途上传中断过，下次上传的时候根据当前临时文件大小，作为在客户端读取文件的偏移量，从此位置继续读取文件数据块，上传到服务器从此偏移量继续写入文件即可
二、实现思路整体思路比较简单，拿到文件，保存文件唯一性标识，切割文件，分段上传，每次上传一段，根据唯一性标识判断文件上传进度，直到文件的全部片段上传完毕

下面的内容都是伪代码
读取文件内容：
const input = document.querySelector(&#x27;input&#x27;);input.addEventListener(&#x27;change&#x27;, function() &#123;    var file = this.files[0];&#125;);

可以使用md5实现文件的唯一性
const md5code = md5(file);

然后开始对文件进行分割
var reader = new FileReader();reader.readAsArrayBuffer(file);reader.addEventListener(&quot;load&quot;, function(e) &#123;    //每10M切割一段,这里只做一个切割演示，实际切割需要循环切割，    var slice = e.target.result.slice(0, 10*1024*1024);&#125;);

h5上传一个（一片）
const formdata = new FormData();formdata.append(&#x27;0&#x27;, slice);//这里是有一个坑的，部分设备无法获取文件名称，和文件类型，这个在最后给出解决方案formdata.append(&#x27;filename&#x27;, file.filename);var xhr = new XMLHttpRequest();xhr.addEventListener(&#x27;load&#x27;, function() &#123;    //xhr.responseText&#125;);xhr.open(&#x27;POST&#x27;, &#x27;&#x27;);xhr.send(formdata);xhr.addEventListener(&#x27;progress&#x27;, updateProgress);xhr.upload.addEventListener(&#x27;progress&#x27;, updateProgress);function updateProgress(event) &#123;    if (event.lengthComputable) &#123;        //进度条    &#125;&#125;

这里给出常见的图片和视频的文件类型判断
function checkFileType(type, file, back) &#123;/*** type png jpg mp4 ...* file input.change=&gt; this.files[0]* back callback(boolean)*/    var args = arguments;    if (args.length != 3) &#123;        back(0);    &#125;    var type = args[0]; // type = &#x27;(png|jpg)&#x27; , &#x27;png&#x27;    var file = args[1];    var back = typeof args[2] == &#x27;function&#x27; ? args[2] : function() &#123;&#125;;    if (file.type == &#x27;&#x27;) &#123;        // 如果系统无法获取文件类型，则读取二进制流，对二进制进行解析文件类型        var imgType = [            &#x27;ff d8 ff&#x27;, //jpg            &#x27;89 50 4e&#x27;, //png            &#x27;0 0 0 14 66 74 79 70 69 73 6F 6D&#x27;, //mp4            &#x27;0 0 0 18 66 74 79 70 33 67 70 35&#x27;, //mp4            &#x27;0 0 0 0 66 74 79 70 33 67 70 35&#x27;, //mp4            &#x27;0 0 0 0 66 74 79 70 4D 53 4E 56&#x27;, //mp4            &#x27;0 0 0 0 66 74 79 70 69 73 6F 6D&#x27;, //mp4            &#x27;0 0 0 18 66 74 79 70 6D 70 34 32&#x27;, //m4v            &#x27;0 0 0 0 66 74 79 70 6D 70 34 32&#x27;, //m4v            &#x27;0 0 0 14 66 74 79 70 71 74 20 20&#x27;, //mov            &#x27;0 0 0 0 66 74 79 70 71 74 20 20&#x27;, //mov            &#x27;0 0 0 0 6D 6F 6F 76&#x27;, //mov            &#x27;4F 67 67 53 0 02&#x27;, //ogg            &#x27;1A 45 DF A3&#x27;, //ogg            &#x27;52 49 46 46 x x x x 41 56 49 20&#x27;, //avi (RIFF fileSize fileType LIST)(52 49 46 46,DC 6C 57 09,41 56 49 20,4C 49 53 54)        ];        var typeName = [            &#x27;jpg&#x27;,            &#x27;png&#x27;,            &#x27;mp4&#x27;,            &#x27;mp4&#x27;,            &#x27;mp4&#x27;,            &#x27;mp4&#x27;,            &#x27;mp4&#x27;,            &#x27;m4v&#x27;,            &#x27;m4v&#x27;,            &#x27;mov&#x27;,            &#x27;mov&#x27;,            &#x27;mov&#x27;,            &#x27;ogg&#x27;,            &#x27;ogg&#x27;,            &#x27;avi&#x27;,        ];        var sliceSize = /png|jpg|jpeg/.test(type) ? 3 : 12;        var reader = new FileReader();        reader.readAsArrayBuffer(file);        reader.addEventListener(&quot;load&quot;, function(e) &#123;            var slice = e.target.result.slice(0, sliceSize);            reader = null;            if (slice &amp;&amp; slice.byteLength == sliceSize) &#123;                var view = new Uint8Array(slice);                var arr = [];                view.forEach(function(v) &#123;                    arr.push(v.toString(16));                &#125;);                view = null;                var idx = arr.join(&#x27; &#x27;).indexOf(imgType);                if (idx &gt; -1) &#123;                    back(typeName[idx]);                &#125; else &#123;                    arr = arr.map(function(v) &#123;                        if (i &gt; 3 &amp;&amp; i &lt; 8) &#123;                            return &#x27;x&#x27;;                        &#125;                        return v;                    &#125;);                    var idx = arr.join(&#x27; &#x27;).indexOf(imgType);                    if (idx &gt; -1) &#123;                        back(typeName[idx]);                    &#125; else &#123;                        back(false);                    &#125;                &#125;            &#125; else &#123;                back(false);            &#125;        &#125;);    &#125; else &#123;        var type = file.name.match(/\.(\w+)$/)[1];        back(type);    &#125;&#125;

调用方法如下
checkFileType(&#x27;(mov|mp4|avi)&#x27;,file,function(fileType)&#123;    // fileType = mp4,    // 如果file的类型不在枚举之列，则返回false&#125;);

上面上传文件的一步，可以改成：
formdata.append(&#x27;filename&#x27;, md5code+&#x27;.&#x27;+fileType);

有了切割上传后，也就有了文件唯一标识信息，断点续传变成了后台的一个小小的逻辑判断
后端主要做的内容为：根据前端传给后台的md5值，到服务器磁盘查找是否有之前未完成的文件合并信息（也就是未完成的半成品文件切片），取到之后根据上传切片的数量，返回数据告诉前端开始从第几节上传
如果想要暂停切片的上传，可以使用XMLHttpRequest 的 abort 方法
三、使用场景
大文件加速上传：当文件大小超过预期大小时，使用分片上传可实现并行上传多个 Part， 以加快上传速度
网络环境较差：建议使用分片上传。当出现上传失败的时候，仅需重传失败的Part
流式上传：可以在需要上传的文件大小还不确定的情况下开始上传。这种场景在视频监控等行业应用中比较常见

小结当前的伪代码，只是提供一个简单的思路，想要把事情做到极致，我们还需要考虑到更多场景，比如

切片上传失败怎么办
上传过程中刷新页面怎么办
如何进行并行上传
切片什么时候按数量切，什么时候按大小切
如何结合 Web Worker 处理大文件上传
如何实现秒传

人生又何尝不是如此，极致的人生体验有无限可能，越是后面才发现越是精彩 _
参考文献
https://segmentfault.com/a/1190000009448892
https://baike.baidu.com/

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝浅拷贝的区别？如何实现一个深拷贝？</title>
    <url>/2024/06/27/JavaScript-copy/</url>
    <content><![CDATA[ 
一、数据类型存储前面文章我们讲到，JavaScript中存在两大数据类型：

基本类型
引用类型

基本类型数据保存在在栈内存中
引用类型数据保存在堆内存中，引用数据类型的变量是一个指向堆内存中实际对象的引用，存在栈中
二、浅拷贝浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝
如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址
即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址
下面简单实现一个浅拷贝
function shallowClone(obj) &#123;    const newObj = &#123;&#125;;    for(let prop in obj) &#123;        if(obj.hasOwnProperty(prop))&#123;            newObj[prop] = obj[prop];        &#125;    &#125;    return newObj;&#125;

在JavaScript中，存在浅拷贝的现象有：

Object.assign
Array.prototype.slice(), Array.prototype.concat()
使用拓展运算符实现的复制

Object.assignvar obj = &#123;    age: 18,    nature: [&#x27;smart&#x27;, &#x27;good&#x27;],    names: &#123;        name1: &#x27;fx&#x27;,        name2: &#x27;xka&#x27;    &#125;,    love: function () &#123;        console.log(&#x27;fx is a great girl&#x27;)    &#125;&#125;var newObj = Object.assign(&#123;&#125;, fxObj);



slice()const fxArr = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]const fxArrs = fxArr.slice(0)fxArrs[1] = &quot;love&quot;;console.log(fxArr) // [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]console.log(fxArrs) // [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;]



concat()const fxArr = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]const fxArrs = fxArr.concat()fxArrs[1] = &quot;love&quot;;console.log(fxArr) // [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]console.log(fxArrs) // [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;]







拓展运算符const fxArr = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]const fxArrs = [...fxArr]fxArrs[1] = &quot;love&quot;;console.log(fxArr) // [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]console.log(fxArrs) // [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;]





三、深拷贝深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性
常见的深拷贝方式有：

_.cloneDeep()

jQuery.extend()

JSON.stringify()

手写循环递归


_.cloneDeep()const _ = require(&#x27;lodash&#x27;);const obj1 = &#123;    a: 1,    b: &#123; f: &#123; g: 1 &#125; &#125;,    c: [1, 2, 3]&#125;;const obj2 = _.cloneDeep(obj1);console.log(obj1.b.f === obj2.b.f);// false



jQuery.extend()const $ = require(&#x27;jquery&#x27;);const obj1 = &#123;    a: 1,    b: &#123; f: &#123; g: 1 &#125; &#125;,    c: [1, 2, 3]&#125;;const obj2 = $.extend(true, &#123;&#125;, obj1);console.log(obj1.b.f === obj2.b.f); // false





JSON.stringify()const obj2=JSON.parse(JSON.stringify(obj1));

但是这种方式存在弊端，会忽略undefined、symbol和函数
const obj = &#123;    name: &#x27;A&#x27;,    name1: undefined,    name3: function() &#123;&#125;,    name4:  Symbol(&#x27;A&#x27;)&#125;const obj2 = JSON.parse(JSON.stringify(obj));console.log(obj2); // &#123;name: &quot;A&quot;&#125;



循环递归function deepClone(obj, hash = new WeakMap()) &#123;  if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作  if (obj instanceof Date) return new Date(obj);  if (obj instanceof RegExp) return new RegExp(obj);  // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝  if (typeof obj !== &quot;object&quot;) return obj;  // 是对象的话就要进行深拷贝  if (hash.get(obj)) return hash.get(obj);  let cloneObj = new obj.constructor();  // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身  hash.set(obj, cloneObj);  for (let key in obj) &#123;    if (obj.hasOwnProperty(key)) &#123;      // 实现一个递归拷贝      cloneObj[key] = deepClone(obj[key], hash);    &#125;  &#125;  return cloneObj;&#125;







四、区别下面首先借助两张图，可以更加清晰看到浅拷贝与深拷贝的区别
 
从上图发现，浅拷贝和深拷贝都创建出一个新的对象，但在复制对象属性的时候，行为就不一样
浅拷贝只复制属性指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存，修改对象属性会影响原对象
// 浅拷贝const obj1 = &#123;    name : &#x27;init&#x27;,    arr : [1,[2,3],4],&#125;;const obj3=shallowClone(obj1) // 一个浅拷贝方法obj3.name = &quot;update&quot;;obj3.arr[1] = [5,6,7] ; // 新旧对象还是共享同一块内存console.log(&#x27;obj1&#x27;,obj1) // obj1 &#123; name: &#x27;init&#x27;,  arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;console.log(&#x27;obj3&#x27;,obj3) // obj3 &#123; name: &#x27;update&#x27;, arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;

但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象
// 深拷贝const obj1 = &#123;    name : &#x27;init&#x27;,    arr : [1,[2,3],4],&#125;;const obj4=deepClone(obj1) // 一个深拷贝方法obj4.name = &quot;update&quot;;obj4.arr[1] = [5,6,7] ; // 新对象跟原对象不共享内存console.log(&#x27;obj1&#x27;,obj1) // obj1 &#123; name: &#x27;init&#x27;, arr: [ 1, [ 2, 3 ], 4 ] &#125;console.log(&#x27;obj4&#x27;,obj4) // obj4 &#123; name: &#x27;update&#x27;, arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;



小结前提为拷贝类型为引用类型的情况下：

浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址

深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址


]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的数据类型？存储上的差别？</title>
    <url>/2024/06/28/JavaScript-data-type/</url>
    <content><![CDATA[ 
前言在JavaScript中，我们可以分成两种类型：

基本类型
复杂类型

两种类型的区别是：存储位置不同
一、基本类型基本类型主要为以下6种：

Number
String
Boolean
Undefined
null
symbol

Number数值最常见的整数类型格式则为十进制，还可以设置八进制（零开头）、十六进制（0x开头）
let intNum = 55 // 10进制的55let num1 = 070 // 8进制的56let hexNum1 = 0xA //16进制的10

浮点类型则在数值汇总必须包含小数点，还可通过科学计数法表示
let floatNum1 = 1.1;let floatNum2 = 0.1;let floatNum3 = .1; // 有效，但不推荐let floatNum = 3.125e7; // 等于 31250000

在数值类型中，存在一个特殊数值NaN，意为”不是数值”，用于表示本来要返回数值的操作失败了（而不是抛出错误）
console.log(0/0); // NaNconsole.log(-0/+0); // NaN



UndefinedUndefined 类型只有一个值，就是特殊值 undefined。当使用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋予了 undefined 值
let message;console.log(message == undefined); // true

包含 undefined 值的变量跟未定义变量是有区别的
let message; // 这个变量被声明了，只是值为 undefinedconsole.log(message); // &quot;undefined&quot;console.log(age); // 没有声明过这个变量，报错



String字符串可以使用双引号（”）、单引号（’）或反引号（&#96;）标示
let firstName = &quot;John&quot;;let lastName = &#x27;Jacob&#x27;;let lastName = `Jingleheimerschmidt`

字符串是不可变的，意思是一旦创建，它们的值就不能变了
let lang = &quot;Java&quot;;lang = lang + &quot;Script&quot;;  // 先销毁再创建



NullNull 类型同样只有一个值，即特殊值 null
逻辑上讲， null 值表示一个空对象指针，这也是给typeof 传一个 null 会返回 &quot;object&quot; 的原因
let car = null;console.log(typeof car); // &quot;object&quot;

undefined 值是由 null 值派生而来
console.log(null == undefined); // true

只要变量要保存对象，而当时又没有那个对象可保存，就可用 null 来填充该变量
BooleanBoolean （布尔值）类型有两个字面值： true 和 false
通过Boolean可以将其他类型的数据转化成布尔值
规则如下：
数据类型      				转换为 true 的值      				转换为 false 的值 String        				 非空字符串          					&quot;&quot;  Number 				非零数值（包括无穷值）						0 、 NaN  Object 					 任意对象 							   nullUndefined 					N/A （不存在） 						undefined



SymbolSymbol （符号）是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险
let genericSymbol = Symbol();let otherGenericSymbol = Symbol();console.log(genericSymbol == otherGenericSymbol); // falselet fooSymbol = Symbol(&#x27;foo&#x27;);let otherFooSymbol = Symbol(&#x27;foo&#x27;);console.log(fooSymbol == otherFooSymbol); // false





二、引用类型复杂类型统称为Object，我们这里主要讲述下面三种：

Object
Array
Function

Object创建object常用方式为对象字面量表示法，属性名可以是字符串或数值
let person = &#123;    name: &quot;Nicholas&quot;,    &quot;age&quot;: 29,    5: true&#125;;



ArrayJavaScript数组是一组有序的数据，但跟其他语言不同的是，数组中每个槽位可以存储任意类型的数据。并且，数组也是动态大小的，会随着数据添加而自动增长
let colors = [&quot;red&quot;, 2, &#123;age: 20 &#125;]colors.push(2)



Function函数实际上是对象，每个函数都是 Function类型的实例，而 Function 也有属性和方法，跟其他引用类型一样
函数存在三种常见的表达方式：

函数声明

// 函数声明function sum (num1, num2) &#123;    return num1 + num2;&#125;


函数表达式

let sum = function(num1, num2) &#123;    return num1 + num2;&#125;;


箭头函数

函数声明和函数表达式两种方式
let sum = (num1, num2) =&gt; &#123;    return num1 + num2;&#125;;



其他引用类型除了上述说的三种之外，还包括Date、RegExp、Map、Set等……
三、存储区别基本数据类型和引用数据类型存储在内存中的位置不同：

基本数据类型存储在栈中

引用类型的对象存储于堆中


当我们把变量赋值给一个变量时，解析器首先要确认的就是这个值是基本类型值还是引用类型值
下面来举个例子
基本类型let a = 10;let b = a; // 赋值操作b = 20;console.log(a); // 10值

a的值为一个基本类型，是存储在栈中，将a的值赋给b，虽然两个变量的值相等，但是两个变量保存了两个不同的内存地址
下图演示了基本类型赋值的过程：
 
引用类型var obj1 = &#123;&#125;var obj2 = obj1;obj2.name = &quot;Xxx&quot;;console.log(obj1.name); // xxx

引用类型数据存放在堆中，每个堆内存对象都有对应的引用地址指向它，引用地址存放在栈中。
obj1是一个引用类型，在赋值操作过程汇总，实际是将堆内存对象在栈内存的引用地址复制了一份给了obj2，实际上他们共同指向了同一个堆内存对象，所以更改obj2会对obj1产生影响
下图演示这个引用类型赋值过程
 
小结
声明变量时不同的内存地址分配：
简单类型的值存放在栈中，在栈中存放的是对应的值
引用类型对应的值存储在堆中，在栈中存放的是指向堆内存的地址


不同的类型数据导致赋值变量时的不同：
简单类型赋值，是生成相同的值，两个对象对应不同的地址
复杂类型赋值，是将保存对象的内存地址赋值给另一个变量。也就是两个变量指向堆内存中同一个对象



]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是防抖和节流？有什么区别？如何实现？</title>
    <url>/2024/07/02/JavaScript-debounce-throttle/</url>
    <content><![CDATA[ 
一、是什么本质上是优化高频率执行代码的一种手段
如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能
为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用 防抖（debounce） 和 节流（throttle） 的方式来减少调用频率
定义
节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效
防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时

一个经典的比喻:
想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应
假设电梯有两种运行策略 debounce 和 throttle，超时设定为15秒，不考虑容量限制
电梯第一个人进来后，15秒后准时运送一次，这是节流
电梯第一个人进来后，等待15秒。如果过程中又有人进来，15秒等待重新计时，直到15秒后开始运送，这是防抖
代码实现节流完成节流可以使用时间戳与定时器的写法
使用时间戳写法，事件会立即执行，停止触发后没有办法再次执行
function throttled1(fn, delay = 500) &#123;    let oldtime = Date.now()    return function (...args) &#123;        let newtime = Date.now()        if (newtime - oldtime &gt;= delay) &#123;            fn.apply(null, args)            oldtime = Date.now()        &#125;    &#125;&#125;

使用定时器写法，delay毫秒后第一次执行，第二次事件停止触发后依然会再一次执行
function throttled2(fn, delay = 500) &#123;    let timer = null    return function (...args) &#123;        if (!timer) &#123;            timer = setTimeout(() =&gt; &#123;                fn.apply(this, args)                timer = null            &#125;, delay);        &#125;    &#125;&#125;

可以将时间戳写法的特性与定时器写法的特性相结合，实现一个更加精确的节流。实现如下
function throttled(fn, delay) &#123;    let timer = null    let starttime = Date.now()    return function () &#123;        let curTime = Date.now() // 当前时间        let remaining = delay - (curTime - starttime)  // 从上一次到现在，还剩下多少多余时间        let context = this        let args = arguments        clearTimeout(timer)        if (remaining &lt;= 0) &#123;            fn.apply(context, args)            starttime = Date.now()        &#125; else &#123;            timer = setTimeout(fn, remaining);        &#125;    &#125;&#125;

防抖简单版本的实现
function debounce(func, wait) &#123;    let timeout;    return function () &#123;        let context = this; // 保存this指向        let args = arguments; // 拿到event对象        clearTimeout(timeout)        timeout = setTimeout(function()&#123;            func.apply(context, args)        &#125;, wait);    &#125;&#125;

防抖如果需要立即执行，可加入第三个参数用于判断，实现如下：
function debounce(func, wait, immediate) &#123;    let timeout;    return function () &#123;        let context = this;        let args = arguments;        if (timeout) clearTimeout(timeout); // timeout 不为null        if (immediate) &#123;            let callNow = !timeout; // 第一次会立即执行，以后只有事件执行后才会再次触发            timeout = setTimeout(function () &#123;                timeout = null;            &#125;, wait)            if (callNow) &#123;                func.apply(context, args)            &#125;        &#125;        else &#123;            timeout = setTimeout(function () &#123;                func.apply(context, args)            &#125;, wait);        &#125;    &#125;&#125;

二、区别相同点：

都可以通过使用 setTimeout 实现
目的都是，降低回调执行频率。节省计算资源

不同点：

函数防抖，在一段连续操作结束后，处理回调，利用clearTimeout 和 setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能
函数防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次

例如，都设置时间频率为500ms，在2秒时间内，频繁触发函数，节流，每隔 500ms 就执行一次。防抖，则不管调动多少次方法，在2s后，只会执行一次
如下图所示：
 
三、应用场景防抖在连续的事件，只需触发一次回调的场景有：

搜索框搜索输入。只需用户最后一次输入完，再发送请求
手机号、邮箱验证输入检测
窗口大小resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。

节流在间隔一段时间执行一次回调的场景有：

滚动加载，加载更多或滚到底部监听
搜索框，搜索联想功能

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的事件模型</title>
    <url>/2024/07/20/JavaScript-event-Model/</url>
    <content><![CDATA[
一、事件与事件流javascript中的事件，可以理解就是在HTML文档或者浏览器中发生的一种交互操作，使得网页具备互动性， 常见的有加载事件、鼠标事件、自定义事件等
由于DOM是一个树结构，如果在父子节点绑定事件时候，当触发子节点的时候，就存在一个顺序问题，这就涉及到了事件流的概念
事件流都会经历三个阶段：

事件捕获阶段(capture phase)
处于目标阶段(target phase)
事件冒泡阶段(bubbling phase)

 
事件冒泡是一种从下往上的传播方式，由最具体的元素（触发节点）然后逐渐向上传播到最不具体的那个节点，也就是DOM中最高层的父节点
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;Event Bubbling&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;button id=&quot;clickMe&quot;&gt;Click Me&lt;/button&gt;    &lt;/body&gt;&lt;/html&gt;

然后，我们给button和它的父元素，加入点击事件
var button = document.getElementById(&#x27;clickMe&#x27;);button.onclick = function() &#123;  console.log(&#x27;1.Button&#x27;);&#125;;document.body.onclick = function() &#123;  console.log(&#x27;2.body&#x27;);&#125;;document.onclick = function() &#123;  console.log(&#x27;3.document&#x27;);&#125;;window.onclick = function() &#123;  console.log(&#x27;4.window&#x27;);&#125;;

点击按钮，输出如下
1.button2.body3.document4.window

点击事件首先在button元素上发生，然后逐级向上传播
事件捕获与事件冒泡相反，事件最开始由不太具体的节点最早接受事件, 而最具体的节点（触发节点）最后接受事件
二、事件模型事件模型可以分为三种：

原始事件模型（DOM0级）
标准事件模型（DOM2级）
IE事件模型（基本不用）

原始事件模型事件绑定监听函数比较简单, 有两种方式：

HTML代码中直接绑定

&lt;input type=&quot;button&quot; onclick=&quot;fun()&quot;&gt;


通过JS代码绑定

var btn = document.getElementById(&#x27;.btn&#x27;);btn.onclick = fun;

特性
绑定速度快

DOM0级事件具有很好的跨浏览器优势，会以最快的速度绑定，但由于绑定速度太快，可能页面还未完全加载出来，以至于事件可能无法正常运行

只支持冒泡，不支持捕获

同一个类型的事件只能绑定一次


&lt;input type=&quot;button&quot; id=&quot;btn&quot; onclick=&quot;fun1()&quot;&gt;var btn = document.getElementById(&#x27;.btn&#x27;);btn.onclick = fun2;

如上，当希望为同一个元素绑定多个同类型事件的时候（上面的这个btn元素绑定2个点击事件），是不被允许的，后绑定的事件会覆盖之前的事件
删除 DOM0 级事件处理程序只要将对应事件属性置为null即可
btn.onclick = null;





标准事件模型在该事件模型中，一次事件共有三个过程:

事件捕获阶段：事件从document一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行
事件处理阶段：事件到达目标元素, 触发目标元素的监听函数
事件冒泡阶段：事件从目标元素冒泡到document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行

事件绑定监听函数的方式如下:
addEventListener(eventType, handler, useCapture)

事件移除监听函数的方式如下:
removeEventListener(eventType, handler, useCapture)

参数如下：

eventType指定事件类型(不要加on)
handler是事件处理函数
useCapture是一个boolean用于指定是否在捕获阶段进行处理，一般设置为false与IE浏览器保持一致

举个例子：
var btn = document.getElementById(&#x27;.btn&#x27;);btn.addEventListener(‘click’, showMessage, false);btn.removeEventListener(‘click’, showMessage, false);

特性
可以在一个DOM元素上绑定多个事件处理器，各自并不会冲突

btn.addEventListener(‘click’, showMessage1, false);btn.addEventListener(‘click’, showMessage2, false);btn.addEventListener(‘click’, showMessage3, false);


执行时机

当第三个参数(useCapture)设置为true就在捕获过程中执行，反之在冒泡过程中执行处理函数
下面举个例子：
&lt;div id=&#x27;div&#x27;&gt;    &lt;p id=&#x27;p&#x27;&gt;        &lt;span id=&#x27;span&#x27;&gt;Click Me!&lt;/span&gt;    &lt;/p &gt;&lt;/div&gt;

设置点击事件
var div = document.getElementById(&#x27;div&#x27;);var p = document.getElementById(&#x27;p&#x27;);function onClickFn (event) &#123;    var tagName = event.currentTarget.tagName;    var phase = event.eventPhase;    console.log(tagName, phase);&#125;div.addEventListener(&#x27;click&#x27;, onClickFn, false);p.addEventListener(&#x27;click&#x27;, onClickFn, false);

上述使用了eventPhase，返回一个代表当前执行阶段的整数值。1为捕获阶段、2为事件对象触发阶段、3为冒泡阶段
点击Click Me!，输出如下
P 3DIV 3

可以看到，p和div都是在冒泡阶段响应了事件，由于冒泡的特性，裹在里层的p率先做出响应
如果把第三个参数都改为true
div.addEventListener(&#x27;click&#x27;, onClickFn, true);p.addEventListener(&#x27;click&#x27;, onClickFn, true);

输出如下
DIV 1P 1

两者都是在捕获阶段响应事件，所以div比p标签先做出响应
IE事件模型IE事件模型共有两个过程:

事件处理阶段：事件到达目标元素, 触发目标元素的监听函数。
事件冒泡阶段：事件从目标元素冒泡到document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行

事件绑定监听函数的方式如下:
attachEvent(eventType, handler)

事件移除监听函数的方式如下:
detachEvent(eventType, handler)

举个例子：
var btn = document.getElementById(&#x27;.btn&#x27;);btn.attachEvent(‘onclick’, showMessage);btn.detachEvent(‘onclick’, showMessage);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是事件代理？应用场景？</title>
    <url>/2024/07/11/JavaScript-event-agent/</url>
    <content><![CDATA[
一、是什么事件代理，俗地来讲，就是把一个元素响应事件（click、keydown……）的函数委托到另一个元素
前面讲到，事件流的都会经过三个阶段： 捕获阶段 -&gt; 目标阶段 -&gt; 冒泡阶段，而事件委托就是在冒泡阶段完成
事件委托，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，而不是目标元素
当事件响应到目标元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数
下面举个例子：
比如一个宿舍的同学同时快递到了，一种笨方法就是他们一个个去领取
较优方法就是把这件事情委托给宿舍长，让一个人出去拿好所有快递，然后再根据收件人一一分发给每个同学
在这里，取快递就是一个事件，每个同学指的是需要响应事件的 DOM 元素，而出去统一领取快递的宿舍长就是代理的元素
所以真正绑定事件的是这个元素，按照收件人分发快递的过程就是在事件执行中，需要判断当前响应的事件应该匹配到被代理元素中的哪一个或者哪几个
二、应用场景如果我们有一个列表，列表之中有大量的列表项，我们需要在点击列表项的时候响应一个事件
&lt;ul id=&quot;list&quot;&gt;  &lt;li&gt;item 1&lt;/li&gt;  &lt;li&gt;item 2&lt;/li&gt;  &lt;li&gt;item 3&lt;/li&gt;  ......  &lt;li&gt;item n&lt;/li&gt;&lt;/ul&gt;

如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的
// 获取目标元素const lis = document.getElementsByTagName(&quot;li&quot;)// 循环遍历绑定事件for (let i = 0; i &lt; lis.length; i++) &#123;    lis[i].onclick = function(e)&#123;        console.log(e.target.innerHTML)    &#125;&#125;

这时候就可以事件委托，把点击事件绑定在父级元素ul上面，然后执行事件的时候再去匹配目标元素
// 给父层元素绑定事件document.getElementById(&#x27;list&#x27;).addEventListener(&#x27;click&#x27;, function (e) &#123;    // 兼容性处理    var event = e || window.event;    var target = event.target || event.srcElement;    // 判断是否匹配目标元素    if (target.nodeName.toLocaleLowerCase === &#x27;li&#x27;) &#123;        console.log(&#x27;the content is: &#x27;, target.innerHTML);    &#125;&#125;);

还有一种场景是上述列表项并不多，我们给每个列表项都绑定了事件
但是如果用户能够随时动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件
如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的
举个例子：
下面html结构中，点击input可以动态添加元素
&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;btn&quot; value=&quot;添加&quot; /&gt;&lt;ul id=&quot;ul1&quot;&gt;    &lt;li&gt;item 1&lt;/li&gt;    &lt;li&gt;item 2&lt;/li&gt;    &lt;li&gt;item 3&lt;/li&gt;    &lt;li&gt;item 4&lt;/li&gt;&lt;/ul&gt;

使用事件委托
const oBtn = document.getElementById(&quot;btn&quot;);const oUl = document.getElementById(&quot;ul1&quot;);const num = 4;//事件委托，添加的子元素也有事件oUl.onclick = function (ev) &#123;    ev = ev || window.event;    const target = ev.target || ev.srcElement;    if (target.nodeName.toLowerCase() == &#x27;li&#x27;) &#123;        console.log(&#x27;the content is: &#x27;, target.innerHTML);    &#125;&#125;;//添加新节点oBtn.onclick = function () &#123;    num++;    const oLi = document.createElement(&#x27;li&#x27;);    oLi.innerHTML = `item $&#123;num&#125;`;    oUl.appendChild(oLi);&#125;;

可以看到，使用事件委托，在动态绑定事件的情况下是可以减少很多重复工作的
三、总结适合事件委托的事件有：click，mousedown，mouseup，keydown，keyup，keypress
从上面应用场景中，我们就可以看到使用事件委托存在两大优点：

减少整个页面所需的内存，提升整体性能
动态绑定，减少重复工作

但是使用事件委托也是存在局限性：

focus、blur 这些事件没有事件冒泡机制，所以无法进行委托绑定事件

mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的


如果把所有事件都用事件代理，可能会出现事件误判，即本不该被触发的事件被绑定上了事件
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>对事件循环的理解</title>
    <url>/2024/07/13/JavaScript-event-loop/</url>
    <content><![CDATA[ 
一、是什么首先，JavaScript 是一门单线程的语言，意味着同一时间内只能做一件事，但是这并不意味着单线程就是阻塞，而实现单线程非阻塞的方法就是事件循环
在JavaScript中，所有的任务都可以分为

同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行

异步任务：异步执行的任务，比如ajax网络请求，setTimeout 定时函数等


同步任务与异步任务的运行流程图如下：
 
从上面我们可以看到，同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就事件循环
二、宏任务与微任务如果将任务划分为同步任务和异步任务并不是那么的准确，举个例子：
console.log(1)setTimeout(()=&gt;&#123;    console.log(2)&#125;, 0)new Promise((resolve, reject)=&gt;&#123;    console.log(&#x27;new Promise&#x27;)    resolve()&#125;).then(()=&gt;&#123;    console.log(&#x27;then&#x27;)&#125;)console.log(3)

如果按照上面流程图来分析代码，我们会得到下面的执行步骤：

console.log(1) ，同步任务，主线程中执行
setTimeout() ，异步任务，放到 Event Table，0 毫秒后console.log(2) 回调推入 Event Queue 中
new Promise ，同步任务，主线程直接执行
.then ，异步任务，放到 Event Table
console.log(3)，同步任务，主线程执行

所以按照分析，它的结果应该是 1 &#x3D;&gt; &#39;new Promise&#39; &#x3D;&gt; 3 &#x3D;&gt; 2 &#x3D;&gt; &#39;then&#39;
但是实际结果是：1&#x3D;&gt;&#39;new Promise&#39;&#x3D;&gt; 3 &#x3D;&gt; &#39;then&#39; &#x3D;&gt; 2
出现分歧的原因在于异步任务执行顺序，事件队列其实是一个”先进先出”的数据结构，排在前面的事件会优先被主线程读取
例子中 setTimeout回调事件是先进入队列中的，按理说应该先于 .then 中的执行，但是结果却偏偏相反
原因在于异步任务还可以细分为微任务与宏任务
微任务一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前
常见的微任务有：

Promise.then

MutaionObserver

Object.observe（已废弃；Proxy 对象替代）

process.nextTick（Node.js）


宏任务宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合
常见的宏任务有：

script (可以理解为外层同步代码) 
setTimeout&#x2F;setInterval 
UI rendering&#x2F;UI事件 
postMessage、MessageChannel 
setImmediate、I&#x2F;O（Node.js）

这时候，事件循环，宏任务，微任务的关系如图所示
 
按照这个流程，它的执行机制是：

执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中
当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完

回到上面的题目
console.log(1)setTimeout(()=&gt;&#123;    console.log(2)&#125;, 0)new Promise((resolve, reject)=&gt;&#123;    console.log(&#x27;new Promise&#x27;)    resolve()&#125;).then(()=&gt;&#123;    console.log(&#x27;then&#x27;)&#125;)console.log(3)

流程如下
// 遇到 console.log(1) ，直接打印 1// 遇到定时器，属于新的宏任务，留着后面执行// 遇到 new Promise，这个是直接执行的，打印 &#x27;new Promise&#x27;// .then 属于微任务，放入微任务队列，后面再执行// 遇到 console.log(3) 直接打印 3// 好了本轮宏任务执行完毕，现在去微任务列表查看是否有微任务，发现 .then 的回调，执行它，打印 &#x27;then&#x27;// 当一次宏任务执行完，再去执行新的宏任务，这里就剩一个定时器的宏任务了，执行它，打印 2



三、async与awaitasync 是异步的意思，await 则可以理解为 async wait。所以可以理解async就是用来声明一个异步方法，而 await 是用来等待异步方法执行
asyncasync函数返回一个promise对象，下面两种方法是等效的
function f() &#123;    return Promise.resolve(&#x27;TEST&#x27;);&#125;// asyncF is equivalent to f!async function asyncF() &#123;    return &#x27;TEST&#x27;;&#125;

await正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值
async function f()&#123;    // 等同于    // return 123    return await 123&#125;f().then(v =&gt; console.log(v)) // 123

不管await后面跟着的是什么，await都会阻塞后面的代码
async function fn1 ()&#123;    console.log(1)    await fn2()    console.log(2) // 阻塞&#125;async function fn2 ()&#123;    console.log(&#x27;fn2&#x27;)&#125;fn1()console.log(3)

上面的例子中，await 会阻塞下面的代码（即加入微任务队列），先执行 async 外面的同步代码，同步代码执行完，再回到 async 函数中，再执行之前阻塞的代码
所以上述输出结果为：1，fn2，3，2
四、流程分析通过对上面的了解，我们对JavaScript对各种场景的执行顺序有了大致的了解
这里直接上代码：
async function async1() &#123;    console.log(&#x27;async1 start&#x27;)    await async2()    console.log(&#x27;async1 end&#x27;)&#125;async function async2() &#123;    console.log(&#x27;async2&#x27;)&#125;console.log(&#x27;script start&#x27;)setTimeout(function () &#123;    console.log(&#x27;settimeout&#x27;)&#125;)async1()new Promise(function (resolve) &#123;    console.log(&#x27;promise1&#x27;)    resolve()&#125;).then(function () &#123;    console.log(&#x27;promise2&#x27;)&#125;)console.log(&#x27;script end&#x27;)

分析过程：

执行整段代码，遇到 console.log(&#39;script start&#39;) 直接打印结果，输出 script start
遇到定时器了，它是宏任务，先放着不执行
遇到 async1()，执行 async1 函数，先打印 async1 start，下面遇到await怎么办？先执行 async2，打印 async2，然后阻塞下面代码（即加入微任务列表），跳出去执行同步代码
跳到 new Promise 这里，直接执行，打印 promise1，下面遇到 .then()，它是微任务，放到微任务列表等待执行
最后一行直接打印 script end，现在同步代码执行完了，开始执行微任务，即 await 下面的代码，打印 async1 end
继续执行下一个微任务，即执行 then 的回调，打印 promise2
上一个宏任务所有事都做完了，开始下一个宏任务，就是定时器，打印 settimeout

所以最后的结果是：script start、async1 start、async2、promise1、script end、async1 end、promise2、settimeout
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript中如何实现函数缓存？函数缓存有哪些应用场景？</title>
    <url>/2024/07/22/JavaScript-function-cache/</url>
    <content><![CDATA[ 
一、是什么函数缓存，就是将函数运算过的结果进行缓存
本质上就是用空间（缓存存储）换时间（计算过程）
常用于缓存数据计算结果和缓存对象
const add = (a,b) =&gt; a+b;const calc = memoize(add); // 函数缓存calc(10,20);// 30calc(10,20);// 30 缓存

缓存只是一个临时的数据存储，它保存数据，以便将来对该数据的请求能够更快地得到处理
二、如何实现实现函数缓存主要依靠闭包、柯里化、高阶函数，这里再简单复习下：
闭包闭包可以理解成，函数 + 函数体内可访问的变量总和
(function() &#123;    var a = 1;    function add() &#123;        const b = 2        let sum = b + a        console.log(sum); // 3    &#125;    add()&#125;)()

add 函数本身，以及其内部可访问的变量，即 a = 1 ，这两个组合在⼀起就形成了闭包
柯里化把接受多个参数的函数转换成接受一个单一参数的函数
// 非函数柯里化var add = function (x,y) &#123;    return x+y;&#125;add(3,4) //7// 函数柯里化var add2 = function (x) &#123;    //**返回函数**    return function (y) &#123;        return x+y;    &#125;&#125;add2(3)(4) //7

将一个二元函数拆分成两个一元函数
高阶函数通过接收其他函数作为参数或返回其他函数的函数
function foo()&#123;  var a = 2;  function bar() &#123;    console.log(a);  &#125;  return bar;&#125;var baz = foo();baz();//2

函数 foo 如何返回另一个函数 bar，baz 现在持有对 foo 中定义的bar 函数的引用。由于闭包特性，a的值能够得到
下面再看看如何实现函数缓存，实现原理也很简单，把参数和对应的结果数据存在一个对象中，调用时判断参数对应的数据是否存在，存在就返回对应的结果数据，否则就返回计算结果
如下所示
const memoize = function (func, content) &#123;  let cache = Object.create(null)  content = content || this  return (...key) =&gt; &#123;    if (!cache[key]) &#123;      cache[key] = func.apply(content, key)    &#125;    return cache[key]  &#125;&#125;

调用方式也很简单
const calc = memoize(add);const num1 = calc(100,200)const num2 = calc(100,200) // 缓存得到的结果

过程分析：

在当前函数作用域定义了一个空对象，用于缓存运行结果
运用柯里化返回一个函数，返回的函数由于闭包特性，可以访问到cache
然后判断输入参数是不是在cache的中。如果已经存在，直接返回cache的内容，如果没有存在，使用函数func对输入参数求值，然后把结果存储在cache中

三、应用场景虽然使用缓存效率是非常高的，但并不是所有场景都适用，因此千万不要极端的将所有函数都添加缓存
以下几种情况下，适合使用缓存：

对于昂贵的函数调用，执行复杂计算的函数
对于具有有限且高度重复输入范围的函数
对于具有重复输入值的递归函数
对于纯函数，即每次使用特定输入调用时返回相同输出的函数

参考文献
https://zhuanlan.zhihu.com/p/112505577

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript如何实现继承？</title>
    <url>/2024/08/12/JavaScript-inherit/</url>
    <content><![CDATA[
一、是什么继承（inheritance）是面向对象软件技术当中的一个概念。
如果一个类别B”继承自”另一个类别A，就把这个B称为”A的子类”，而把A称为”B的父类别”也可以称”A是B的超类”

继承的优点

继承可以使得子类具有父类别的各种属性和方法，而不需要再次编写相同的代码
在子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能
虽然JavaScript并不是真正的面向对象语言，但它天生的灵活性，使应用场景更加丰富
关于继承，我们举个形象的例子：
定义一个类（Class）叫汽车，汽车的属性包括颜色、轮胎、品牌、速度、排气量等
class Car&#123;    constructor(color,speed)&#123;        this.color = color        this.speed = speed        // ...    &#125;&#125;

由汽车这个类可以派生出”轿车”和”货车”两个类，在汽车的基础属性上，为轿车添加一个后备厢、给货车添加一个大货箱
// 货车class Truck extends Car&#123;    constructor(color,speed)&#123;        super(color,speed)        this.Container = true // 货箱    &#125;&#125;

这样轿车和货车就是不一样的，但是二者都属于汽车这个类，汽车、轿车继承了汽车的属性，而不需要再次在”轿车”中定义汽车已经有的属性
在”轿车”继承”汽车”的同时，也可以重新定义汽车的某些属性，并重写或覆盖某些属性和方法，使其获得与”汽车”这个父类不同的属性和方法
class Truck extends Car&#123;    constructor(color,speed)&#123;        super(color,speed)        this.color = &quot;black&quot; //覆盖        this.Container = true // 货箱    &#125;&#125;

从这个例子中就能详细说明汽车、轿车以及卡车之间的继承关系
二、实现方式下面给出JavaScripy常见的继承方式：

原型链继承

构造函数继承（借助 call）

组合继承

原型式继承

寄生式继承

寄生组合式继承


原型链继承原型链继承是比较常见的继承方式之一，其中涉及的构造函数、原型和实例，三者之间存在着一定的关系，即每一个构造函数都有一个原型对象，原型对象又包含一个指向构造函数的指针，而实例则包含一个原型对象的指针
举个例子
function Parent() &#123;   this.name = &#x27;parent1&#x27;;   this.play = [1, 2, 3] &#125; function Child() &#123;   this.type = &#x27;child2&#x27;; &#125; Child1.prototype = new Parent(); console.log(new Child())

上面代码看似没问题，实际存在潜在问题
var s1 = new Child2();var s2 = new Child2();s1.play.push(4);console.log(s1.play, s2.play); // [1,2,3,4]

改变s1的play属性，会发现s2也跟着发生变化了，这是因为两个实例使用的是同一个原型对象，内存空间是共享的
构造函数继承借助 call 调用Parent函数
function Parent()&#123;    this.name = &#x27;parent1&#x27;;&#125;Parent.prototype.getName = function () &#123;    return this.name;&#125;function Child()&#123;    Parent1.call(this);    this.type = &#x27;child&#x27;&#125;let child = new Child();console.log(child);  // 没问题console.log(child.getName());  // 会报错

可以看到，父类原型对象中一旦存在父类之前自己定义的方法，那么子类将无法继承这些方法
相比第一种原型链继承方式，父类的引用属性不会被共享，优化了第一种继承方式的弊端，但是只能继承父类的实例属性和方法，不能继承原型属性或者方法
组合继承前面我们讲到两种继承方式，各有优缺点。组合继承则将前两种方式继承起来
function Parent3 () &#123;    this.name = &#x27;parent3&#x27;;    this.play = [1, 2, 3];&#125;Parent3.prototype.getName = function () &#123;    return this.name;&#125;function Child3() &#123;    // 第二次调用 Parent3()    Parent3.call(this);    this.type = &#x27;child3&#x27;;&#125;// 第一次调用 Parent3()Child3.prototype = new Parent3();// 手动挂上构造器，指向自己的构造函数Child3.prototype.constructor = Child3;var s3 = new Child3();var s4 = new Child3();s3.play.push(4);console.log(s3.play, s4.play);  // 不互相影响console.log(s3.getName()); // 正常输出&#x27;parent3&#x27;console.log(s4.getName()); // 正常输出&#x27;parent3&#x27;

这种方式看起来就没什么问题，方式一和方式二的问题都解决了，但是从上面代码我们也可以看到 Parent3 执行了两次，造成了多构造一次的性能开销
原型式继承这里主要借助Object.create方法实现普通对象的继承
同样举个例子
let parent4 = &#123;    name: &quot;parent4&quot;,    friends: [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;],    getName: function() &#123;      return this.name;    &#125;  &#125;;  let person4 = Object.create(parent4);  person4.name = &quot;tom&quot;;  person4.friends.push(&quot;jerry&quot;);  let person5 = Object.create(parent4);  person5.friends.push(&quot;lucy&quot;);  console.log(person4.name); // tom  console.log(person4.name === person4.getName()); // true  console.log(person5.name); // parent4  console.log(person4.friends); // [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;,&quot;jerry&quot;,&quot;lucy&quot;]  console.log(person5.friends); // [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;,&quot;jerry&quot;,&quot;lucy&quot;]

这种继承方式的缺点也很明显，因为Object.create 方法实现的是浅拷贝，多个实例的引用类型属性指向相同的内存，存在篡改的可能
寄生式继承寄生式继承在上面继承基础上进行优化，利用这个浅拷贝的能力再进行增强，添加一些方法
let parent5 = &#123;    name: &quot;parent5&quot;,    friends: [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;],    getName: function() &#123;        return this.name;    &#125;&#125;;function clone(original) &#123;    let clone = Object.create(original);    clone.getFriends = function() &#123;        return this.friends;    &#125;;    return clone;&#125;let person5 = clone(parent5);console.log(person5.getName()); // parent5console.log(person5.getFriends()); // [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;]

其优缺点也很明显，跟上面讲的原型式继承一样
寄生组合式继承寄生组合式继承，借助解决普通对象的继承问题的 Object.create 方法，在前面几种继承方式的优缺点基础上进行改造，这也是所有继承方式里面相对最优的继承方式
function clone (parent, child) &#123;    // 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程    child.prototype = Object.create(parent.prototype);    child.prototype.constructor = child;&#125;function Parent6() &#123;    this.name = &#x27;parent6&#x27;;    this.play = [1, 2, 3];&#125;Parent6.prototype.getName = function () &#123;    return this.name;&#125;function Child6() &#123;    Parent6.call(this);    this.friends = &#x27;child5&#x27;;&#125;clone(Parent6, Child6);Child6.prototype.getFriends = function () &#123;    return this.friends;&#125;let person6 = new Child6();console.log(person6); //&#123;friends:&quot;child5&quot;,name:&quot;child5&quot;,play:[1,2,3],__proto__:Parent6&#125;console.log(person6.getName()); // parent6console.log(person6.getFriends()); // child5

可以看到 person6 打印出来的结果，属性都得到了继承，方法也没问题
文章一开头，我们是使用ES6 中的extends 关键字直接实现 JavaScript 的继承
class Person &#123;  constructor(name) &#123;    this.name = name  &#125;  // 原型方法  // 即 Person.prototype.getName = function() &#123; &#125;  // 下面可以简写为 getName() &#123;...&#125;  getName = function () &#123;    console.log(&#x27;Person:&#x27;, this.name)  &#125;&#125;class Gamer extends Person &#123;  constructor(name, age) &#123;    // 子类中存在构造函数，则需要在使用&quot;this&quot;之前首先调用 super()。    super(name)    this.age = age  &#125;&#125;const asuna = new Gamer(&#x27;Asuna&#x27;, 20)asuna.getName() // 成功访问到父类的方法

利用babel工具进行转换，我们会发现extends实际采用的也是寄生组合继承方式，因此也证明了这种方式是较优的解决继承的方式
三、总结下面以一张图作为总结：
 
通过Object.create 来划分不同的继承方式，最后的寄生式组合继承方式是通过组合继承改造之后的最优继承方式，而 extends 的语法糖和寄生组合继承的方式基本类似
相关链接https://zh.wikipedia.org/wiki/%E7%BB%A7%E6%89%BF
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>对函数式编程的理解？优缺点？</title>
    <url>/2024/08/10/JavaScript-functional-programming/</url>
    <content><![CDATA[ 
一、是什么函数式编程是一种”编程范式”（programming paradigm），一种编写程序的方法论
主要的编程范式有三种：命令式编程，声明式编程和函数式编程
相比命令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而非设计一个复杂的执行过程
举个例子，将数组每个元素进行平方操作，命令式编程与函数式编程如下
// 命令式编程var array = [0, 1, 2, 3]for(let i = 0; i &lt; array.length; i++) &#123;    array[i] = Math.pow(array[i], 2)&#125;// 函数式方式[0, 1, 2, 3].map(num =&gt; Math.pow(num, 2))

简单来讲，就是要把过程逻辑写成函数，定义好输入参数，只关心它的输出结果
即是一种描述集合和集合之间的转换关系，输入通过函数都会返回有且只有一个输出值
 
可以看到，函数实际上是一个关系，或者说是一种映射，而这种映射关系是可以组合的，一旦我们知道一个函数的输出类型可以匹配另一个函数的输入，那他们就可以进行组合
二、概念纯函数函数式编程旨在尽可能的提高代码的无状态性和不变性。要做到这一点，就要学会使用无副作用的函数，也就是纯函数
纯函数是对给定的输入返还相同输出的函数，并且要求你所有的数据都是不可变的，即纯函数&#x3D;无状态+数据不可变
 
举一个简单的例子
let double = value=&gt;value*2;

特性：

函数内部传入指定的值，就会返回确定唯一的值
不会造成超出作用域的变化，例如修改全局变量或引用传递的参数

优势：

使用纯函数，我们可以产生可测试的代码

test(&#x27;double(2) 等于 4&#x27;, () =&gt; &#123;  expect(double(2)).toBe(4);&#125;)


不依赖外部环境计算，不会产生副作用，提高函数的复用性

可读性更强 ，函数不管是否是纯函数  都会有一个语义化的名称，更便于阅读

可以组装成复杂任务的可能性。符合模块化概念及单一职责原则


高阶函数在我们的编程世界中，我们需要处理的其实也只有”数据”和”关系”，而关系就是函数
编程工作也就是在找一种映射关系，一旦关系找到了，问题就解决了，剩下的事情，就是让数据流过这种关系，然后转换成另一个数据，如下图所示
 
在这里，就是高阶函数的作用。高级函数，就是以函数作为输入或者输出的函数被称为高阶函数
通过高阶函数抽象过程，注重结果，如下面例子
const forEach = function(arr,fn)&#123;    for(let i=0;i&lt;arr.length;i++)&#123;        fn(arr[i]);    &#125;&#125;let arr = [1,2,3];forEach(arr,(item)=&gt;&#123;    console.log(item);&#125;)

上面通过高阶函数 forEach来抽象循环如何做的逻辑，直接关注做了什么
高阶函数存在缓存的特性，主要是利用闭包作用
const once = (fn)=&gt;&#123;    let done = false;    return function()&#123;        if(!done)&#123;            fn.apply(this,fn);        &#125;else&#123;            console.log(&quot;该函数已经执行&quot;);        &#125;        done = true;    &#125;&#125;

柯里化柯里化是把一个多参数函数转化成一个嵌套的一元函数的过程
一个二元函数如下：
let fn = (x,y)=&gt;x+y;

转化成柯里化函数如下：
const curry = function(fn)&#123;    return function(x)&#123;        return function(y)&#123;            return fn(x,y);        &#125;    &#125;&#125;let myfn = curry(fn);console.log( myfn(1)(2) );

上面的curry函数只能处理二元情况，下面再来实现一个实现多参数的情况
// 多参数柯里化；const curry = function(fn)&#123;    return function curriedFn(...args)&#123;        if(args.length&lt;fn.length)&#123;            return function()&#123;                return curriedFn(...args.concat([...arguments]));            &#125;        &#125;        return fn(...args);    &#125;&#125;const fn = (x,y,z,a)=&gt;x+y+z+a;const myfn = curry(fn);console.log(myfn(1)(2)(3)(1));

关于柯里化函数的意义如下：

让纯函数更纯，每次接受一个参数，松散解耦
惰性执行

组合与管道组合函数，目的是将多个函数组合成一个函数
举个简单的例子：
function afn(a)&#123;    return a*2;&#125;function bfn(b)&#123;    return b*3;&#125;const compose = (a,b)=&gt;c=&gt;a(b(c));let myfn =  compose(afn,bfn);console.log( myfn(2));

可以看到compose实现一个简单的功能：形成了一个新的函数，而这个函数就是一条从 bfn -&gt; afn 的流水线
下面再来看看如何实现一个多函数组合：
const compose = (...fns)=&gt;val=&gt;fns.reverse().reduce((acc,fn)=&gt;fn(acc),val);

compose执行是从右到左的。而管道函数，执行顺序是从左到右执行的
const pipe = (...fns)=&gt;val=&gt;fns.reduce((acc,fn)=&gt;fn(acc),val);

组合函数与管道函数的意义在于：可以把很多小函数组合起来完成更复杂的逻辑
三、优缺点优点
更好的管理状态：因为它的宗旨是无状态，或者说更少的状态，能最大化的减少这些未知、优化代码、减少出错情况

更简单的复用：固定输入-&gt;固定输出，没有其他外部变量影响，并且无副作用。这样代码复用时，完全不需要考虑它的内部实现和外部影响

更优雅的组合：往大的说，网页是由各个组件组成的。往小的说，一个函数也可能是由多个小函数组成的。更强的复用性，带来更强大的组合性

隐性好处。减少代码量，提高维护性


缺点：
性能：函数式编程相对于指令式编程，性能绝对是一个短板，因为它往往会对一个方法进行过度包装，从而产生上下文切换的性能开销

资源占用：在 JS 中为了实现对象状态的不可变，往往会创建新的对象，因此，它对垃圾回收所产生的压力远远超过其他编程方式

递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作


参考文献
https://zhuanlan.zhihu.com/p/81302150

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 引擎的理解</title>
    <url>/2024/08/20/JavaScript-js-engine/</url>
    <content><![CDATA[一、什么是 JavaScript 引擎JavaScript 引擎是一个专门处理 JavaScript 代码的程序。它负责解析和执行 JavaScript 代码，将我们编写的 JavaScript 代码转换为机器能够理解和执行的机器码。
目前主流的 JavaScript 引擎有：

V8（Google）：用于 Chrome 浏览器和 Node.js
SpiderMonkey（Mozilla）：用于 Firefox 浏览器
JavaScriptCore（Apple）：用于 Safari 浏览器
Chakra（Microsoft）：用于 IE 和 Edge 浏览器（旧版）

二、主要组成部分1. Memory Heap（内存堆）
用于存储对象、数组等引用类型数据
进行动态内存分配
包含垃圾回收机制（分代回收、标记清除、引用计数等）
处理内存碎片化问题

2. Call Stack（调用栈）
记录代码执行的上下文
基于 LIFO（后进先出）原则
包含以下信息：
局部变量
参数
返回地址
临时变量



3. Parser（解析器）解析过程分为两个阶段：

词法分析（Tokenization）
// 源代码：let name = &quot;John&quot;;// 被解析为 tokens：[  &#123; type: &quot;keyword&quot;, value: &quot;let&quot; &#125;,  &#123; type: &quot;identifier&quot;, value: &quot;name&quot; &#125;,  &#123; type: &quot;operator&quot;, value: &quot;=&quot; &#125;,  &#123; type: &quot;string&quot;, value: &quot;John&quot; &#125;,  &#123; type: &quot;punctuator&quot;, value: &quot;;&quot; &#125;]

语法分析（生成 AST）
// AST 结构示例&#123;  type: &quot;Program&quot;,  body: [&#123;    type: &quot;VariableDeclaration&quot;,    declarations: [&#123;      type: &quot;VariableDeclarator&quot;,      id: &#123;        type: &quot;Identifier&quot;,        name: &quot;name&quot;      &#125;,      init: &#123;        type: &quot;Literal&quot;,        value: &quot;John&quot;      &#125;    &#125;]  &#125;]&#125;

4. Interpreter（解释器）
直接执行字节码
维护执行上下文
处理作用域链
实现变量提升
管理闭包

5. Compiler（编译器）包含多个优化阶段：

JIT（即时编译）
// 热点函数会被编译优化function hotFunction(n) &#123;  // 被多次调用的函数  return n * 2;&#125;for(let i = 0; i &lt; 100000; i++) &#123;  hotFunction(i); // 这个函数会被 JIT 编译&#125;

内联缓存（Inline Caching）
// 优化前function getName(obj) &#123;  return obj.name;&#125;// V8 优化后的伪代码function getName(obj) &#123;  // 检查对象结构是否匹配缓存  if (obj.map === cachedMap) &#123;    // 直接返回固定偏移量的属性    return *（obj + nameOffset）;  &#125;  // 回退到常规属性访问  return obj.name;&#125;

三、工作流程1. 加载阶段
源码加载
词法分析
语法分析
生成 AST
生成字节码

2. 执行阶段
创建执行上下文
ExecutionContext = &#123;  ThisBinding: &lt;this value&gt;,  LexicalEnvironment: &#123;    EnvironmentRecord: &#123;      Type: &quot;Declarative&quot;,      // 标识符绑定    &#125;,    outer: &lt;outer lexical environment reference&gt;  &#125;,  VariableEnvironment: &#123;    EnvironmentRecord: &#123;      Type: &quot;Declarative&quot;,      // 变量和函数声明    &#125;,    outer: &lt;outer lexical environment reference&gt;  &#125;&#125;

作用域链建立
function outer() &#123;  const a = 1;  function inner() &#123;    const b = 2;    console.log(a, b);  &#125;  return inner;&#125;// 作用域链：inner -&gt; outer -&gt; global

变量对象创建

代码执行


3. 优化阶段
死代码消除
// 优化前function unused() &#123;  const a = 1;  const b = 2;  return a; // b 永远不会被使用&#125;// 优化后function unused() &#123;  const a = 1;  return a;&#125;

内联展开
// 优化前function add(a, b) &#123;  return a + b;&#125;let result = add(1, 2);// 优化后let result = 1 + 2;

四、性能优化1. 代码层面// 1. 对象属性访问优化const obj = &#123;  name: &#x27;John&#x27;,  age: 30&#125;;// 不推荐function badAccess() &#123;  for(let i = 0; i &lt; 1000; i++) &#123;    console.log(obj.name); // 每次都要查找属性  &#125;&#125;// 推荐function goodAccess() &#123;  const &#123; name &#125; = obj; // 解构一次  for(let i = 0; i &lt; 1000; i++) &#123;    console.log(name);  &#125;&#125;// 2. 函数优化// 不推荐const addBad = new Function(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;return a + b&#x27;);// 推荐const addGood = (a, b) =&gt; a + b;// 3. 数组优化// 不推荐const arrBad = new Array(1000);for(let i = 0; i &lt; arrBad.length; i++) &#123;  arrBad[i] = i;&#125;// 推荐const arrGood = Array.from(&#123; length: 1000 &#125;, (_, i) =&gt; i);

2. 内存管理// 1. WeakMap 使用const cache = new WeakMap();function memorize(fn) &#123;  return function(obj) &#123;    if (!cache.has(obj)) &#123;      cache.set(obj, fn(obj));    &#125;    return cache.get(obj);  &#125;&#125;// 2. 避免内存泄漏class EventEmitter &#123;  constructor() &#123;    this.listeners = new Map();  &#125;    addListener(event, callback) &#123;    if (!this.listeners.has(event)) &#123;      this.listeners.set(event, new Set());    &#125;    this.listeners.get(event).add(callback);  &#125;    removeListener(event, callback) &#123;    if (this.listeners.has(event)) &#123;      this.listeners.get(event).delete(callback);    &#125;  &#125;&#125;

五、注意事项1. 内存泄漏// 1. 闭包导致的内存泄漏function createLeak() &#123;  const largeData = new Array(1000000);  return function() &#123;    console.log(largeData.length);  &#125;&#125;// 2. 定时器未清除function setTimer() &#123;  const data = &#123; /* 大量数据 */ &#125;;  const timer = setInterval(() =&gt; &#123;    console.log(data);  &#125;, 1000);    // 记得清除  return () =&gt; clearInterval(timer);&#125;

2. 执行效率// 1. 避免动态属性访问const key = &#x27;dynamicKey&#x27;;obj[key] = value; // 会禁用某些优化// 2. 使用位运算// 不推荐Math.floor(num / 2);// 推荐num &gt;&gt; 1;// 3. 避免混合类型let number = 42;number = &#x27;string&#x27;; // 会导致类型转换，降低性能

六、高级优化技巧1. Hidden Class// 不推荐function Point(x, y) &#123;  this.x = x;  this.y = y;  if (x &gt; 0) &#123;    this.positive = true; // 动态添加属性  &#125;&#125;// 推荐function Point(x, y) &#123;  this.x = x;  this.y = y;  this.positive = x &gt; 0; // 固定属性结构&#125;

2. 函数优化// 1. 单态函数function add(a, b) &#123;  // 只处理数字类型  if (typeof a === &#x27;number&#x27; &amp;&amp; typeof b === &#x27;number&#x27;) &#123;    return a + b;  &#125;  throw new Error(&#x27;Invalid arguments&#x27;);&#125;// 2. 内联优化const multiply = (a, b) =&gt; a * b; // 简单函数更容易被内联

参考文献
V8 官方文档
JavaScript 引擎基础：原理与优化
深入理解 V8 引擎
V8 性能优化
JavaScript 内存管理

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>了解的js数据结构？</title>
    <url>/2024/08/16/JavaScript-js-data-structure/</url>
    <content><![CDATA[什么是数据结构？数据结构是计算机存储、组织数据的方式。数据结构意味着接口或封装：一个数据结构可被视为两个函数之间的接口，或者是由数据类型联合组成的存储内容的访问方法封装。
我们每天的编码中都会用到数据结构数组是最简单的内存数据结构下面是常见的数据结构：

数组（Array）
栈（Stack）
队列（Queue）
链表（Linked List）
字典
散列表（Hash table）
树（Tree）
图（Graph）
堆（Heap）

数组（Array）数组是最最基本的数据结构，很多语言都内置支持数组。数组是使用一块连续的内存空间保存数据，保存的数据的个数在分配内存的时候就是确定的。
在日常生活中，人们经常使用列表：待办事项列表、购物清单等。
而计算机程序也在使用列表，在下面的条件下，选择列表作为数据结构就显得尤为有用：数据结构较为简单不需要在一个长序列中查找元素，或者对其进行排序反之，如果数据结构非常复杂，列表的作用就没有那么大了。
栈（Stack）栈是一种遵循后进先出（LIFO）原则的有序集合在栈里，新元素都接近栈顶，旧元素都接近栈底。每次加入新的元素和拿走元素都在顶部操作
队列（Queue）队列是遵循先进先出（FIFO，也称为先来先服务）原则的一组有序的项队列在尾部添加新元素，并从顶部移除元素最新添加的元素必须排在队列的末尾
链表（Linked List）链表也是一种列表，已经设计了数组，为什么还需要链表呢？JavaScript中数组的主要问题时，它们被实现成了对象，与其他语言（比如C++和Java）的数组相对，效率很低。如果你发现数组在实际使用时很慢，就可以考虑使用链表来代替它。
使用条件：链表几乎可以用在任何可以使用一维数组的情况中。如果需要随机访问，数组仍然是更好的选择。
字典字典是一种以键-值对存储数据的数据结构，js中的Object类就是以字典的形式设计的。JavaScript可以通过实现字典类，让这种字典类型的对象使用起来更加简单，字典可以实现对象拥有的常见功能，并相应拓展自己想要的功能，而对象在JavaScript编写中随处可见，所以字典的作用也异常明显了。
散列表也称为哈希表，特点是在散列表上插入、删除和取用数据都非常快。为什么要设计这种数据结构呢？用数组或链表存储数据，如果想要找到其中一个数据，需要从头进行遍历，因为不知道这个数据存储到了数组的哪个位置。
散列表在JavaScript中可以基础数组去进行设计。数组的长度是预先设定的，所有元素根据和该元素对应的键，保存在数组的特定位置，这里的键和对象的键是类型的概念。使用散列表存储数组时，通过一个散列函数将键映射为一个数字，这个数字的范围是0到散列表的长度。
即使使用一个高效的散列函数，依然存在将两个键映射为同一个值得可能，这种现象叫做碰撞。常见碰撞的处理方法有：开链法和线性探测法（具体概念有兴趣的可以网上自信了解）使用条件：可以用于数据的插入、删除和取用，不适用于查找数据
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>说说 Javascript 数字精度丢失的问题，如何解决？</title>
    <url>/2023/08/10/JavaScript-loss-accuracy/</url>
    <content><![CDATA[ 
一、场景复现一个经典的面试题
0.1 + 0.2 === 0.3 // false
为什么是false呢?
先看下面这个比喻
比如一个数 1÷3&#x3D;0.33333333…… 
3会一直无限循环，数学可以表示，但是计算机要存储，方便下次取出来再使用，但0.333333…… 这个数无限循环，再大的内存它也存不下，所以不能存储一个相对于数学来说的值，只能存储一个近似值，当计算机存储后再取出时就会出现精度丢失问题
二、浮点数“浮点数”是一种表示数字的标准，整数也可以用浮点数的格式来存储
我们也可以理解成，浮点数就是小数
在JavaScript中，现在主流的数值类型是Number，而Number采用的是IEEE754规范中64位双精度浮点数编码
这样的存储结构优点是可以归一化处理整数和小数，节省存储空间
对于一个整数，可以很轻易转化成十进制或者二进制。但是对于一个浮点数来说，因为小数点的存在，小数点的位置不是固定的。解决思路就是使用科学计数法，这样小数点位置就固定了
而计算机只能用二进制（0或1）表示，二进制转换为科学记数法的公式如下：
 
其中，a的值为0或者1，e为小数点移动的位置
举个例子：
27.0转化成二进制为11011.0 ，科学计数法表示为：
 
前面讲到，javaScript存储方式是双精度浮点数，其长度为8个字节，即64位比特
64位比特又可分为三个部分：

符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数
指数位E：中间的 11 位存储指数（exponent），用来表示次方数，可以为正负数。在双精度浮点数中，指数的固定偏移量为1023
尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零

如下图所示：
 
举个例子：
27.5 转换为二进制11011.1
11011.1转换为科学记数法 
符号位为1(正数)，指数位为4+，1023+4，即1027
因为它是十进制的需要转换为二进制，即 10000000011，小数部分为10111，补够52位即： 1011 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000&#96;
所以27.5存储为计算机的二进制标准形式（符号位+指数位+小数部分 (阶数)），既下面所示
0+10000000011+011 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000&#96;
二、问题分析再回到问题上
0.1 + 0.2 === 0.3 // false

通过上面的学习，我们知道，在javascript语言中，0.1 和 0.2 都转化成二进制后再进行运算
// 0.1 和 0.2 都转化成二进制后再进行运算0.00011001100110011001100110011001100110011001100110011010 +0.0011001100110011001100110011001100110011001100110011010 =0.0100110011001100110011001100110011001100110011001100111// 转成十进制正好是 0.30000000000000004

所以输出false
再来一个问题，那么为什么x=0.1得到0.1？
主要是存储二进制时小数点的偏移量最大为52位，最多可以表达的位数是2^53=9007199254740992，对应科学计数尾数是 9.007199254740992，这也是 JS 最多能表示的精度
它的长度是 16，所以可以使用 toPrecision(16) 来做精度运算，超过的精度会自动做凑整处理
.10000000000000000555.toPrecision(16)// 返回 0.1000000000000000，去掉末尾的零后正好为 0.1

但看到的 0.1 实际上并不是 0.1。不信你可用更高的精度试试：
0.1.toPrecision(21) = 0.100000000000000005551

如果整数大于 9007199254740992 会出现什么情况呢？
由于指数位最大值是1023，所以最大可以表示的整数是 2^1024 - 1，这就是能表示的最大整数。但你并不能这样计算这个数字，因为从 2^1024 开始就变成了 Infinity
&gt; Math.pow(2, 1023)8.98846567431158e+307&gt; Math.pow(2, 1024)Infinity

那么对于 (2^53, 2^63) 之间的数会出现什么情况呢？

(2^53, 2^54) 之间的数会两个选一个，只能精确表示偶数
(2^54, 2^55) 之间的数会四个选一个，只能精确表示4个倍数
… 依次跳过更多2的倍数

要想解决大数的问题你可以引用第三方库 bignumber.js，原理是把所有数字当作字符串，重新实现了计算逻辑，缺点是性能比原生差很多
小结计算机存储双精度浮点数需要先把十进制数转换为二进制的科学记数法的形式，然后计算机以自己的规则{符号位+(指数位+指数偏移量的二进制)+小数部分}存储二进制的科学记数法
因为存储时有位数限制（64位），并且某些十进制的浮点数在转换为二进制数时会出现无限循环，会造成二进制的舍入操作(0舍1入)，当再转换为十进制时就造成了计算误差
三、解决方案理论上用有限的空间来存储无限的小数是不可能保证精确的，但我们可以处理一下得到我们期望的结果
当你拿到 1.4000000000000001 这样的数据要展示时，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示，如下：
parseFloat(1.4000000000000001.toPrecision(12)) === 1.4  // True

封装成方法就是：
function strip(num, precision = 12) &#123;  return +parseFloat(num.toPrecision(precision));&#125;

对于运算类操作，如 +-*/，就不能使用 toPrecision 了。正确的做法是把小数转成整数后再运算。以加法为例：
/** * 精确加法 */function add(num1, num2) &#123;  const num1Digits = (num1.toString().split(&#x27;.&#x27;)[1] || &#x27;&#x27;).length;  const num2Digits = (num2.toString().split(&#x27;.&#x27;)[1] || &#x27;&#x27;).length;  const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));  return (num1 * baseNum + num2 * baseNum) / baseNum;&#125;

最后还可以使用第三方库，如Math.js、BigDecimal.js
参考文献
https://zhuanlan.zhihu.com/p/100353781
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>说说new操作符具体干了什么？</title>
    <url>/2023/02/12/JavaScript-new/</url>
    <content><![CDATA[
一、是什么在JavaScript中，new操作符用于创建一个给定构造函数的实例对象
例子
function Person(name, age)&#123;    this.name = name;    this.age = age;&#125;Person.prototype.sayName = function () &#123;    console.log(this.name)&#125;const person1 = new Person(&#x27;Tom&#x27;, 20)console.log(person1)  // Person &#123;name: &quot;Tom&quot;, age: 20&#125;t.sayName() // &#x27;Tom&#x27;

从上面可以看到：

new 通过构造函数 Person 创建出来的实例可以访问到构造函数中的属性
new 通过构造函数 Person 创建出来的实例可以访问到构造函数原型链中的属性（即实例与构造函数通过原型链连接了起来）

现在在构建函数中显式加上返回值，并且这个返回值是一个原始类型
function Test(name) &#123;  this.name = name  return 1&#125;const t = new Test(&#x27;xxx&#x27;)console.log(t.name) // &#x27;xxx&#x27;

可以发现，构造函数中返回一个原始值，然而这个返回值并没有作用
下面在构造函数中返回一个对象
function Test(name) &#123;  this.name = name  console.log(this) // Test &#123; name: &#x27;xxx&#x27; &#125;  return &#123; age: 26 &#125;&#125;const t = new Test(&#x27;xxx&#x27;)console.log(t) // &#123; age: 26 &#125;console.log(t.name) // &#x27;undefined&#x27;

从上面可以发现，构造函数如果返回值为一个对象，那么这个返回值会被正常使用
二、流程从上面介绍中，我们可以看到new关键字主要做了以下的工作：

创建一个新的对象obj

将对象与构建函数通过原型链连接起来

将构建函数中的this绑定到新建的对象obj上

根据构建函数返回类型作判断，如果是原始值则被忽略，如果是返回对象，需要正常处理


举个例子：
function Person(name, age)&#123;    this.name = name;    this.age = age;&#125;const person1 = new Person(&#x27;Tom&#x27;, 20)console.log(person1)  // Person &#123;name: &quot;Tom&quot;, age: 20&#125;t.sayName() // &#x27;Tom&#x27;

流程图如下：
 
三、手写new操作符现在我们已经清楚地掌握了new的执行过程
那么我们就动手来实现一下new
function mynew(Func, ...args) &#123;    // 1.创建一个新对象    const obj = &#123;&#125;    // 2.新对象原型指向构造函数原型对象    obj.__proto__ = Func.prototype    // 3.将构建函数的this指向新对象    let result = Func.apply(obj, args)    // 4.根据返回值判断    return result instanceof Object ? result : obj&#125;

测试一下
function mynew(func, ...args) &#123;    const obj = &#123;&#125;    obj.__proto__ = func.prototype    let result = func.apply(obj, args)    return result instanceof Object ? result : obj&#125;function Person(name, age) &#123;    this.name = name;    this.age = age;&#125;Person.prototype.say = function () &#123;    console.log(this.name)&#125;let p = mynew(Person, &quot;huihui&quot;, 123)console.log(p) // Person &#123;name: &quot;huihui&quot;, age: 123&#125;p.say() // huihui

可以发现，代码虽然很短，但是能够模拟实现new
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>说说 JavaScript 中内存泄漏的几种情况？</title>
    <url>/2023/06/10/JavaScript-memory-leak/</url>
    <content><![CDATA[  
一、是什么内存泄漏（Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存
并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费
程序的运行需要内存。只要程序提出要求，操作系统或者运行时就必须供给内存
对于持续运行的服务进程，必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃
 
在C语言中，因为是手动管理内存，内存泄露是经常出现的事情。
char * buffer;buffer = (char*) malloc(42);// Do something with bufferfree(buffer);

上面是 C 语言代码，malloc方法用来申请内存，使用完毕之后，必须自己用free方法释放内存。
这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为”垃圾回收机制”
二、垃圾回收机制Javascript 具有自动垃圾回收机制（GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存
原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存
通常情况下有两种实现方式：

标记清除
引用计数

标记清除JavaScript最常用的垃圾收回机制
当变量进入执行环境是，就标记这个变量为”进入环境”。进入环境的变量所占用的内存就不能释放，当变量离开环境时，则将其标记为”离开环境”
垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉
在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了
随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存
举个例子：
var m = 0,n = 19 // 把 m,n,add() 标记为进入环境。add(m, n) // 把 a, b, c标记为进入环境。console.log(n) // a,b,c标记为离开环境，等待垃圾回收。function add(a, b) &#123;  a++  var c = a + b  return c&#125;



引用计数语言引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放
如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，从而导致内存泄漏
const arr = [1, 2, 3, 4];console.log(&#x27;hello world&#x27;);

上面代码中，数组[1, 2, 3, 4]是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它还是会持续占用内存
如果需要这块内存被垃圾回收机制释放，只需要设置如下：
arr = null

通过设置arr为null，就解除了对数组[1,2,3,4]的引用，引用次数变为 0，就被垃圾回收了
小结有了垃圾回收机制，不代表不用关注内存泄露。那些很占空间的值，一旦不再用到，需要检查是否还存在对它们的引用。如果是的话，就必须手动解除引用
三、常见内存泄露情况意外的全局变量
function foo(arg) &#123;    bar = &quot;this is a hidden global variable&quot;;&#125;

另一种意外的全局变量可能由 this 创建：
function foo() &#123;    this.variable = &quot;potential accidental global&quot;;&#125;// foo 调用自己，this 指向了全局对象（window）foo();

上述使用严格模式，可以避免意外的全局变量
定时器也常会造成内存泄露
var someResource = getData();setInterval(function() &#123;    var node = document.getElementById(&#x27;Node&#x27;);    if(node) &#123;        // 处理 node 和 someResource        node.innerHTML = JSON.stringify(someResource));    &#125;&#125;, 1000);

如果id为Node的元素从DOM中移除，该定时器仍会存在，同时，因为回调函数中包含对someResource的引用，定时器外面的someResource也不会被释放
包括我们之前所说的闭包，维持函数内局部变量，使其得不到释放
function bindEvent() &#123;  var obj = document.createElement(&#x27;XXX&#x27;);  var unused = function () &#123;    console.log(obj, &#x27;闭包内引用obj obj不会被释放&#x27;);  &#125;;  obj = null; // 解决方法&#125;

没有清理对DOM元素的引用同样造成内存泄露
const refA = document.getElementById(&#x27;refA&#x27;);document.body.removeChild(refA); // dom删除了console.log(refA, &#x27;refA&#x27;); // 但是还存在引用能console出整个div 没有被回收refA = null;console.log(refA, &#x27;refA&#x27;); // 解除引用

包括使用事件监听addEventListener监听的时候，在不监听的情况下使用removeEventListener取消对事件监听
参考文献
http://www.ruanyifeng.com/blog/2017/04/memory-leak.html
https://zh.wikipedia.org/wiki

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript原型，原型链？有什么特点？</title>
    <url>/2023/04/09/JavaScript-prototype/</url>
    <content><![CDATA[ 
一、原型JavaScript 常被描述为一种基于原型的语言——每个对象拥有一个原型对象
当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾
准确地说，这些属性和方法定义在Object的构造器函数（constructor functions）之上的prototype属性上，而非实例对象本身
下面举个例子：
函数可以有属性。 每个函数都有一个特殊的属性叫作原型prototype 
function doSomething()&#123;&#125;console.log( doSomething.prototype );

控制台输出
&#123;    constructor: ƒ doSomething(),    __proto__: &#123;        constructor: ƒ Object(),        hasOwnProperty: ƒ hasOwnProperty(),        isPrototypeOf: ƒ isPrototypeOf(),        propertyIsEnumerable: ƒ propertyIsEnumerable(),        toLocaleString: ƒ toLocaleString(),        toString: ƒ toString(),        valueOf: ƒ valueOf()    &#125;&#125;

上面这个对象，就是大家常说的原型对象
可以看到，原型对象有一个自有属性constructor，这个属性指向该函数，如下图关系展示
 
二、原型链原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法
在对象实例和它的构造器之间建立一个链接（它是__proto__属性，是从构造函数的prototype属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法
下面举个例子：
function Person(name) &#123;    this.name = name;    this.age = 18;    this.sayName = function() &#123;        console.log(this.name);    &#125;&#125;// 第二步 创建实例var person = new Person(&#x27;person&#x27;)

根据代码，我们可以得到下图
 
下面分析一下：

构造函数Person存在原型对象Person.prototype

构造函数生成实例对象person，person的__proto__指向构造函数Person原型对象

Person.prototype.__proto__ 指向内置对象，因为 Person.prototype 是个对象，默认是由 Object 函数作为类创建的，而 Object.prototype 为内置对象

Person.__proto__ 指向内置匿名函数 anonymous，因为 Person 是个函数对象，默认由 Function 作为类创建

Function.prototype 和 Function.__proto__ 同时指向内置匿名函数 anonymous，这样原型链的终点就是 null


三、总结下面首先要看几个概念：
__proto__作为不同对象之间的桥梁，用来指向创建它的构造函数的原型对象的
 
每个对象的__proto__都是指向它的构造函数的原型对象prototype的
person1.__proto__ === Person.prototype

构造函数是一个函数对象，是通过 Function 构造器产生的
Person.__proto__ === Function.prototype

原型对象本身是一个普通对象，而普通对象的构造函数都是Object
Person.prototype.__proto__ === Object.prototype

刚刚上面说了，所有的构造器都是函数对象，函数对象都是 Function 构造产生的
Object.__proto__ === Function.prototype

Object 的原型对象也有__proto__属性指向null，null是原型链的顶端
Object.prototype.__proto__ === null

下面作出总结：

一切对象都是继承自Object对象，Object 对象直接继承根源对象 null

一切的函数对象（包括 Object 对象），都是继承自 Function 对象

Object 对象直接继承自 Function 对象

Function对象的__proto__会指向自己的原型对象，最终还是继承自Object对象


参考文献
https://juejin.cn/post/6870732239556640775#heading-7
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>如何实现上拉加载，下拉刷新？</title>
    <url>/2023/06/19/JavaScript-pull-up-loading-pull-down-refresh/</url>
    <content><![CDATA[ 
一、前言下拉刷新和上拉加载这两种交互方式通常出现在移动端中
本质上等同于PC网页中的分页，只是交互形式不同
开源社区也有很多优秀的解决方案，如iscroll、better-scroll、pulltorefresh.js库等等
这些第三方库使用起来非常便捷
我们通过原生的方式实现一次上拉加载，下拉刷新，有助于对第三方库有更好的理解与使用
二、实现原理上拉加载及下拉刷新都依赖于用户交互
最重要的是要理解在什么场景，什么时机下触发交互动作
上拉加载首先可以看一张图
 
上拉加载的本质是页面触底，或者快要触底时的动作
判断页面触底我们需要先了解一下下面几个属性

scrollTop：滚动视窗的高度距离window顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值

clientHeight:它是一个定值，表示屏幕可视区域的高度；

scrollHeight：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示body所有元素的总长度(包括body元素自身的padding)


综上我们得出一个触底公式：
scrollTop + clientHeight &gt;= scrollHeight

简单实现
let clientHeight  = document.documentElement.clientHeight; //浏览器高度let scrollHeight = document.body.scrollHeight;let scrollTop = document.documentElement.scrollTop; let distance = 50;  //距离视窗还用50的时候，开始触发；if ((scrollTop + clientHeight) &gt;= (scrollHeight - distance)) &#123;    console.log(&quot;开始加载数据&quot;);&#125;


下拉刷新下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作
关于下拉刷新的原生实现，主要分成三步：

监听原生touchstart事件，记录其初始位置的值，e.touches[0].pageY；
监听原生touchmove事件，记录并计算当前滑动的位置值与初始位置值的差值，大于0表示向下拉动，并借助CSS3的translateY属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；
监听原生touchend事件，若此时元素滑动达到最大值，则触发callback，同时将translateY重设为0，元素回到初始位置

举个例子：
Html结构如下：
&lt;main&gt;    &lt;p class=&quot;refreshText&quot;&gt;&lt;/p &gt;    &lt;ul id=&quot;refreshContainer&quot;&gt;        &lt;li&gt;111&lt;/li&gt;        &lt;li&gt;222&lt;/li&gt;        &lt;li&gt;333&lt;/li&gt;        &lt;li&gt;444&lt;/li&gt;        &lt;li&gt;555&lt;/li&gt;        ...    &lt;/ul&gt;&lt;/main&gt;

监听touchstart事件，记录初始的值
var _element = document.getElementById(&#x27;refreshContainer&#x27;),    _refreshText = document.querySelector(&#x27;.refreshText&#x27;),    _startPos = 0,  // 初始的值    _transitionHeight = 0; // 移动的距离_element.addEventListener(&#x27;touchstart&#x27;, function(e) &#123;    _startPos = e.touches[0].pageY; // 记录初始位置    _element.style.position = &#x27;relative&#x27;;    _element.style.transition = &#x27;transform 0s&#x27;;&#125;, false);

监听touchmove移动事件，记录滑动差值
_element.addEventListener(&#x27;touchmove&#x27;, function(e) &#123;    // e.touches[0].pageY 当前位置    _transitionHeight = e.touches[0].pageY - _startPos; // 记录差值    if (_transitionHeight &gt; 0 &amp;&amp; _transitionHeight &lt; 60) &#123;         _refreshText.innerText = &#x27;下拉刷新&#x27;;         _element.style.transform = &#x27;translateY(&#x27;+_transitionHeight+&#x27;px)&#x27;;        if (_transitionHeight &gt; 55) &#123;            _refreshText.innerText = &#x27;释放更新&#x27;;        &#125;    &#125;                &#125;, false);

最后，就是监听touchend离开的事件
_element.addEventListener(&#x27;touchend&#x27;, function(e) &#123;    _element.style.transition = &#x27;transform 0.5s ease 1s&#x27;;    _element.style.transform = &#x27;translateY(0px)&#x27;;    _refreshText.innerText = &#x27;更新中...&#x27;;    // todo...&#125;, false);

从上面可以看到，在下拉到松手的过程中，经历了三个阶段：

当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作
下拉到一定值时，显示松手释放后的操作提示
下拉到达设定最大值松手时，执行回调，提示正在进行更新操作

三、案例在实际开发中，我们更多的是使用第三方库，下面以better-scroll进行举例：
HTML结构
&lt;div id=&quot;position-wrapper&quot;&gt;    &lt;div&gt;        &lt;p class=&quot;refresh&quot;&gt;下拉刷新&lt;/p &gt;        &lt;div class=&quot;position-list&quot;&gt;   &lt;!--列表内容--&gt;        &lt;/div&gt;        &lt;p class=&quot;more&quot;&gt;查看更多&lt;/p &gt;    &lt;/div&gt;&lt;/div&gt;

实例化上拉下拉插件，通过use来注册插件
import BScroll from &quot;@better-scroll/core&quot;;import PullDown from &quot;@better-scroll/pull-down&quot;;import PullUp from &#x27;@better-scroll/pull-up&#x27;;BScroll.use(PullDown);BScroll.use(PullUp);

实例化BetterScroll，并传入相关的参数
let pageNo = 1,pageSize = 10,dataList = [],isMore = true;  var scroll= new BScroll(&quot;#position-wrapper&quot;,&#123;    scrollY:true,//垂直方向滚动    click:true,//默认会阻止浏览器的原生click事件，如果需要点击，这里要设为true    pullUpLoad:true,//上拉加载更多    pullDownRefresh:&#123;        threshold:50,//触发pullingDown事件的位置        stop:0//下拉回弹后停留的位置    &#125;&#125;);//监听下拉刷新scroll.on(&quot;pullingDown&quot;,pullingDownHandler);//监测实时滚动scroll.on(&quot;scroll&quot;,scrollHandler);//上拉加载更多scroll.on(&quot;pullingUp&quot;,pullingUpHandler);async function pullingDownHandler()&#123;    dataList=[];    pageNo=1;    isMore=true;    $(&quot;.more&quot;).text(&quot;查看更多&quot;);    await getlist();//请求数据    scroll.finishPullDown();//每次下拉结束后，需要执行这个操作    scroll.refresh();//当滚动区域的dom结构有变化时，需要执行这个操作&#125;async function pullingUpHandler()&#123;    if(!isMore)&#123;        $(&quot;.more&quot;).text(&quot;没有更多数据了&quot;);        scroll.finishPullUp();//每次上拉结束后，需要执行这个操作        return;    &#125;    pageNo++;    await this.getlist();//请求数据    scroll.finishPullUp();//每次上拉结束后，需要执行这个操作    scroll.refresh();//当滚动区域的dom结构有变化时，需要执行这个操作    &#125;function scrollHandler()&#123;    if(this.y&gt;50) $(&#x27;.refresh&#x27;).text(&quot;松手开始加载&quot;);    else $(&#x27;.refresh&#x27;).text(&quot;下拉刷新&quot;);&#125;function getlist()&#123;    //返回的数据    let result=....;    dataList=dataList.concat(result);    //判断是否已加载完    if(result.length&lt;pageSize) isMore=false;    //将dataList渲染到html内容中&#125;    

注意点：
使用better-scroll 实现下拉刷新、上拉加载时要注意以下几点：

wrapper里必须只有一个子元素
子元素的高度要比wrapper要高
使用的时候，要确定DOM元素是否已经生成，必须要等到DOM渲染完成后，再new BScroll()
滚动区域的DOM元素结构有变化后，需要执行刷新 refresh() 
上拉或者下拉，结束后，需要执行finishPullUp()或者finishPullDown()，否则将不会执行下次操作
better-scroll，默认会阻止浏览器的原生click事件，如果滚动内容区要添加点击事件，需要在实例化属性里设置click:true

小结下拉刷新、上拉加载原理本身都很简单，真正复杂的是封装过程中，要考虑的兼容性、易用性、性能等诸多细节
参考文献
https://segmentfault.com/a/1190000014423308
https://github.com/ustbhuangyi/better-scroll

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>对正则表达式的理解？应用场景？</title>
    <url>/2023/12/10/JavaScript-regexp/</url>
    <content><![CDATA[
一、是什么正则表达式是一种用来匹配字符串的强有力的武器
它的设计思想是用一种描述性的语言定义一个规则，凡是符合规则的字符串，我们就认为它”匹配”了，否则，该字符串就是不合法的
在 JavaScript中，正则表达式也是对象，构建正则表达式有两种方式：

字面量创建，其由包含在斜杠之间的模式组成

const re = /\d+/g;


调用RegExp对象的构造函数

const re = new RegExp(&quot;\\d+&quot;,&quot;g&quot;);const rul = &quot;\\d+&quot;const re1 = new RegExp(rul,&quot;g&quot;);

使用构建函数创建，第一个参数可以是一个变量，遇到特殊字符\需要使用\\进行转义
二、匹配规则常见的校验规则如下：



规则
描述



\
转义


^
匹配输入的开始


$
匹配输入的结束


*
匹配前一个表达式 0 次或多次


+
匹配前面一个表达式 1 次或者多次。等价于 &#123;1,&#125;


?
匹配前面一个表达式 0 次或者 1 次。等价于&#123;0,1&#125;


.
默认匹配除换行符之外的任何单个字符


x(?&#x3D;y)
匹配’x’仅仅当’x’后面跟着’y’。这种叫做先行断言


(?&lt;&#x3D;y)x
匹配’x’仅当’x’前面是’y’.这种叫做后行断言


x(?!y)
仅仅当’x’后面不跟着’y’时匹配’x’，这被称为正向否定查找


(?&lt;!y)x
仅仅当’x’前面不是’y’时匹配’x’，这被称为反向否定查找


x|y
匹配’x’或者’y’


{n}
n 是一个正整数，匹配了前面一个字符刚好出现了 n 次


{n,}
n是一个正整数，匹配前一个字符至少出现了n次


{n,m}
n 和 m 都是整数。匹配前面的字符至少n次，最多m次


[xyz]
一个字符集合。匹配方括号中的任意字符


[^xyz]
匹配任何没有包含在方括号中的字符


\b
匹配一个词的边界，例如在字母和空格之间


\B
匹配一个非单词边界


\d
匹配一个数字


\D
匹配一个非数字字符


\f
匹配一个换页符


\n
匹配一个换行符


\r
匹配一个回车符


\s
匹配一个空白字符，包括空格、制表符、换页符和换行符


\S
匹配一个非空白字符


\w
匹配一个单字字符（字母、数字或者下划线）


\W
匹配一个非单字字符


正则表达式标记


标志
描述



g
全局搜索。


i
不区分大小写搜索。


m
多行搜索。


s
允许 . 匹配换行符。


u
使用unicode码的模式进行匹配。


y
执行”粘性(sticky)搜索,匹配从目标字符串的当前位置开始。


使用方法如下：
var re = /pattern/flags;var re = new RegExp(&quot;pattern&quot;, &quot;flags&quot;);

在了解下正则表达式基本的之外，还可以掌握几个正则表达式的特性：
贪婪模式在了解贪婪模式前，首先举个例子：
const reg = /ab&#123;1,3&#125;c/

在匹配过程中，尝试可能的顺序是从多往少的方向去尝试。首先会尝试bbb，然后再看整个正则是否能匹配。不能匹配时，吐出一个b，即在bb的基础上，再继续尝试，以此重复
如果多个贪婪量词挨着，则深度优先搜索
const string = &quot;12345&quot;;const regx = /(\d&#123;1,3&#125;)(\d&#123;1,3&#125;)/;console.log( string.match(reg) );// =&gt; [&quot;12345&quot;, &quot;123&quot;, &quot;45&quot;, index: 0, input: &quot;12345&quot;]

其中，前面的\d&#123;1,3&#125;匹配的是”123”，后面的\d&#123;1,3&#125;匹配的是”45”
懒惰模式惰性量词就是在贪婪量词后面加个问号。表示尽可能少的匹配
var string = &quot;12345&quot;;var regex = /(\d&#123;1,3&#125;?)(\d&#123;1,3&#125;)/;console.log( string.match(regex) );// =&gt; [&quot;1234&quot;, &quot;1&quot;, &quot;234&quot;, index: 0, input: &quot;12345&quot;]

其中\d&#123;1,3&#125;?只匹配到一个字符”1”，而后面的\d&#123;1,3&#125;匹配了”234”
分组分组主要是用过()进行实现，比如beyond&#123;3&#125;，是匹配d字母3次。而(beyond)&#123;3&#125;是匹配beyond三次
在()内使用|达到或的效果，如(abc | xxx)可以匹配abc或者xxx
反向引用，巧用$分组捕获
let str = &quot;John Smith&quot;;// 交换名字和姓氏console.log(str.replace(/(john) (smith)/i, &#x27;$2, $1&#x27;)) // Smith, John





三、匹配方法正则表达式常被用于某些方法，我们可以分成两类：

字符串（str）方法：match、matchAll、search、replace、split
正则对象下（regexp）的方法：test、exec




方法
描述



exec
一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回 null）。


test
一个在字符串中测试是否匹配的RegExp方法，它返回 true 或 false。


match
一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null。


matchAll
一个在字符串中执行查找所有匹配的String方法，它返回一个迭代器（iterator）。


search
一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。


replace
一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。


split
一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 String 方法。


str.match(regexp)str.match(regexp) 方法在字符串 str 中找到匹配 regexp 的字符
如果 regexp 不带有 g 标记，则它以数组的形式返回第一个匹配项，其中包含分组和属性 index（匹配项的位置）、input（输入字符串，等于 str）
let str = &quot;I love JavaScript&quot;;let result = str.match(/Java(Script)/);console.log( result[0] );     // JavaScript（完全匹配）console.log( result[1] );     // Script（第一个分组）console.log( result.length ); // 2// 其他信息：console.log( result.index );  // 7（匹配位置）console.log( result.input );  // I love JavaScript（源字符串）

如果 regexp 带有 g 标记，则它将所有匹配项的数组作为字符串返回，而不包含分组和其他详细信息
let str = &quot;I love JavaScript&quot;;let result = str.match(/Java(Script)/g);console.log( result[0] ); // JavaScriptconsole.log( result.length ); // 1

如果没有匹配项，则无论是否带有标记 g ，都将返回 null
let str = &quot;I love JavaScript&quot;;let result = str.match(/HTML/);console.log(result); // null



str.matchAll(regexp)返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器
const regexp = /t(e)(st(\d?))/g;const str = &#x27;test1test2&#x27;;const array = [...str.matchAll(regexp)];console.log(array[0]);// expected output: Array [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;]console.log(array[1]);// expected output: Array [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;]







str.search(regexp)返回第一个匹配项的位置，如果未找到，则返回 -1
let str = &quot;A drop of ink may make a million think&quot;;console.log( str.search( /ink/i ) ); // 10（第一个匹配位置）

这里需要注意的是，search 仅查找第一个匹配项
str.replace(regexp)替换与正则表达式匹配的子串，并返回替换后的字符串。在不设置全局匹配g的时候，只替换第一个匹配成功的字符串片段
const reg1=/javascript/i;const reg2=/javascript/ig;console.log(&#x27;hello Javascript Javascript Javascript&#x27;.replace(reg1,&#x27;js&#x27;));//hello js Javascript Javascriptconsole.log(&#x27;hello Javascript Javascript Javascript&#x27;.replace(reg2,&#x27;js&#x27;));//hello js js js



str.split(regexp)使用正则表达式（或子字符串）作为分隔符来分割字符串
console.log(&#x27;12, 34, 56&#x27;.split(/,\s*/)) // 数组 [&#x27;12&#x27;, &#x27;34&#x27;, &#x27;56&#x27;]



regexp.exec(str)regexp.exec(str) 方法返回字符串 str 中的 regexp 匹配项，与以前的方法不同，它是在正则表达式而不是字符串上调用的
根据正则表达式是否带有标志 g，它的行为有所不同
如果没有 g，那么 regexp.exec(str) 返回的第一个匹配与 str.match(regexp) 完全相同
如果有标记 g，调用 regexp.exec(str) 会返回第一个匹配项，并将紧随其后的位置保存在属性regexp.lastIndex 中。 下一次同样的调用会从位置 regexp.lastIndex 开始搜索，返回下一个匹配项，并将其后的位置保存在 regexp.lastIndex 中
let str = &#x27;More about JavaScript at https://javascript.info&#x27;;let regexp = /javascript/ig;let result;while (result = regexp.exec(str)) &#123;  console.log( `Found $&#123;result[0]&#125; at position $&#123;result.index&#125;` );  // Found JavaScript at position 11  // Found javascript at position 33&#125;



regexp.test(str)查找匹配项，然后返回 true/false 表示是否存在
let str = &quot;I love JavaScript&quot;;// 这两个测试相同console.log( /love/i.test(str) ); // true





四、应用场景通过上面的学习，我们对正则表达式有了一定的了解
下面再来看看正则表达式一些案例场景：
验证QQ合法性（5~15位、全是数字、不以0开头）：
const reg = /^[1-9][0-9]&#123;4,14&#125;$/const isvalid = patrn.exec(s)

校验用户账号合法性（只能输入5-20个以字母开头、可带数字、”_”、”.”的字串）：
var patrn=/^[a-zA-Z]&#123;1&#125;([a-zA-Z0-9]|[._])&#123;4,19&#125;$/;const isvalid = patrn.exec(s)

将url参数解析为对象
const protocol = &#x27;(?&lt;protocol&gt;https?:)&#x27;;const host = &#x27;(?&lt;host&gt;(?&lt;hostname&gt;[^/#?:]+)(?::(?&lt;port&gt;\\d+))?)&#x27;;const path = &#x27;(?&lt;pathname&gt;(?:\\/[^/#?]+)*\\/?)&#x27;;const search = &#x27;(?&lt;search&gt;(?:\\?[^#]*)?)&#x27;;const hash = &#x27;(?&lt;hash&gt;(?:#.*)?)&#x27;;const reg = new RegExp(`^$&#123;protocol&#125;\/\/$&#123;host&#125;$&#123;path&#125;$&#123;search&#125;$&#123;hash&#125;$`);function execURL(url)&#123;    const result = reg.exec(url);    if(result)&#123;        result.groups.port = result.groups.port || &#x27;&#x27;;        return result.groups;    &#125;    return &#123;        protocol:&#x27;&#x27;,host:&#x27;&#x27;,hostname:&#x27;&#x27;,port:&#x27;&#x27;,        pathname:&#x27;&#x27;,search:&#x27;&#x27;,hash:&#x27;&#x27;,    &#125;;&#125;console.log(execURL(&#x27;https://localhost:8080/?a=b#xxxx&#x27;));protocol: &quot;https:&quot;host: &quot;localhost:8080&quot;hostname: &quot;localhost&quot;port: &quot;8080&quot;pathname: &quot;/&quot;search: &quot;?a=b&quot;hash: &quot;#xxxx&quot;

再将上面的search和hash进行解析
function execUrlParams(str)&#123;    str = str.replace(/^[#?&amp;]/,&#x27;&#x27;);    const result = &#123;&#125;;    if(!str)&#123; //如果正则可能配到空字符串，极有可能造成死循环，判断很重要        return result;     &#125;    const reg = /(?:^|&amp;)([^&amp;=]*)=?([^&amp;]*?)(?=&amp;|$)/y    let exec = reg.exec(str);    while(exec)&#123;        result[exec[1]] = exec[2];        exec = reg.exec(str);    &#125;    return result;&#125;console.log(execUrlParams(&#x27;#&#x27;));// &#123;&#125;console.log(execUrlParams(&#x27;##&#x27;));//&#123;&#x27;#&#x27;:&#x27;&#x27;&#125;console.log(execUrlParams(&#x27;?q=3606&amp;src=srp&#x27;)); //&#123;q: &quot;3606&quot;, src: &quot;srp&quot;&#125;console.log(execUrlParams(&#x27;test=a=b=c&amp;&amp;==&amp;a=&#x27;));//&#123;test: &quot;a=b=c&quot;, &quot;&quot;: &quot;=&quot;, a: &quot;&quot;&#125;

参考文献
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>对作用域链的理解</title>
    <url>/2023/12/19/JavaScript-scope/</url>
    <content><![CDATA[ 
一、作用域作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合
换句话说，作用域决定了代码区块中变量和其他资源的可见性
举个例子
function myFunction() &#123;    let inVariable = &quot;函数内部变量&quot;;&#125;myFunction();//要先执行这个函数，否则根本不知道里面是啥console.log(inVariable); // Uncaught ReferenceError: inVariable is not defined

上述例子中，函数myFunction内部创建一个inVariable变量，当我们在全局访问这个变量的时候，系统会报错
这就说明我们在全局是无法获取到（闭包除外）函数内部的变量
我们一般将作用域分成：

全局作用域

函数作用域

块级作用域


全局作用域任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问
// 全局变量var greeting = &#x27;Hello World!&#x27;;function greet() &#123;  console.log(greeting);&#125;// 打印 &#x27;Hello World!&#x27;greet();


函数作用域函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问
function greet() &#123;  var greeting = &#x27;Hello World!&#x27;;  console.log(greeting);&#125;// 打印 &#x27;Hello World!&#x27;greet();// 报错： Uncaught ReferenceError: greeting is not definedconsole.log(greeting);
可见上述代码中在函数内部声明的变量或函数，在函数外部是无法访问的，这说明在函数内部定义的变量或者方法只是函数作用域
块级作用域ES6引入了let和const关键字,和var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量
&#123;  // 块级作用域中的变量  let greeting = &#x27;Hello World!&#x27;;  var lang = &#x27;English&#x27;;  console.log(greeting); // Prints &#x27;Hello World!&#x27;&#125;// 变量 &#x27;English&#x27;console.log(lang);// 报错：Uncaught ReferenceError: greeting is not definedconsole.log(greeting);



二、词法作用域词法作用域，又叫静态作用域，变量被创建时就确定好了，而非执行阶段确定的。也就是说我们写好代码时它的作用域就确定了，JavaScript 遵循的就是词法作用域
var a = 2;function foo()&#123;    console.log(a)&#125;function bar()&#123;    var a = 3;    foo();&#125;bar()

上述代码改变成一张图
 
由于JavaScript遵循词法作用域，相同层级的 foo 和 bar 就没有办法访问到彼此块作用域中的变量，所以输出2
三、作用域链当在Javascript中使用一个变量的时候，首先Javascript引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域
如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错
这里拿《你不知道的Javascript(上)》中的一张图解释：
把作用域比喻成一个建筑，这份建筑代表程序中的嵌套作用域链，第一层代表当前的执行作用域，顶层代表全局作用域
 
变量的引用会顺着当前楼层进行查找，如果找不到，则会往上一层找，一旦到达顶层，查找的过程都会停止
下面代码演示下：
var sex = &#x27;男&#x27;;function person() &#123;    var name = &#x27;张三&#x27;;    function student() &#123;        var age = 18;        console.log(name); // 张三        console.log(sex); // 男     &#125;    student();    console.log(age); // Uncaught ReferenceError: age is not defined&#125;person();

上述代码主要主要做了以下工作：

student函数内部属于最内层作用域，找不到name，向上一层作用域person函数内部找，找到了输出”张三”
student内部输出sex时找不到，向上一层作用域person函数找，还找不到继续向上一层找，即全局作用域，找到了输出”男”
在person函数内部输出age时找不到，向上一层作用域找，即全局作用域，还是找不到则报错

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是单点登录？如何实现？</title>
    <url>/2023/06/13/JavaScript-single-sign/</url>
    <content><![CDATA[ 
一、是什么单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一
SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统
SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过passport，子系统本身将不参与登录操作
当一个系统成功登录以后，passport将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被passport授权以后，会建立一个局部会话，在一定时间内可以无需再次向passport发起认证
 
上图有四个系统，分别是Application1、Application2、Application3、和SSO，当Application1、Application2、Application3需要登录时，将跳到SSO系统，SSO系统完成登录，其他的应用系统也就随之登录了
举个例子淘宝、天猫都属于阿里旗下，当用户登录淘宝后，再打开天猫，系统便自动帮用户登录了天猫，这种现象就属于单点登录
二、如何实现同域名下的单点登录cookie的domain属性设置为当前域的父域，并且父域的cookie会被子域所共享。path属性默认为web应用的上下文路径
利用 Cookie 的这个特点，没错，我们只需要将Cookie的 domain属性设置为父域的域名（主域名），同时将 Cookie 的path属性设置为根路径，将 Session ID（或 Token）保存到父域中。这样所有的子域应用就都可以访问到这个Cookie
不过这要求应用系统的域名需建立在一个共同的主域名之下，如 tieba.baidu.com 和 map.baidu.com，它们都建立在 baidu.com 这个主域名之下，那么它们就可以通过这种方式来实现单点登录
不同域名下的单点登录(一)如果是不同域的情况下，Cookie是不共享的，这里我们可以部署一个认证中心，用于专门处理登录请求的独立的 Web 服务
用户统一在认证中心进行登录，登录成功后，认证中心记录用户的登录状态，并将 token 写入 Cookie（注意这个 Cookie 是认证中心的，应用系统是访问不到的）
应用系统检查当前请求有没有 Token，如果没有，说明用户在当前系统中尚未登录，那么就将页面跳转至认证中心
由于这个操作会将认证中心的 Cookie 自动带过去，因此，认证中心能够根据 Cookie 知道用户是否已经登录过了
如果认证中心发现用户尚未登录，则返回登录页面，等待用户登录
如果发现用户已经登录过了，就不会让用户再次登录了，而是会跳转回目标 URL ，并在跳转前生成一个 Token，拼接在目标 URL 的后面，回传给目标应用系统
应用系统拿到 Token 之后，还需要向认证中心确认下 Token 的合法性，防止用户伪造。确认无误后，应用系统记录用户的登录状态，并将 Token 写入 Cookie，然后给本次访问放行。（注意这个 Cookie 是当前应用系统的）当用户再次访问当前应用系统时，就会自动带上这个 Token，应用系统验证 Token 发现用户已登录，于是就不会有认证中心什么事了
此种实现方式相对复杂，支持跨域，扩展性好，是单点登录的标准做法
不同域名下的单点登录(二)可以选择将 Session ID （或 Token ）保存到浏览器的 LocalStorage 中，让前端在每次向后端发送请求时，主动将LocalStorage的数据传递给服务端
这些都是由前端来控制的，后端需要做的仅仅是在用户登录成功后，将 Session ID （或 Token ）放在响应体中传递给前端
单点登录完全可以在前端实现。前端拿到 Session ID （或 Token ）后，除了将它写入自己的 LocalStorage 中之外，还可以通过特殊手段将它写入多个其他域下的 LocalStorage 中
关键代码如下：
// 获取 tokenvar token = result.data.token; // 动态创建一个不可见的iframe，在iframe中加载一个跨域HTMLvar iframe = document.createElement(&quot;iframe&quot;);iframe.src = &quot;http://app1.com/localstorage.html&quot;;document.body.append(iframe);// 使用postMessage()方法将token传递给iframesetTimeout(function () &#123;    iframe.contentWindow.postMessage(token, &quot;http://app1.com&quot;);&#125;, 4000);setTimeout(function () &#123;    iframe.remove();&#125;, 6000); // 在这个iframe所加载的HTML中绑定一个事件监听器，当事件被触发时，把接收到的token数据写入localStoragewindow.addEventListener(&#x27;message&#x27;, function (event) &#123;    localStorage.setItem(&#x27;token&#x27;, event.data)&#125;, false);

前端通过 iframe+postMessage() 方式，将同一份 Token 写入到了多个域下的 LocalStorage 中，前端每次在向后端发送请求之前，都会主动从 LocalStorage 中读取Token并在请求中携带，这样就实现了同一份 Token 被多个域所共享
此种实现方式完全由前端控制，几乎不需要后端参与，同样支持跨域
三、流程单点登录的流程图如下所示：
 

用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数

sso认证中心发现用户未登录，将用户引导至登录页面

用户输入用户名密码提交登录申请

sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌

sso认证中心带着令牌跳转会最初的请求地址（系统1）

系统1拿到令牌，去sso认证中心校验令牌是否有效

sso认证中心校验令牌，返回有效，注册系统1

系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源

用户访问系统2的受保护资源

系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数

sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌

系统2拿到令牌，去sso认证中心校验令牌是否有效

sso认证中心校验令牌，返回有效，注册系统2

系统2使用该令牌创建与用户的局部会话，返回受保护资源


用户登录成功之后，会与sso认证中心及各个子系统建立会话，用户与sso认证中心建立的会话称为全局会话
用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过sso认证中心
全局会话与局部会话有如下约束关系：

局部会话存在，全局会话一定存在
全局会话存在，局部会话不一定存在
全局会话销毁，局部会话必须销毁

参考文献
https://blog.csdn.net/weixin_36380516/article/details/109006828
https://baike.baidu.com/item/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95
https://juejin.cn/post/6844903664985866253

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript字符串的常用方法有哪些？</title>
    <url>/2023/06/22/JavaScript-string-api/</url>
    <content><![CDATA[ 
一、操作方法我们也可将字符串常用的操作方法归纳为增、删、改、查，需要知道字符串的特点是一旦创建了，就不可变
增这里增的意思并不是说直接增添内容，而是创建字符串的一个副本，再进行操作
除了常用+以及$&#123;&#125;进行字符串拼接之外，还可通过concat
concat用于将一个或多个字符串拼接成一个新字符串
let stringValue = &quot;hello &quot;;let result = stringValue.concat(&quot;world&quot;);console.log(result); // &quot;hello world&quot;console.log(stringValue); // &quot;hello&quot;



删这里的删的意思并不是说删除原字符串的内容，而是创建字符串的一个副本，再进行操作
常见的有：

slice()
substr()
substring()

这三个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。
let stringValue = &quot;hello world&quot;;console.log(stringValue.slice(3)); // &quot;lo world&quot;console.log(stringValue.substring(3)); // &quot;lo world&quot;console.log(stringValue.substr(3)); // &quot;lo world&quot;console.log(stringValue.slice(3, 7)); // &quot;lo w&quot;console.log(stringValue.substring(3,7)); // &quot;lo w&quot;console.log(stringValue.substr(3, 7)); // &quot;lo worl&quot;



改这里改的意思也不是改变原字符串，而是创建字符串的一个副本，再进行操作
常见的有：

trim()、trimLeft()、trimRight()

repeat()

padStart()、padEnd()

toLowerCase()、 toUpperCase()


trim()、trimLeft()、trimRight()删除前、后或前后所有空格符，再返回新的字符串
let stringValue = &quot; hello world &quot;;let trimmedStringValue = stringValue.trim();console.log(stringValue); // &quot; hello world &quot;console.log(trimmedStringValue); // &quot;hello world&quot;



repeat()接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果
let stringValue = &quot;na &quot;;let copyResult = stringValue.repeat(2) // na na 



padEnd()复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件
let stringValue = &quot;foo&quot;;console.log(stringValue.padStart(6)); // &quot; foo&quot;console.log(stringValue.padStart(9, &quot;.&quot;)); // &quot;......foo&quot;



toLowerCase()、 toUpperCase()大小写转化
let stringValue = &quot;hello world&quot;;console.log(stringValue.toUpperCase()); // &quot;HELLO WORLD&quot;console.log(stringValue.toLowerCase()); // &quot;hello world&quot;



查除了通过索引的方式获取字符串的值，还可通过：

chatAt()

indexOf()

startWith()

includes()


charAt()返回给定索引位置的字符，由传给方法的整数参数指定
let message = &quot;abcde&quot;;console.log(message.charAt(2)); // &quot;c&quot;



indexOf()从字符串开头去搜索传入的字符串，并返回位置（如果没找到，则返回 -1 ）
let stringValue = &quot;hello world&quot;;console.log(stringValue.indexOf(&quot;o&quot;)); // 4



startWith()、includes()从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值
let message = &quot;foobarbaz&quot;;console.log(message.startsWith(&quot;foo&quot;)); // trueconsole.log(message.startsWith(&quot;bar&quot;)); // falseconsole.log(message.includes(&quot;bar&quot;)); // trueconsole.log(message.includes(&quot;qux&quot;)); // false





二、转换方法split把字符串按照指定的分割符，拆分成数组中的每一项
let str = &quot;12+23+34&quot;let arr = str.split(&quot;+&quot;) // [12,23,34]



三、模板匹配方法针对正则表达式，字符串设计了几个方法：

match()
search()
replace()

match()接收一个参数，可以是一个正则表达式字符串，也可以是一个RegExp对象，返回数组
let text = &quot;cat, bat, sat, fat&quot;;let pattern = /.at/;let matches = text.match(pattern);console.log(matches[0]); // &quot;cat&quot;



search()接收一个参数，可以是一个正则表达式字符串，也可以是一个RegExp对象，找到则返回匹配索引，否则返回 -1
let text = &quot;cat, bat, sat, fat&quot;;let pos = text.search(/at/);console.log(pos); // 1



replace()接收两个参数，第一个参数为匹配的内容，第二个参数为替换的元素（可用函数）
let text = &quot;cat, bat, sat, fat&quot;;let result = text.replace(&quot;at&quot;, &quot;ond&quot;);console.log(result); // &quot;cond, bat, sat, fat&quot;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>举例说明你对尾递归的理解，有哪些应用场景</title>
    <url>/2023/07/21/JavaScript-tail-recursion/</url>
    <content><![CDATA[ 
一、递归递归（英语：Recursion）
在数学与计算机科学中，是指在函数的定义中使用函数自身的方法
在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数
其核心思想是把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解
一般来说，递归需要有边界条件、递归前进阶段和递归返回阶段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回
下面实现一个函数 pow(x, n)，它可以计算 x 的 n 次方
使用迭代的方式，如下：
function pow(x, n) &#123;  let result = 1;  // 再循环中，用 x 乘以 result n 次  for (let i = 0; i &lt; n; i++) &#123;    result *= x;  &#125;  return result;&#125;

使用递归的方式，如下：
function pow(x, n) &#123;  if (n == 1) &#123;    return x;  &#125; else &#123;    return x * pow(x, n - 1);  &#125;&#125;

pow(x, n) 被调用时，执行分为两个分支：
             if n==1  = x             /pow(x, n) =             \              else     = x * pow(x, n - 1)

也就是说pow 递归地调用自身 直到 n == 1
 
为了计算 pow(2, 4)，递归变体经过了下面几个步骤：

pow(2, 4) = 2 * pow(2, 3)
pow(2, 3) = 2 * pow(2, 2)
pow(2, 2) = 2 * pow(2, 1)
pow(2, 1) = 2

因此，递归将函数调用简化为一个更简单的函数调用，然后再将其简化为一个更简单的函数，以此类推，直到结果
二、尾递归尾递归，即在函数尾位置调用自身（或是一个尾调用本身的其他函数等等）。尾递归也是递归的一种特殊情形。尾递归是一种特殊的尾调用，即在尾部直接调用自身的递归函数
尾递归在普通尾调用的基础上，多出了2个特征：

在尾部调用的是函数自身
可通过优化，使得计算仅占用常量栈空间

在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储，递归次数过多容易造成栈溢出
这时候，我们就可以使用尾递归，即一个函数中所有递归形式的调用都出现在函数的末尾，对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误
实现一下阶乘，如果用普通的递归，如下：
function factorial(n) &#123;  if (n === 1) return 1;  return n * factorial(n - 1);&#125;factorial(5) // 120

如果n等于5，这个方法要执行5次，才返回最终的计算表达式，这样每次都要保存这个方法，就容易造成栈溢出，复杂度为O(n)
如果我们使用尾递归，则如下：
function factorial(n, total) &#123;  if (n === 1) return total;  return factorial(n - 1, n * total);&#125;factorial(5, 1) // 120

可以看到，每一次返回的就是一个新的函数，不带上一个函数的参数，也就不需要储存上一个函数了。尾递归只需要保存一个调用栈，复杂度 O(1)
二、应用场景数组求和
function sumArray(arr, total) &#123;    if(arr.length === 1) &#123;        return total    &#125;    return sum(arr, total + arr.pop())&#125;

使用尾递归优化求斐波那契数列
function factorial2 (n, start = 1, total = 1) &#123;    if(n &lt;= 2)&#123;        return total    &#125;    return factorial2 (n -1, total, total + start)&#125;

数组扁平化
let a = [1,2,3, [1,2,3, [1,2,3]]]// 变成let a = [1,2,3,1,2,3,1,2,3]// 具体实现function flat(arr = [], result = []) &#123;    arr.forEach(v =&gt; &#123;        if(Array.isArray(v)) &#123;            result = result.concat(flat(v, []))        &#125;else &#123;            result.push(v)        &#125;    &#125;)    return result&#125;

数组对象格式化
let obj = &#123;    a: &#x27;1&#x27;,    b: &#123;        c: &#x27;2&#x27;,        D: &#123;            E: &#x27;3&#x27;        &#125;    &#125;&#125;// 转化为如下：let obj = &#123;    a: &#x27;1&#x27;,    b: &#123;        c: &#x27;2&#x27;,        d: &#123;            e: &#x27;3&#x27;        &#125;    &#125;&#125;// 代码实现function keysLower(obj) &#123;    let reg = new RegExp(&quot;([A-Z]+)&quot;, &quot;g&quot;);    for (let key in obj) &#123;        if (obj.hasOwnProperty(key)) &#123;            let temp = obj[key];            if (reg.test(key.toString())) &#123;                // 将修改后的属性名重新赋值给temp，并在对象obj内添加一个转换后的属性                temp = obj[key.replace(reg, function (result) &#123;                    return result.toLowerCase()                &#125;)] = obj[key];                // 将之前大写的键属性删除                delete obj[key];            &#125;            // 如果属性是对象或者数组，重新执行函数            if (typeof temp === &#x27;object&#x27; || Object.prototype.toString.call(temp) === &#x27;[object Array]&#x27;) &#123;                keysLower(temp);            &#125;        &#125;    &#125;    return obj;&#125;;



参考文献
https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>web常见的攻击方式有哪些？如何防御？</title>
    <url>/2023/05/11/JavaScript-security/</url>
    <content><![CDATA[ 
一、是什么Web攻击（WebAttack）是针对用户上网行为或网站服务器等设备进行攻击的行为
如植入恶意代码，修改网站权限，获取网站用户隐私信息等等
Web应用程序的安全性是任何基于Web业务的重要组成部分
确保Web应用程序安全十分重要，即使是代码中很小的 bug 也有可能导致隐私信息被泄露
站点安全就是为保护站点不受未授权的访问、使用、修改和破坏而采取的行为或实践
我们常见的Web攻击方式有

XSS (Cross Site Scripting) 跨站脚本攻击
CSRF（Cross-site request forgery）跨站请求伪造
SQL注入攻击

二、XSSXSS，跨站脚本攻击，允许攻击者将恶意代码植入到提供给其它用户使用的页面中
XSS涉及到三方，即攻击者、客户端与Web应用
XSS的攻击目标是为了盗取存储在客户端的cookie或者其他网站用于识别客户端身份的敏感信息。一旦获取到合法用户的信息后，攻击者甚至可以假冒合法用户与网站进行交互
举个例子：
一个搜索页面，根据url参数决定关键词的内容
&lt;input type=&quot;text&quot; value=&quot;&lt;%= getParameter(&quot;keyword&quot;) %&gt;&quot;&gt;&lt;button&gt;搜索&lt;/button&gt;&lt;div&gt;  您搜索的关键词是：&lt;%= getParameter(&quot;keyword&quot;) %&gt;&lt;/div&gt;

这里看似并没有问题，但是如果不按套路出牌呢？
用户输入&quot;&gt;&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;，拼接到 HTML 中返回给浏览器。形成了如下的 HTML：
&lt;input type=&quot;text&quot; value=&quot;&quot;&gt;&lt;script&gt;alert(&#x27;XSS&#x27;);&lt;/script&gt;&quot;&gt;&lt;button&gt;搜索&lt;/button&gt;&lt;div&gt;  您搜索的关键词是：&quot;&gt;&lt;script&gt;alert(&#x27;XSS&#x27;);&lt;/script&gt;&lt;/div&gt;

浏览器无法分辨出 &lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt; 是恶意代码，因而将其执行，试想一下，如果是获取cookie发送对黑客服务器呢？
根据攻击的来源，XSS攻击可以分成：

存储型
反射型
DOM 型

存储型存储型 XSS 的攻击步骤：

攻击者将恶意代码提交到目标网站的数据库中
用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器
用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行
恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作

这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等
反射型 XSS反射型 XSS 的攻击步骤：

攻击者构造出特殊的 URL，其中包含恶意代码
用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器
用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行
恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作

反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。
反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。
由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。
POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见
DOM 型 XSSDOM 型 XSS 的攻击步骤：

攻击者构造出特殊的 URL，其中包含恶意代码
用户打开带有恶意代码的 URL
用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行
恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作

DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞
XSS的预防通过前面介绍，看到XSS攻击的两大要素：

攻击者提交而恶意代码
浏览器执行恶意代码

针对第一个要素，我们在用户输入的过程中，过滤掉用户输入的恶劣代码，然后提交给后端，但是如果攻击者绕开前端请求，直接构造请求就不能预防了
而如果在后端写入数据库前，对输入进行过滤，然后把内容给前端，但是这个内容在不同地方就会有不同显示
例如：
一个正常的用户输入了 5 &lt; 7 这个内容，在写入数据库前，被转义，变成了 5 &lt; 7
在客户端中，一旦经过了 escapeHTML()，客户端显示的内容就变成了乱码( 5 &lt; 7 )
在前端中，不同的位置所需的编码也不同。

当 5 &lt; 7 作为 HTML 拼接页面时，可以正常显示：

&lt;div title=&quot;comment&quot;&gt;5 &amp;lt; 7&lt;/div&gt;


当 5 &lt; 7 通过 Ajax 返回，然后赋值给 JavaScript 的变量时，前端得到的字符串就是转义后的字符。这个内容不能直接用于 Vue 等模板的展示，也不能直接用于内容长度计算。不能用于标题、alert 等

可以看到，过滤并非可靠的，下面就要通过防止浏览器执行恶意代码：
在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等
如果用 Vue/React 技术栈，并且不使用 v-html&#x2F;dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患
DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，&lt;a&gt; 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免
&lt;!-- 链接内包含恶意代码 --&gt;&lt; a href=&quot; &quot;&gt;1&lt;/ a&gt;&lt;script&gt;// setTimeout()/setInterval() 中调用恶意代码setTimeout(&quot;UNTRUSTED&quot;)setInterval(&quot;UNTRUSTED&quot;)// location 调用恶意代码location.href = &#x27;UNTRUSTED&#x27;// eval() 中调用恶意代码eval(&quot;UNTRUSTED&quot;)





三、CSRFCSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求
利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目
一个典型的CSRF攻击有着如下的流程：

受害者登录a.com，并保留了登录凭证（Cookie）
攻击者引诱受害者访问了b.com
b.com 向 a.com 发送了一个请求：a.com&#x2F;act&#x3D;xx。浏览器会默认携带a.com的Cookie
a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求
a.com以受害者的名义执行了act&#x3D;xx
攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作

csrf可以通过get请求，即通过访问img的页面后，浏览器自动访问目标地址，发送请求
同样，也可以设置一个自动提交的表单发送post请求，如下：
&lt;form action=&quot;http://bank.example/withdraw&quot; method=POST&gt;    &lt;input type=&quot;hidden&quot; name=&quot;account&quot; value=&quot;xiaoming&quot; /&gt;    &lt;input type=&quot;hidden&quot; name=&quot;amount&quot; value=&quot;10000&quot; /&gt;    &lt;input type=&quot;hidden&quot; name=&quot;for&quot; value=&quot;hacker&quot; /&gt;&lt;/form&gt;&lt;script&gt; document.forms[0].submit(); &lt;/script&gt; 

访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作
还有一种为使用a标签的，需要用户点击链接才会触发
访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作
&lt; a href=&quot;http://test.com/csrf/withdraw.php?amount=1000&amp;for=hacker&quot; taget=&quot;_blank&quot;&gt;    重磅消息！！&lt;a/&gt;



CSRF的特点
攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生
攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据
整个过程攻击者并不能获取到受害者的登录凭证，仅仅是”冒用”
跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪

CSRF的预防CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性
防止csrf常用方案如下：

阻止不明外域的访问
同源检测
Samesite Cookie


提交时要求附加本域才能获取的信息
CSRF Token
双重Cookie验证



这里主要讲讲token这种形式，流程如下：

用户打开页面的时候，服务器需要给这个用户生成一个Token
对于GET请求，Token将附在请求地址之后。对于 POST 请求来说，要在 form 的最后加上

&lt;input type=&quot;hidden&quot; name=&quot;csrftoken&quot; value=&quot;tokenvalue&quot;/&gt;


当用户从客户端得到了Token，再次提交给服务器的时候，服务器需要判断Token的有效性

四、SQL注入Sql 注入攻击，是通过将恶意的 Sql 查询或添加语句插入到应用的输入参数中，再在后台 Sql 服务器上解析执行进行的攻击
 
流程如下所示：

找出SQL漏洞的注入点

判断数据库的类型以及版本

猜解用户名和密码

利用工具查找Web后台管理入口

入侵和破坏


预防方式如下：

严格检查输入变量的类型和格式
过滤和转义特殊字符
对访问数据库的Web应用程序采用Web应用防火墙

上述只是列举了常见的web攻击方式，实际开发过程中还会遇到很多安全问题，对于这些问题， 切记不可忽视
参考文献
https://tech.meituan.com/2018/09/27/fe-security.html
https://developer.mozilla.org/zh-CN/docs/learn/Server-side/First_steps/Website_security

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>说说JavaScript中的类型转换机制</title>
    <url>/2023/08/16/JavaScript-type-conversion/</url>
    <content><![CDATA[ 
一、概述前面我们讲到，JS 中有六种简单数据类型：undefined、null、boolean、string、number、symbol，以及引用类型：object
但是我们在声明的时候只有一种数据类型，只有到运行期间才会确定当前类型
let x = y ? 1 : a;

上面代码中，x的值在编译阶段是无法获取的，只有等到程序运行时才能知道
虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的，如果运算子的类型与预期不符合，就会触发类型转换机制
常见的类型转换有：

强制转换（显示转换）
自动转换（隐式转换）

二、显示转换显示转换，即我们很清楚可以看到这里发生了类型的转变，常见的方法有：

Number()
parseInt()
String()
Boolean()

Number()将任意类型的值转化为数值
先给出类型转换规则：
 
实践一下：
Number(324) // 324// 字符串：如果可以被解析为数值，则转换为相应的数值Number(&#x27;324&#x27;) // 324// 字符串：如果不可以被解析为数值，返回 NaNNumber(&#x27;324abc&#x27;) // NaN// 空字符串转为0Number(&#x27;&#x27;) // 0// 布尔值：true 转成 1，false 转成 0Number(true) // 1Number(false) // 0// undefined：转成 NaNNumber(undefined) // NaN// null：转成0Number(null) // 0// 对象：通常转换成NaN(除了只包含单个数值的数组)Number(&#123;a: 1&#125;) // NaNNumber([1, 2, 3]) // NaNNumber([5]) // 5

从上面可以看到，Number转换的时候是很严格的，只要有一个字符无法转成数值，整个字符串就会被转为NaN
parseInt()parseInt相比Number，就没那么严格了，parseInt函数逐个解析字符，遇到不能转换的字符就停下来
parseInt(&#x27;32a3&#x27;) //32



String()可以将任意类型的值转化成字符串
给出转换规则图：
   
实践一下：
// 数值：转为相应的字符串String(1) // &quot;1&quot;//字符串：转换后还是原来的值String(&quot;a&quot;) // &quot;a&quot;//布尔值：true转为字符串&quot;true&quot;，false转为字符串&quot;false&quot;String(true) // &quot;true&quot;//undefined：转为字符串&quot;undefined&quot;String(undefined) // &quot;undefined&quot;//null：转为字符串&quot;null&quot;String(null) // &quot;null&quot;//对象String(&#123;a: 1&#125;) // &quot;[object Object]&quot;String([1, 2, 3]) // &quot;1,2,3&quot;



Boolean()可以将任意类型的值转为布尔值，转换规则如下：
 
实践一下：
Boolean(undefined) // falseBoolean(null) // falseBoolean(0) // falseBoolean(NaN) // falseBoolean(&#x27;&#x27;) // falseBoolean(&#123;&#125;) // trueBoolean([]) // trueBoolean(new Boolean(false)) // true



三、隐式转换在隐式转换中，我们可能最大的疑惑是 ：何时发生隐式转换？
我们这里可以归纳为两种情况发生隐式转换的场景：

比较运算（==、!=、&gt;、&lt;）、if、while需要布尔值地方
算术运算（+、-、*、/、%）

除了上面的场景，还要求运算符两边的操作数不是同一类型
自动转换为布尔值在需要布尔值的地方，就会将非布尔值的参数自动转为布尔值，系统内部会调用Boolean函数
可以得出个小结：

undefined 
null 
false 
+0 
-0
NaN
“”

除了上面几种会被转化成false，其他都换被转化成true
自动转换成字符串遇到预期为字符串的地方，就会将非字符串的值自动转为字符串
具体规则是：先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串
常发生在+运算中，一旦存在字符串，则会进行字符串拼接操作
&#x27;5&#x27; + 1 // &#x27;51&#x27;&#x27;5&#x27; + true // &quot;5true&quot;&#x27;5&#x27; + false // &quot;5false&quot;&#x27;5&#x27; + &#123;&#125; // &quot;5[object Object]&quot;&#x27;5&#x27; + [] // &quot;5&quot;&#x27;5&#x27; + function ()&#123;&#125; // &quot;5function ()&#123;&#125;&quot;&#x27;5&#x27; + undefined // &quot;5undefined&quot;&#x27;5&#x27; + null // &quot;5null&quot;



自动转换成数值除了+有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值
&#x27;5&#x27; - &#x27;2&#x27; // 3&#x27;5&#x27; * &#x27;2&#x27; // 10true - 1  // 0false - 1 // -1&#x27;1&#x27; - 1   // 0&#x27;5&#x27; * []    // 0false / &#x27;5&#x27; // 0&#x27;abc&#x27; - 1   // NaNnull + 1 // 1undefined + 1 // NaN

null转为数值时，值为0 。undefined转为数值时，值为NaN
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>typeof 与 instanceof 区别</title>
    <url>/2023/09/10/JavaScript-typeof-instanceof/</url>
    <content><![CDATA[ 
一、typeoftypeof 操作符返回一个字符串，表示未经计算的操作数的类型
使用方法如下：
typeof operandtypeof(operand)

operand表示对象或原始值的表达式，其类型将被返回
举个例子
typeof 1 // &#x27;number&#x27;typeof &#x27;1&#x27; // &#x27;string&#x27;typeof undefined // &#x27;undefined&#x27;typeof true // &#x27;boolean&#x27;typeof Symbol() // &#x27;symbol&#x27;typeof null // &#x27;object&#x27;typeof [] // &#x27;object&#x27;typeof &#123;&#125; // &#x27;object&#x27;typeof console // &#x27;object&#x27;typeof console.log // &#x27;function&#x27;

从上面例子，前6个都是基础数据类型。虽然typeof null为object，但这只是 JavaScript 存在的一个悠久 Bug，不代表null 就是引用数据类型，并且null 本身也不是对象
所以，null 在 typeof 之后返回的是有问题的结果，不能作为判断null的方法。如果你需要在 if 语句中判断是否为 null，直接通过===null来判断就好
同时，可以发现引用类型数据，用typeof来判断的话，除了function会被识别出来之外，其余的都输出object
如果我们想要判断一个变量是否存在，可以使用typeof：(不能使用if(a)， 若a未声明，则报错)
if(typeof a != &#x27;undefined&#x27;)&#123;    //变量存在&#125;



二、instanceofinstanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上
使用如下：
object instanceof constructor

object为实例对象，constructor为构造函数
构造函数通过new可以实例对象，instanceof 能判断这个对象是否是之前那个构造函数生成的对象
// 定义构建函数let Car = function() &#123;&#125;let benz = new Car()benz instanceof Car // truelet car = new String(&#x27;xxx&#x27;)car instanceof String // truelet str = &#x27;xxx&#x27;str instanceof String // false

关于instanceof的实现原理，可以参考下面：
function myInstanceof(left, right) &#123;    // 这里先用typeof来判断基础数据类型，如果是，直接返回false    if(typeof left !== &#x27;object&#x27; || left === null) return false;    // getProtypeOf是Object对象自带的API，能够拿到参数的原型对象    let proto = Object.getPrototypeOf(left);    while(true) &#123;                          if(proto === null) return false;        if(proto === right.prototype) return true;//找到相同原型对象，返回true        proto = Object.getPrototypeof(proto);    &#125;&#125;

也就是顺着原型链去找，直到找到相同的原型对象，返回true，否则为false
三、区别typeof与instanceof都是判断数据类型的方法，区别如下：

typeof会返回一个变量的基本类型，instanceof返回的是一个布尔值

instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型

而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的也无法判断


可以看到，上述两种方法都有弊端，并不能满足所有场景的需求
如果需要通用检测数据类型，可以采用Object.prototype.toString，调用该方法，统一返回格式“[object Xxx]” 的字符串
如下
Object.prototype.toString(&#123;&#125;)       // &quot;[object Object]&quot;Object.prototype.toString.call(&#123;&#125;)  // 同上结果，加上call也okObject.prototype.toString.call(1)    // &quot;[object Number]&quot;Object.prototype.toString.call(&#x27;1&#x27;)  // &quot;[object String]&quot;Object.prototype.toString.call(true)  // &quot;[object Boolean]&quot;Object.prototype.toString.call(function()&#123;&#125;)  // &quot;[object Function]&quot;Object.prototype.toString.call(null)   //&quot;[object Null]&quot;Object.prototype.toString.call(undefined) //&quot;[object Undefined]&quot;Object.prototype.toString.call(/123/g)    //&quot;[object RegExp]&quot;Object.prototype.toString.call(new Date()) //&quot;[object Date]&quot;Object.prototype.toString.call([])       //&quot;[object Array]&quot;Object.prototype.toString.call(document)  //&quot;[object HTMLDocument]&quot;Object.prototype.toString.call(window)   //&quot;[object Window]&quot;

了解了toString的基本用法，下面就实现一个全局通用的数据类型判断方法
function getType(obj)&#123;  let type  = typeof obj;  if (type !== &quot;object&quot;) &#123;    // 先进行typeof判断，如果是基础数据类型，直接返回    return type;  &#125;  // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果  return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, &#x27;$1&#x27;); &#125;

使用如下
getType([])     // &quot;Array&quot; typeof []是object，因此toString返回getType(&#x27;123&#x27;)  // &quot;string&quot; typeof 直接返回getType(window) // &quot;Window&quot; toString返回getType(null)   // &quot;Null&quot;首字母大写，typeof null是object，需toString来判断getType(undefined)   // &quot;undefined&quot; typeof 直接返回getType()            // &quot;undefined&quot; typeof 直接返回getType(function()&#123;&#125;) // &quot;function&quot; typeof能判断，因此首字母小写getType(/123/g)      //&quot;RegExp&quot; toString返回]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的this指向问题</title>
    <url>/2023/07/29/JavaScript-this/</url>
    <content><![CDATA[ 
一、定义函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别
在绝大多数情况下，函数的调用方式决定了 this 的值（运行时绑定）
this 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象
举个例子：
function baz() &#123;    // 当前调用栈是：baz    // 因此，当前调用位置是全局作用域        console.log( &quot;baz&quot; );    bar(); // &lt;-- bar的调用位置&#125;function bar() &#123;    // 当前调用栈是：baz --&gt; bar    // 因此，当前调用位置在baz中        console.log( &quot;bar&quot; );    foo(); // &lt;-- foo的调用位置&#125;function foo() &#123;    // 当前调用栈是：baz --&gt; bar --&gt; foo    // 因此，当前调用位置在bar中        console.log( &quot;foo&quot; );&#125;baz(); // &lt;-- baz的调用位置

同时，this在函数执行过程中，this一旦被确定了，就不可以再更改
var a = 10;var obj = &#123;  a: 20&#125;function fn() &#123;  this = obj; // 修改this，运行后会报错  console.log(this.a);&#125;fn();





二、绑定规则根据不同的使用场合，this有不同的值，主要分为下面几种情况：

默认绑定

隐式绑定

new绑定

显示绑定


默认绑定全局环境中定义person函数，内部使用this关键字
var name = &#x27;Jenny&#x27;;function person() &#123;    return this.name;&#125;console.log(person());  //Jenny

上述代码输出Jenny，原因是调用函数的对象在游览器中位window，因此this指向window，所以输出Jenny
注意：
严格模式下，不能将全局对象用于默认绑定，this会绑定到undefined，只有函数运行在非严格模式下，默认绑定才能绑定到全局对象
隐式绑定函数还可以作为某个对象的方法调用，这时this就指这个上级对象
function test() &#123;  console.log(this.x);&#125;var obj = &#123;&#125;;obj.x = 1;obj.m = test;obj.m(); // 1

这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象
var o = &#123;    a:10,    b:&#123;        fn:function()&#123;            console.log(this.a); //undefined        &#125;    &#125;&#125;o.b.fn();

上述代码中，this的上一级对象为b，b内部并没有a变量的定义，所以输出undefined
这里再举一种特殊情况
var o = &#123;    a:10,    b:&#123;        a:12,        fn:function()&#123;            console.log(this.a); //undefined            console.log(this); //window        &#125;    &#125;&#125;var j = o.b.fn;j();

此时this指向的是window，这里的大家需要记住，this永远指向的是最后调用它的对象，虽然fn是对象b的方法，但是fn赋值给j时候并没有执行，所以最终指向window
new绑定通过构建函数new关键字生成一个实例对象，此时this指向这个实例对象
function test() &#123;　this.x = 1;&#125;var obj = new test();obj.x // 1

上述代码之所以能过输出1，是因为new关键字改变了this的指向
这里再列举一些特殊情况：
new过程遇到return一个对象，此时this指向为返回的对象
function fn()  &#123;      this.user = &#x27;xxx&#x27;;      return &#123;&#125;;  &#125;var a = new fn();  console.log(a.user); //undefined

如果返回一个简单类型的时候，则this指向实例对象
function fn()  &#123;      this.user = &#x27;xxx&#x27;;      return 1;&#125;var a = new fn;  console.log(a.user); //xxx

注意的是null虽然也是对象，但是此时new仍然指向实例对象
function fn()  &#123;      this.user = &#x27;xxx&#x27;;      return null;&#125;var a = new fn;  console.log(a.user); //xxx



显示修改apply()、call()、bind()是函数的一个方法，作用是改变函数的调用对象。它的第一个参数就表示改变后的调用这个函数的对象。因此，这时this指的就是这第一个参数
var x = 0;function test() &#123;　console.log(this.x);&#125;var obj = &#123;&#125;;obj.x = 1;obj.m = test;obj.m.apply(obj) // 1

关于apply、call、bind三者的区别，我们后面再详细说
三、箭头函数在 ES6 的语法中还提供了箭头函语法，让我们在代码书写时就能确定 this 的指向（编译时绑定）
举个例子：
const obj = &#123;  sayThis: () =&gt; &#123;    console.log(this);  &#125;&#125;;obj.sayThis(); // window 因为 JavaScript 没有块作用域，所以在定义 sayThis 的时候，里面的 this 就绑到 window 上去了const globalSay = obj.sayThis;globalSay(); // window 浏览器中的 global 对象

虽然箭头函数的this能够在编译的时候就确定了this的指向，但也需要注意一些潜在的坑
下面举个例子：
绑定事件监听
const button = document.getElementById(&#x27;mngb&#x27;);button.addEventListener(&#x27;click&#x27;, ()=&gt; &#123;    console.log(this === window) // true    this.innerHTML = &#x27;clicked button&#x27;&#125;)

上述可以看到，我们其实是想要this为点击的button，但此时this指向了window
包括在原型上添加方法时候，此时this指向window
Cat.prototype.sayName = () =&gt; &#123;    console.log(this === window) //true    return this.name&#125;const cat = new Cat(&#x27;mm&#x27;);cat.sayName()

同样的，箭头函数不能作为构建函数
四、优先级隐式绑定 VS 显式绑定function foo() &#123;    console.log( this.a );&#125;var obj1 = &#123;    a: 2,    foo: foo&#125;;var obj2 = &#123;    a: 3,    foo: foo&#125;;obj1.foo(); // 2obj2.foo(); // 3obj1.foo.call( obj2 ); // 3obj2.foo.call( obj1 ); // 2

显然，显示绑定的优先级更高
new绑定 VS 隐式绑定function foo(something) &#123;    this.a = something;&#125;var obj1 = &#123;    foo: foo&#125;;var obj2 = &#123;&#125;;obj1.foo( 2 );console.log( obj1.a ); // 2obj1.foo.call( obj2, 3 );console.log( obj2.a ); // 3var bar = new obj1.foo( 4 );console.log( obj1.a ); // 2console.log( bar.a ); // 4

可以看到，new绑定的优先级&gt;隐式绑定
new绑定 VS 显式绑定因为new和apply、call无法一起使用，但硬绑定也是显式绑定的一种，可以替换测试
function foo(something) &#123;    this.a = something;&#125;var obj1 = &#123;&#125;;var bar = foo.bind( obj1 );bar( 2 );console.log( obj1.a ); // 2var baz = new bar( 3 );console.log( obj1.a ); // 2console.log( baz.a ); // 3

bar被绑定到obj1上，但是new bar(3) 并没有像我们预计的那样把obj1.a修改为3。但是，new修改了绑定调用bar()中的this
我们可认为new绑定优先级&gt;显式绑定
综上，new绑定优先级 &gt; 显示绑定优先级 &gt; 隐式绑定优先级 &gt; 默认绑定优先级
相关链接
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>如何判断一个元素是否在可视区域中？</title>
    <url>/2023/11/12/JavaScript-visible/</url>
    <content><![CDATA[ 
一、用途可视区域即我们浏览网页的设备肉眼可见的区域，如下图
 
在日常开发中，我们经常需要判断目标元素是否在视窗之内或者和视窗的距离小于一个值（例如 100 px），从而实现一些常用的功能，例如：

图片的懒加载
列表的无限滚动
计算广告元素的曝光情况
可点击链接的预加载

二、实现方式判断一个元素是否在可视区域，我们常用的有三种办法：

offsetTop、scrollTop

getBoundingClientRect 

Intersection Observer


offsetTop、scrollTopoffsetTop，元素的上外边框至包含元素的上内边框之间的像素距离，其他offset属性如下图所示：
 
下面再来了解下clientWidth、clientHeight：

clientWidth：元素内容区宽度加上左右内边距宽度，即clientWidth = content + padding
clientHeight：元素内容区高度加上上下内边距高度，即clientHeight = content + padding

这里可以看到client元素都不包括外边距
最后，关于scroll系列的属性如下：

scrollWidth 和 scrollHeight 主要用于确定元素内容的实际大小

scrollLeft 和 scrollTop 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置


垂直滚动 scrollTop &gt; 0
水平滚动 scrollLeft &gt; 0


将元素的 scrollLeft 和 scrollTop 设置为 0，可以重置元素的滚动位置


注意
上述属性都是只读的，每次访问都要重新开始

下面再看看如何实现判断：
公式如下：
el.offsetTop - document.documentElement.scrollTop &lt;= viewPortHeight
代码实现：
function isInViewPortOfOne (el) &#123;    // viewPortHeight 兼容所有浏览器写法    const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight     const offsetTop = el.offsetTop    const scrollTop = document.documentElement.scrollTop    const top = offsetTop - scrollTop    return top &lt;= viewPortHeight&#125;

getBoundingClientRect返回值是一个 DOMRect对象，拥有left, top, right, bottom, x, y, width, 和 height属性
const target = document.querySelector(&#x27;.target&#x27;);const clientRect = target.getBoundingClientRect();console.log(clientRect);// &#123;//   bottom: 556.21875,//   height: 393.59375,//   left: 333,//   right: 1017,//   top: 162.625,//   width: 684// &#125;

属性对应的关系图如下所示：
 
当页面发生滚动的时候，top与left属性值都会随之改变
如果一个元素在视窗之内的话，那么它一定满足下面四个条件：

top 大于等于 0
left 大于等于 0
bottom 小于等于视窗高度
right 小于等于视窗宽度

实现代码如下：
function isInViewPort(element) &#123;  const viewWidth = window.innerWidth || document.documentElement.clientWidth;  const viewHeight = window.innerHeight || document.documentElement.clientHeight;  const &#123;    top,    right,    bottom,    left,  &#125; = element.getBoundingClientRect();  return (    top &gt;= 0 &amp;&amp;    left &gt;= 0 &amp;&amp;    right &lt;= viewWidth &amp;&amp;    bottom &lt;= viewHeight  );&#125;



Intersection ObserverIntersection Observer 即重叠观察者，从这个命名就可以看出它用于判断两个元素是否重叠，因为不用进行事件的监听，性能方面相比getBoundingClientRect 会好很多
使用步骤主要分为两步：创建观察者和传入被观察者
创建观察者const options = &#123;  // 表示重叠面积占被观察者的比例，从 0 - 1 取值，  // 1 表示完全被包含  threshold: 1.0,   root:document.querySelector(&#x27;#scrollArea&#x27;) // 必须是目标元素的父级元素&#125;;const callback = (entries, observer) =&gt; &#123; ....&#125;const observer = new IntersectionObserver(callback, options);

通过new IntersectionObserver创建了观察者 observer，传入的参数 callback 在重叠比例超过 threshold 时会被执行&#96;
关于callback回调函数常用属性如下：
// 上段代码中被省略的 callbackconst callback = function(entries, observer) &#123;     entries.forEach(entry =&gt; &#123;        entry.time;               // 触发的时间        entry.rootBounds;         // 根元素的位置矩形，这种情况下为视窗位置        entry.boundingClientRect; // 被观察者的位置举行        entry.intersectionRect;   // 重叠区域的位置矩形        entry.intersectionRatio;  // 重叠区域占被观察者面积的比例（被观察者不是矩形时也按照矩形计算）        entry.target;             // 被观察者    &#125;);&#125;;

传入被观察者通过 observer.observe(target) 这一行代码即可简单的注册被观察者
const target = document.querySelector(&#x27;.target&#x27;);observer.observe(target);



三、案例分析实现：创建了一个十万个节点的长列表，当节点滚入到视窗中时，背景就会从红色变为黄色
Html结构如下：
&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;

css样式如下：
.container &#123;    display: flex;    flex-wrap: wrap;&#125;.target &#123;    margin: 5px;    width: 20px;    height: 20px;    background: red;&#125;

往container插入1000个元素
const $container = $(&quot;.container&quot;);// 插入 100000 个 &lt;div class=&quot;target&quot;&gt;&lt;/div&gt;function createTargets() &#123;  const htmlString = new Array(100000)    .fill(&#x27;&lt;div class=&quot;target&quot;&gt;&lt;/div&gt;&#x27;)    .join(&quot;&quot;);  $container.html(htmlString);&#125;

这里，首先使用getBoundingClientRect 方法进行判断元素是否在可视区域
function isInViewPort(element) &#123;    const viewWidth = window.innerWidth || document.documentElement.clientWidth;    const viewHeight =          window.innerHeight || document.documentElement.clientHeight;    const &#123; top, right, bottom, left &#125; = element.getBoundingClientRect();    return top &gt;= 0 &amp;&amp; left &gt;= 0 &amp;&amp; right &lt;= viewWidth &amp;&amp; bottom &lt;= viewHeight;&#125;

然后开始监听scroll事件，判断页面上哪些元素在可视区域中，如果在可视区域中则将背景颜色设置为yellow
$(window).on(&quot;scroll&quot;, () =&gt; &#123;    console.log(&quot;scroll !&quot;);    $targets.each((index, element) =&gt; &#123;        if (isInViewPort(element)) &#123;            $(element).css(&quot;background-color&quot;, &quot;yellow&quot;);        &#125;    &#125;);&#125;);

通过上述方式，可以看到可视区域颜色会变成黄色了，但是可以明显看到有卡顿的现象，原因在于我们绑定了scroll事件，scroll事件伴随了大量的计算，会造成资源方面的浪费
下面通过Intersection Observer的形式同样实现相同的功能
首先创建一个观察者
const observer = new IntersectionObserver(getYellow, &#123; threshold: 1.0 &#125;);

getYellow回调函数实现对背景颜色改变，如下：
function getYellow(entries, observer) &#123;    entries.forEach(entry =&gt; &#123;        $(entry.target).css(&quot;background-color&quot;, &quot;yellow&quot;);    &#125;);&#125;

最后传入观察者，即.target元素
$targets.each((index, element) =&gt; &#123;    observer.observe(element);&#125;);

可以看到功能同样完成，并且页面不会出现卡顿的情况
参考文献
https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect
https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序的实现原理</title>
    <url>/2024/05/19/applet-WebView-jscore/</url>
    <content><![CDATA[   
一、背景  网页开发，渲染线程和脚本是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应的原因，本质就是我们常说的 JS 是单线程的
  而在小程序中，选择了 Hybrid 的渲染方式，将视图层和逻辑层是分开的，双线程同时运行，视图层的界面使用 WebView 进行渲染，逻辑层运行在 JSCore 中
   

渲染层：界面渲染相关的任务全都在 WebView 线程里执行。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程
逻辑层：采用 JsCore 线程运行 JS 脚本，在这个环境下执行的都是有关小程序业务逻辑的代码

二、通信  小程序在渲染层，宿主环境会把wxml转化成对应的JS对象
  在逻辑层发生数据变更的时候，通过宿主环境提供的setData方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的视图
   
  当视图存在交互的时候，例如用户点击你界面上某个按钮，这类反馈应该通知给开发者的逻辑层，需要将对应的处理状态呈现给用户
  对于事件的分发处理，微信进行了特殊的处理，将所有的事件拦截后，丢到逻辑层交给JavaScript进行处理
   
  由于小程序是基于双线程的，也就是任何在视图层和逻辑层之间的数据传递都是线程间的通信，会有一定的延时，因此在小程序中，页面更新成了异步操作
  异步会使得各部分的运行时序变得复杂一些，比如在渲染首屏的时候，逻辑层与渲染层会同时开始初始化工作，但是渲染层需要有逻辑层的数据才能把界面渲染出来
  如果渲染层初始化工作较快完成，就要等逻辑层的指令才能进行下一步工作
  因此逻辑层与渲染层需要有一定的机制保证时序正确，在每个小程序页面的生命周期中，存在着若干次页面数据通信
   
三、运行机制  小程序启动运行两种情况：

冷启动（重新开始）：用户首次打开或者小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即为冷启动
热启动：用户已经打开过小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需要将后台态的小程序切换到前台，这个过程就是热启动

需要注意：
 1.小程序没有重启的概念 2.当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后会被微信主动销毁 3.短时间内收到系统两次以上内存警告，也会对小程序进行销毁，这也就为什么一旦页面内存溢出，页面会奔溃的本质原因了

   
  开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也在发布之后 24 小时之内下发新版本信息到用户
  每次冷启动时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上
参考文献
https://developers.weixin.qq.com/community/develop/article/doc/0008a4c4f28f30fe3eb863b2750813
https://juejin.cn/post/6976805521407868958#heading-5
https://juejin.cn/post/6844903805675388942
https://juejin.cn/post/6844903999863259144#heading-1

]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序的理解</title>
    <url>/2024/03/19/applet-applet/</url>
    <content><![CDATA[ 
一、是什么2017年，微信正式推出了小程序，允许外部开发者在微信内部运行自己的代码，开展业务
截至目前，小程序已经成为国内前端的一个重要业务，跟 Web 和手机 App 有着同等的重要性
 
小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用
也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载
注意的是，除了微信小程序，还有百度小程序、微信小程序、支付宝小程序、抖音小程序，都是每个平台自己开发的，都是有针对性平台的应用程序
二、背景⼩程序并⾮凭空冒出来的⼀个概念，当微信中的 WebView 逐渐成为移动 Web的⼀个重要⼊⼝时，微信就有相关的 JS-SDK
JS-SDK 解决了移动⽹⻚能⼒不⾜的问题，通过暴露微信的接⼝使得 Web 开发者能够拥有更多的能⼒，然⽽在更多的能⼒之外，JS-SDK的模式并没有解决使⽤移动⽹⻚遇到的体验不良的问题
因此需要设计⼀个⽐较好的系统，使得所有开发者在微信中都能获得⽐较好的体验：

快速的加载
更强⼤的能⼒
原⽣的体验
易⽤且安全的微信数据开放
⾼效和简单的开发

这些是JS-SDK做不到的，需要设计一个全新的小程序系统
对于小程序的开发，提供一个简单、高效的应用开发框架和丰富的组件及API，帮助开发者开发出具有原生体验的服务
其中相比H5，小程序与其的区别有如下：

运⾏环境：⼩程序基于浏览器内核重构的内置解析器
系统权限：⼩程序能获得更多的系统权限，如⽹络通信状态、数据缓存能⼒等
渲染机制：⼩程序的逻辑层和渲染层是分开的

小程序可以视为只能用微信打开和浏览的H5，小程序和网页的技术模型是一样的，用到的 JavaScript 语言和 CSS 样式也是一样的，只是网页的 HTML 标签被稍微修改成了 WXML 标签
因此可以说，小程序页面本质上就是网页
其中关于微信小程序的实现原理，我们在后面的文章讲到
三、优缺点优点：

随搜随用，用完即走：使得小程序可以代替许多APP，或是做APP的整体嫁接，或是作为阉割版功能的承载体
流量大，易接受：小程序借助自身平台更加容易引入更多的流量
安全
开发门槛低
降低兼容性限制

缺点：

用户留存：及相关数据显示，小程序的平均次日留存在13%左右，但是双周留存骤降到仅有1%
体积限制：微信小程序只有2M的大小，这样导致无法开发大型一些的小程序
受控微信：比起APP，尤其是安卓版的高自由度，小程序要面对很多来自微信的限制，从功能接口，甚至到类别内容，都要接受微信的管控

参考文献
https://developers.weixin.qq.com/miniprogram/dev/framework/
https://www.zhihu.com/question/263816362

]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序的生命周期</title>
    <url>/2024/03/20/applet-lifecycle/</url>
    <content><![CDATA[ 
一、是什么跟vue、react框架一样，微信小程序框架也存在生命周期，实质也是一堆会在特定时期执行的函数
小程序中，生命周期主要分成了三部分：

应用的生命周期
页面的生命周期
组件的生命周期

应用的生命周期小程序的生命周期函数是在app.js里面调用的，通过App(Object)函数用来注册一个小程序，指定其小程序的生命周期回调
页面的生命周期页面生命周期函数就是当你每进入&#x2F;切换到一个新的页面的时候，就会调用的生命周期函数，同样通过App(Object)函数用来注册一个页面
组件的生命周期组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发，通过Component(Object)进行注册组件
二、有哪些应用的生命周期


生命周期
说明



onLaunch
小程序初始化完成时触发，全局只触发一次


onShow
小程序启动，或从后台进入前台显示时触发


onHide
小程序从前台进入后台时触发


onError
小程序发生脚本错误或 API 调用报错时触发


onPageNotFound
小程序要打开的页面不存在时触发


onUnhandledRejection()
小程序有未处理的 Promise 拒绝时触发


onThemeChange
系统切换主题时触发


页面的生命周期


生命周期
说明
作用



onLoad
生命周期回调—监听页面加载
发送请求获取数据


onShow
生命周期回调—监听页面显示
请求数据


onReady
生命周期回调—监听页面初次渲染完成
获取页面元素（少用）


onHide
生命周期回调—监听页面隐藏
终止任务，如定时器或者播放音乐


onUnload
生命周期回调—监听页面卸载
终止任务


组件的生命周期


生命周期
说明



created
生命周期回调—监听页面加载


attached
生命周期回调—监听页面显示


ready
生命周期回调—监听页面初次渲染完成


moved
生命周期回调—监听页面隐藏


detached
生命周期回调—监听页面卸载


error
每当组件方法抛出错误时执行


注意的是：

组件实例刚刚被创建好时， created 生命周期被触发，此时，组件数据 this.data 就是在 Component  构造器中定义的数据 data ， 此时不能调用 setData
在组件完全初始化完毕、进入页面节点树后， attached 生命周期被触发。此时， this.data 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行
在组件离开页面节点树后， detached 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则  detached 会被触发

还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理，这样的生命周期称为“组件所在页面的生命周期”，在 pageLifetimes 定义段中定义，如下：



生命周期
说明



show
组件所在的页面被展示时执行


hide
组件所在的页面被隐藏时执行


代码如下：
Component(&#123;  pageLifetimes: &#123;    show: function() &#123;      // 页面被展示    &#125;,    hide: function() &#123;      // 页面被隐藏    &#125;,  &#125;&#125;)






三、执行过程应⽤的⽣命周期执行过程：
⽤户⾸次打开⼩程序，触发 onLaunch（全局只触发⼀次）

⼩程序初始化完成后，触发onShow⽅法，监听⼩程序显示

⼩程序从前台进⼊后台，触发 onHide⽅法

⼩程序从后台进⼊前台显示，触发 onShow⽅法

⼩程序后台运⾏⼀定时间，或系统资源占⽤过⾼，会被销毁


⻚⾯⽣命周期的执行过程：
⼩程序注册完成后，加载⻚⾯，触发onLoad⽅法
⻚⾯载⼊后触发onShow⽅法，显示⻚⾯
⾸次显示⻚⾯，会触发onReady⽅法，渲染⻚⾯元素和样式，⼀个⻚⾯只会调⽤⼀次
当⼩程序后台运⾏或跳转到其他⻚⾯时，触发onHide⽅法
当⼩程序有后台进⼊到前台运⾏或重新进⼊⻚⾯时，触发onShow⽅法
当使⽤重定向⽅法 wx.redirectTo() 或关闭当前⻚返回上⼀⻚wx.navigateBack()，触发onUnload

当存在也应用生命周期和页面周期的时候，相关的执行顺序如下：

打开小程序：(App)onLaunch –&gt; (App)onShow –&gt; (Pages)onLoad –&gt; (Pages)onShow –&gt; (pages)onRead

进入下一个页面：(Pages)onHide –&gt; (Next)onLoad –&gt; (Next)onShow –&gt; (Next)onReady

返回上一个页面：(curr)onUnload –&gt; (pre)onShow

离开小程序：(App)onHide

再次进入：小程序未销毁 –&gt; (App)onShow(执行上面的顺序），小程序被销毁，（App)onLaunch重新开始执行.


参考文献
https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onLaunch-Object-object
https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onLoad-Object-query
https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onLaunch-Object-object

]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序的登录流程</title>
    <url>/2024/03/21/applet-login/</url>
    <content><![CDATA[ 
一、背景传统的web开发实现登陆功能，一般的做法是输入账号密码、或者输入手机号及短信验证码进行登录
服务端校验用户信息通过之后，下发一个代表登录态的 token 给客户端，以便进行后续的交互,每当token过期，用户都需要重新登录
而在微信小程序中，可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系，从而实现登陆功能
实现小程序用户体系主要涉及到openid和code的概念：

调用wx.login()方法会生成code，将code作为参数传递给微信服务器指定接口，就可以获取用户的openid

对于每个小程序，微信都会将用户的微信ID映射出一个小程序 openid，作为这个用户在这个小程序的唯一标识
二、流程微信小程序登陆具体实现的逻辑如下图所示：
 

通过  wx.login()  获取到用户的code判断用户是否授权读取用户信息，调用wx.getUserInfo 读取用户数据
由于小程序后台授权域名无法授权微信的域名，所以需要自身后端调用微信服务器获取用户信息
通过 wx.request() 方法请求业务方服务器，后端把 appid , appsecret  和 code 一起发送到微信服务器。 appid 和 appsecret 都是微信提供的，可以在管理员后台找到
微信服务器返回了 openid 及本次登录的会话密钥 session_key
后端从数据库中查找 openid ，如果没有查到记录，说明该用户没有注册，如果有记录，则继续往下走
session_key 是对用户数据进行加密签名的密钥。为了自身应用安全，session_key 不应该在网络上传输
然后生成 session并返回给小程序
小程序把 session 存到  storage 里面
下次请求时，先从 storage 里面读取，然后带给服务端
服务端对比 session 对应的记录，然后校验有效期

更加详细的功能图如下所示：
 
三、扩展实际业务中，我们还需要登录态是否过期，通常的做法是在登录态（临时令牌）中保存有效期数据，该有效期数据应该在服务端校验登录态时和约定的时间（如服务端本地的系统时间或时间服务器上的标准时间）做对比
这种方法需要将本地存储的登录态发送到小程序的服务端，服务端判断为无效登录态时再返回需重新执行登录过程的消息给小程
另一种方式可以通过调用wx.checkSession检查微信登陆态是否过期：

如果过期，则发起完整的登录流程
如果不过期，则继续使用本地保存的自定义登录态

这种方式的好处是不需要小程序服务端来参与校验，而是在小程序端调用AP，流程如下所示：
 
参考文献
https://segmentfault.com/a/1190000016750340
https://juejin.cn/post/6955754095860776973
https://www.cnblogs.com/zwh0910/p/13977278.html

]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>提高微信小程序的应用速度的手段有哪些？</title>
    <url>/2024/03/30/applet-optimization/</url>
    <content><![CDATA[ 
一、是什么小程序启动会常常遇到如下图场景：
 
这是因为，小程序首次启动前，微信会在小程序启动前为小程序准备好通用的运行环境，如运行中的线程和一些基础库的初始化
然后才开始进入启动状态，展示一个固定的启动界面，界面内包含小程序的图标、名称和加载提示图标。此时，微信会在背后完成几项工作：

下载小程序代码包
加载小程序代码包
初始化小程序首页

下载到的小程序代码包不是小程序的源代码，而是编译、压缩、打包之后的代码包
整体流程如下图：
 
二、手段围绕上图小程序的启动流程， 我们可以从加载、渲染两个纬度进行切入：
加载提升体验最直接的方法是控制小程序包的大小，常见手段有如下：

代码包的体积压缩可以通过勾选开发者工具中“上传代码时，压缩代码”选项

及时清理无用的代码和资源文件

减少资源包中的图片等资源的数量和大小（理论上除了小icon，其他图片资源从网络下载），图片资源压缩率有限


并且可以采取分包加载的操作，将用户访问率高的页面放在主包里，将访问率低的页面放入子包里，按需加载
当用户点击到子包的目录时，还是有一个代码包下载的过程，这会感觉到明显的卡顿，所以子包也不建议拆的太大，当然我们可以采用子包预加载技术，并不需要等到用户点击到子包页面后在下载子包
 
渲染关于微信小程序首屏渲染优化的手段如下：

请求可以在页面onLoad就加载，不需要等页面ready后在异步请求数据
尽量减少不必要的https请求，可使用 getStorageSync() 及 setStorageSync() 方法将数据存储在本地
可以在前置页面将一些有用的字段带到当前页，进行首次渲染（列表页的某些数据–&gt; 详情页），没有数据的模块可以进行骨架屏的占位

在微信小程序中，提高页面的多次渲染效率主要在于正确使用setData：

不要过于频繁调用setData，应考虑将多次setData合并成一次setData调用
数据通信的性能与数据量正相关，因而如果有一些数据字段不在界面中展示且数据结构比较复杂或包含长字符串，则不应使用setData来设置这些数据
与界面渲染无关的数据最好不要设置在data中，可以考虑设置在page对象的其他字段下

除此之外，对于一些独立的模块我们尽可能抽离出来，这是因为自定义组件的更新并不会影响页面上其他元素的更新
各个组件也将具有各自独立的逻辑空间。每个组件都分别拥有自己的独立的数据、setData调用
三、总结小程序启动加载性能：

控制代码包的大小
分包加载
首屏体验（预请求，利用缓存，避免白屏，及时反馈

小程序渲染性能：

避免不当的使用setData
使用自定义组件

参考文献
https://juejin.cn/post/6969779451177484296
https://segmentfault.com/a/1190000008925450
https://juejin.cn/post/6844903638226173965
https://juejin.cn/post/6844903726939897869

]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序中路由跳转的方式有哪些？区别</title>
    <url>/2024/03/22/applet-navigate/</url>
    <content><![CDATA[ 
一、是什么微信小程序拥有web网页和Application共同的特征，我们的页面都不是孤立存在的，而是通过和其他页面进行交互，来共同完成系统的功能
在微信小程序中，每个页面可以看成是一个 pageModel，pageModel 全部以栈的形式进行管理
二、有哪些常见的微信小程序页面跳转方式有如下：

wx.navigateTo(Object)
wx.redirectTo(Object)
wx.switchTab(Object)
wx.navigateBack(Object)
wx.reLaunch(Object)

wx.navigateTo(Object)wx.navigateTo()用于保留当前页面、跳转到应用内的某个页面，使用 wx.navigateBack可以返回到原页面
对于页面不是特别多的小程序，通常推荐使用 wx.navigateTo进行跳转， 以便返回原页面，以提高加载速度。当页面特别多时，则不推荐使用
参数表如下所示：
 
流程图如下：
 
wx.redirectTo(Object)重定向，当页面过多时，被保留页面会挤占微信分配给小程序的内存，或是达到微信所限制的 10 层页面栈的情况下，我们应该考虑选择 wx.redirectTo
wx.redirectTo()用于关闭当前页面，跳转到应用内的某个页面
这样的跳转，可以避免跳转前页面占据运行内存，但返回时页面需要重新加载，增加了返回页面的显示时间
参数表如下所示：
 
流程图如下所示：
 
wx.switchTab(Object)跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面
参数表如下所示：
 
wx.navigateBack(Object)wx.navigateBack() 用于关闭当前页面，并返回上一页面或多级页面，开发者可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层则设置对象的delta属性即可
参数表如下：
 
wx.reLaunch(Object)关闭所有页面，打开到应用内的某个页面，返回的时候跳到首页
流程图如下所示：
 
参数表如下所示：
 
三、总结关于上述五种跳转方式，做下总结：

navigateTo 保留当前页面，跳转到应用内的某个页面，使用 wx.navigateBack 可以返回到原页
redirectTo 关闭当前页面，跳转到应用内的某个页面
switchTab 跳转到 tabBar 页面，同时关闭其他非 tabBar 页面
navigateBack 返回上一页面
reLanch 关闭所有页面，打开到应用内的某个页面

其中关于它们的页面栈的关系如下：

avigateTo 新页面入栈

redirectTo 当前页面出栈，新页面入栈

navigateBack 页面不断出栈，直到目标返回页，新页面入栈

switchTab 页面全部出栈，只留下新的 Tab 页面

reLanch 页面全部出栈，只留下新的页面


参考文献
https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.html

]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序的发布流程？</title>
    <url>/2024/04/10/applet-publish/</url>
    <content><![CDATA[ 
一、背景在中大型的公司里，人员的分工非常仔细，一般会有不同岗位角色的员工同时参与同一个小程序项目。为此，小程序平台设计了不同的权限管理使得项目管理者可以更加高效管理整个团队的协同工作
 
以往我们在开发完网页之后，需要把网页的代码和资源放在服务器上，让用户通过互联网来访问
在小程序的平台里，开发者完成开发之后，需要在开发者工具提交小程序的代码包，然后在小程序后台发布小程序
 
二、流程关于发布的流程，主要分成了三个部分：

上传代码
提交审核
发布版本

上传代码在开发者工具中，可以点击代码上传功能：
 
然后就可以填写版本信息：
 
然后点击上传，编译器则会提示上传代码成功
提交审核代码上传完毕，就可以登陆微信公众号的官网首页，点击【开发管理】，查看应用详情：
 
提交审核过程需要填写审核信息，如下图：
 
提交审核成功之后如下图：
 
发布版本当审核通过之后，即可提交发布
 
发布成功之后则如下：
 
三、扩展上述是最简单的小程序代码发布的流程，通常的流程如下：

代码管理服务器上新建分支
开发测试新需求
测试完成后，将本地分支合并到 master 分支
拉取 master 分支最新代码，执行 build 命令生成小程序可执行文件
开发者工具点击“上传”
提审
发布

但是面对多人协调开发的时候，有可能出现已经上线的代码还没合并到master的情况
因此可以考虑自动化构建部署，就是将从开发到部署的一系列流程变成自动化，衔接连贯，在构建失败时能够告知开发者，构建成功后能够告知测试和实施人员，可参考如下流程图：
 
参考文献
https://juejin.cn/post/6994414162700927012
https://www.leapcloud.cn/website/docs/doc_config/xiaochengxu/xiaochengxu.html

]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序的支付流程？</title>
    <url>/2024/04/19/applet-requestPayment/</url>
    <content><![CDATA[ 
一、前言微信小程序为电商类小程序，提供了非常完善、优秀、安全的支付功能
在小程序内可调用微信的API完成支付功能，方便、快捷
场景如下图所示：
 
 

用户通过分享或扫描二维码进入商户小程序，用户选择购买，完成选购流程
调起微信支付控件，用户开始输入支付密码
密码验证通过，支付成功。商户后台得到支付成功的通知
返回商户小程序，显示购买成功
微信支付公众号下发支付凭证

二、流程以电商小程序为例
支付流程图如下所示：
 
具体的做法：

打开某小程序，点击直接下单
wx.login获取用户临时登录凭证code，发送到后端服务器换取openId
在下单时，小程序需要将购买的商品Id，商品数量，以及用户的openId传送到服务器
服务器在接收到商品Id、商品数量、openId后，生成服务期订单数据，同时经过一定的签名算法，向微信支付发送请求，获取预付单信息(prepay_id)，同时将获取的数据再次进行相应规则的签名，向小程序端响应必要的信息
小程序端在获取对应的参数后，调用wx.requestPayment()发起微信支付，唤醒支付工作台，进行支付
接下来的一些列操作都是由用户来操作的包括了微信支付密码，指纹等验证，确认支付之后执行鉴权调起支付
鉴权调起支付：在微信后台进行鉴权，微信后台直接返回给前端支付的结果，前端收到返回数据后对支付结果进行展示
推送支付结果：微信后台在给前端返回支付的结果后，也会向后台也返回一个支付结果，后台通过这个支付结果来更新订单的状态

其中后端响应数据必要的信息则是wx.requestPayment方法所需要的参数，大致如下：
wx.requestPayment(&#123;  // 时间戳  timeStamp: &#x27;&#x27;,  // 随机字符串  nonceStr: &#x27;&#x27;,  // 统一下单接口返回的 prepay_id 参数值  package: &#x27;&#x27;,  // 签名类型  signType: &#x27;&#x27;,  // 签名  paySign: &#x27;&#x27;,  // 调用成功回调  success () &#123;&#125;,  // 失败回调  fail () &#123;&#125;,  // 接口调用结束回调  complete () &#123;&#125;&#125;)

参数表如下所示：

三、结束小程序支付和以往的网页、APP微信支付大同小异，可以说小程序的支付变得更加简洁，不需要设置支付目录、域名授权等操作
参考文献
https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_8_0.shtml
https://juejin.cn/post/6844903895970349064

]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据量的 Excel 导出解决方案有哪些？</title>
    <url>/2024/09/10/performance-excel-export/</url>
    <content><![CDATA[一、问题背景在实际业务中，经常需要导出大量数据到 Excel 文件，这可能会遇到以下问题：

浏览器内存占用过大
导出过程页面卡顿
请求超时
文件过大下载慢

二、前端导出方案1. 使用 XLSX.js1.1 基础导出import * as XLSX from &#x27;xlsx&#x27;;class ExcelExport &#123;  constructor() &#123;    this.workbook = XLSX.utils.book_new();  &#125;    // 创建工作表  createSheet(data, sheetName = &#x27;Sheet1&#x27;) &#123;    const worksheet = XLSX.utils.json_to_sheet(data);    XLSX.utils.book_append_sheet(this.workbook, worksheet, sheetName);  &#125;    // 导出文件  exportFile(fileName = &#x27;export.xlsx&#x27;) &#123;    XLSX.writeFile(this.workbook, fileName);  &#125;&#125;// 使用示例const exporter = new ExcelExport();exporter.createSheet([  &#123; name: &#x27;John&#x27;, age: 30 &#125;,  &#123; name: &#x27;Mary&#x27;, age: 25 &#125;]);exporter.exportFile();

1.2 分片处理class ChunkExport &#123;  constructor(chunkSize = 1000) &#123;    this.chunkSize = chunkSize;    this.workbook = XLSX.utils.book_new();  &#125;    // 分片处理数据  async processDataInChunks(data) &#123;    const chunks = this.splitIntoChunks(data);    const worksheet = XLSX.utils.json_to_sheet([]);        for (let i = 0; i &lt; chunks.length; i++) &#123;      await this.processChunk(worksheet, chunks[i], i);    &#125;        XLSX.utils.book_append_sheet(this.workbook, worksheet, &#x27;Sheet1&#x27;);  &#125;    // 分割数据  splitIntoChunks(data) &#123;    const chunks = [];    for (let i = 0; i &lt; data.length; i += this.chunkSize) &#123;      chunks.push(data.slice(i, i + this.chunkSize));    &#125;    return chunks;  &#125;    // 处理单个分片  async processChunk(worksheet, chunk, index) &#123;    return new Promise(resolve =&gt; &#123;      setTimeout(() =&gt; &#123;        const rows = XLSX.utils.json_to_sheet(chunk);        if (index === 0) &#123;          worksheet[&#x27;!ref&#x27;] = rows[&#x27;!ref&#x27;];          worksheet[&#x27;!cols&#x27;] = rows[&#x27;!cols&#x27;];          Object.assign(worksheet, rows);        &#125; else &#123;          this.appendRows(worksheet, rows, index * this.chunkSize);        &#125;        resolve();      &#125;, 0);    &#125;);  &#125;    // 追加行数据  appendRows(worksheet, rows, startRow) &#123;    Object.keys(rows).forEach(cell =&gt; &#123;      if (cell[0] === &#x27;!&#x27;) return;      const newCell = cell.replace(/\d+/, match =&gt; +match + startRow);      worksheet[newCell] = rows[cell];    &#125;);  &#125;    // 导出文件  async export(data, fileName = &#x27;export.xlsx&#x27;) &#123;    await this.processDataInChunks(data);    XLSX.writeFile(this.workbook, fileName);  &#125;&#125;// 使用示例const exporter = new ChunkExport(1000);const largeData = Array.from(&#123; length: 100000 &#125;, (_, i) =&gt; (&#123;  id: i,  name: `User $&#123;i&#125;`,  date: new Date().toISOString()&#125;));exporter.export(largeData, &#x27;large-export.xlsx&#x27;);

2. Web Worker 处理2.1 主线程代码class WorkerExport &#123;  constructor() &#123;    this.worker = new Worker(&#x27;excel-worker.js&#x27;);    this.setupWorker();  &#125;    setupWorker() &#123;    this.worker.onmessage = (event) =&gt; &#123;      const &#123; type, data &#125; = event.data;            switch (type) &#123;        case &#x27;progress&#x27;:          this.updateProgress(data);          break;        case &#x27;complete&#x27;:          this.downloadFile(data);          break;        case &#x27;error&#x27;:          console.error(&#x27;Export failed:&#x27;, data);          break;      &#125;    &#125;;  &#125;    export(data, options = &#123;&#125;) &#123;    this.worker.postMessage(&#123;      type: &#x27;start&#x27;,      data,      options    &#125;);  &#125;    updateProgress(percent) &#123;    // 更新进度条    console.log(`Export progress: $&#123;percent&#125;%`);  &#125;    downloadFile(blob) &#123;    const url = URL.createObjectURL(blob);    const link = document.createElement(&#x27;a&#x27;);    link.href = url;    link.download = &#x27;export.xlsx&#x27;;    link.click();    URL.revokeObjectURL(url);  &#125;    terminate() &#123;    this.worker.terminate();  &#125;&#125;

2.2 Worker 线程代码// excel-worker.jsimportScripts(&#x27;https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js&#x27;);class ExcelWorker &#123;  constructor() &#123;    this.setupEventListeners();  &#125;    setupEventListeners() &#123;    self.onmessage = (event) =&gt; &#123;      const &#123; type, data, options &#125; = event.data;            if (type === &#x27;start&#x27;) &#123;        this.processExport(data, options);      &#125;    &#125;;  &#125;    async processExport(data, options) &#123;    try &#123;      const workbook = XLSX.utils.book_new();      const totalChunks = Math.ceil(data.length / 1000);            for (let i = 0; i &lt; totalChunks; i++) &#123;        const chunk = data.slice(i * 1000, (i + 1) * 1000);        await this.processChunk(workbook, chunk, i === 0);                // 报告进度        self.postMessage(&#123;          type: &#x27;progress&#x27;,          data: Math.round((i + 1) / totalChunks * 100)        &#125;);      &#125;            // 生成文件      const wbout = XLSX.write(workbook, &#123;        bookType: &#x27;xlsx&#x27;,        type: &#x27;array&#x27;      &#125;);            // 返回结果      self.postMessage(&#123;        type: &#x27;complete&#x27;,        data: new Blob([wbout], &#123; type: &#x27;application/octet-stream&#x27; &#125;)      &#125;);          &#125; catch (error) &#123;      self.postMessage(&#123;        type: &#x27;error&#x27;,        data: error.message      &#125;);    &#125;  &#125;    async processChunk(workbook, chunk, isFirst) &#123;    return new Promise(resolve =&gt; &#123;      setTimeout(() =&gt; &#123;        if (isFirst) &#123;          const worksheet = XLSX.utils.json_to_sheet(chunk);          XLSX.utils.book_append_sheet(workbook, worksheet, &#x27;Sheet1&#x27;);        &#125; else &#123;          XLSX.utils.sheet_add_json(            workbook.Sheets[&#x27;Sheet1&#x27;],            chunk,            &#123; origin: -1 &#125;          );        &#125;        resolve();      &#125;, 0);    &#125;);  &#125;&#125;new ExcelWorker();

三、后端导出方案1. 流式处理// 前端代码async function streamDownload() &#123;  const response = await fetch(&#x27;/api/export/stream&#x27;, &#123;    headers: &#123;      &#x27;Accept&#x27;: &#x27;application/octet-stream&#x27;    &#125;  &#125;);    const reader = response.body.getReader();  const chunks = [];    while (true) &#123;    const &#123; done, value &#125; = await reader.read();    if (done) break;    chunks.push(value);  &#125;    const blob = new Blob(chunks, &#123; type: &#x27;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&#x27; &#125;);  const url = URL.createObjectURL(blob);  const link = document.createElement(&#x27;a&#x27;);  link.href = url;  link.download = &#x27;export.xlsx&#x27;;  link.click();  URL.revokeObjectURL(url);&#125;

// 后端代码 (Node.js)const Excel = require(&#x27;exceljs&#x27;);const stream = require(&#x27;stream&#x27;);async function streamExport(req, res) &#123;  const workbook = new Excel.stream.xlsx.WorkbookWriter(&#123;    stream: res,    useStyles: true  &#125;);    const worksheet = workbook.addWorksheet(&#x27;Sheet1&#x27;);    // 设置表头  worksheet.columns = [    &#123; header: &#x27;ID&#x27;, key: &#x27;id&#x27; &#125;,    &#123; header: &#x27;Name&#x27;, key: &#x27;name&#x27; &#125;,    &#123; header: &#x27;Date&#x27;, key: &#x27;date&#x27; &#125;  ];    // 流式查询数据库  const cursor = db.collection(&#x27;data&#x27;).find().cursor();    for (let doc = await cursor.next(); doc != null; doc = await cursor.next()) &#123;    worksheet.addRow(doc).commit();  &#125;    await worksheet.commit();  await workbook.commit();&#125;

2. 任务队列处理// 前端代码class ExportTask &#123;  async createTask() &#123;    const response = await fetch(&#x27;/api/export/task&#x27;, &#123;      method: &#x27;POST&#x27;,      body: JSON.stringify(&#123; /* 导出参数 */ &#125;)    &#125;);    const &#123; taskId &#125; = await response.json();    return this.pollTaskStatus(taskId);  &#125;    async pollTaskStatus(taskId) &#123;    while (true) &#123;      const response = await fetch(`/api/export/status/$&#123;taskId&#125;`);      const &#123; status, url &#125; = await response.json();            if (status === &#x27;completed&#x27;) &#123;        this.downloadFile(url);        break;      &#125; else if (status === &#x27;failed&#x27;) &#123;        throw new Error(&#x27;Export failed&#x27;);      &#125;            await new Promise(resolve =&gt; setTimeout(resolve, 2000));    &#125;  &#125;    downloadFile(url) &#123;    const link = document.createElement(&#x27;a&#x27;);    link.href = url;    link.download = &#x27;export.xlsx&#x27;;    link.click();  &#125;&#125;

四、最佳实践1. 数据量判断class ExportStrategy &#123;  constructor(threshold = 10000) &#123;    this.threshold = threshold;  &#125;    async export(data) &#123;    if (data.length &lt;= this.threshold) &#123;      // 小数据量：直接前端导出      return this.clientExport(data);    &#125; else if (data.length &lt;= this.threshold * 10) &#123;      // 中等数据量：使用 Web Worker      return this.workerExport(data);    &#125; else &#123;      // 大数据量：使用后端导出      return this.serverExport(data);    &#125;  &#125;&#125;

2. 性能优化class OptimizedExport &#123;  // 预处理数据  preprocessData(data) &#123;    return data.map(item =&gt; &#123;      // 只保留需要的字段      const &#123; id, name, date &#125; = item;      return &#123; id, name, date &#125;;    &#125;);  &#125;    // 分批处理  async batchProcess(data, batchSize = 1000) &#123;    const results = [];    for (let i = 0; i &lt; data.length; i += batchSize) &#123;      const batch = data.slice(i, i + batchSize);      results.push(await this.processBatch(batch));            // 允许其他任务执行      await new Promise(resolve =&gt; setTimeout(resolve, 0));    &#125;    return results;  &#125;    // 内存管理  cleanupMemory() &#123;    if (global.gc) &#123;      global.gc();    &#125;  &#125;&#125;

3. 用户体验class ExportUI &#123;  constructor() &#123;    this.progress = 0;    this.status = &#x27;idle&#x27;;  &#125;    // 更新进度条  updateProgress(percent) &#123;    this.progress = percent;    this.updateUI();  &#125;    // 显示状态  updateStatus(status) &#123;    this.status = status;    this.updateUI();  &#125;    // 更新界面  updateUI() &#123;    const progressBar = document.querySelector(&#x27;.progress-bar&#x27;);    const statusText = document.querySelector(&#x27;.status-text&#x27;);        if (progressBar) &#123;      progressBar.style.width = `$&#123;this.progress&#125;%`;    &#125;        if (statusText) &#123;      statusText.textContent = this.getStatusText();    &#125;  &#125;    // 获取状态文本  getStatusText() &#123;    const statusMap = &#123;      idle: &#x27;准备导出&#x27;,      processing: &#x27;正在导出...&#x27;,      completed: &#x27;导出完成&#x27;,      failed: &#x27;导出失败&#x27;    &#125;;    return statusMap[this.status] || &#x27;&#x27;;  &#125;&#125;

参考文献
SheetJS 文档
ExcelJS 文档
Web Workers API
Stream API

]]></content>
      <categories>
        <category>前端</category>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>Excel</tag>
        <tag>大数据</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能指标有哪些，如何获取和分析？</title>
    <url>/2024/09/12/performance-performance-metrics/</url>
    <content><![CDATA[一、核心性能指标1. 加载性能指标
FCP (First Contentful Paint)


首次内容绘制时间
标记浏览器渲染第一个 DOM 内容的时间点// 方式一：Performance APInew PerformanceObserver((entryList) =&gt; &#123;  for (const entry of entryList.getEntries()) &#123;    console.log(&#x27;FCP:&#x27;, entry.startTime);  &#125;&#125;).observe(&#123; entryTypes: [&#x27;paint&#x27;] &#125;);// 方式二：Web Vitalsimport &#123; getFCP &#125; from &#x27;web-vitals&#x27;;getFCP(console.log);


LCP (Largest Contentful Paint)


最大内容绘制时间
页面主要内容加载完成的时间new PerformanceObserver((entryList) =&gt; &#123;  for (const entry of entryList.getEntries()) &#123;    console.log(&#x27;LCP:&#x27;, entry.startTime);  &#125;&#125;).observe(&#123; entryTypes: [&#x27;largest-contentful-paint&#x27;] &#125;);


TTI (Time to Interactive)


可交互时间
页面完全可交互所需时间import &#123; getTTI &#125; from &#x27;web-vitals&#x27;;getTTI(console.log);

2. 交互性能指标
FID (First Input Delay)


首次输入延迟
用户首次交互的响应时间new PerformanceObserver((entryList) =&gt; &#123;  for (const entry of entryList.getEntries()) &#123;    console.log(&#x27;FID:&#x27;, entry.processingStart - entry.startTime);  &#125;&#125;).observe(&#123; entryTypes: [&#x27;first-input&#x27;] &#125;);


CLS (Cumulative Layout Shift)


累积布局偏移
页面视觉稳定性的度量new PerformanceObserver((entryList) =&gt; &#123;  for (const entry of entryList.getEntries()) &#123;    console.log(&#x27;CLS:&#x27;, entry.value);  &#125;&#125;).observe(&#123; entryTypes: [&#x27;layout-shift&#x27;] &#125;);

二、性能指标采集1. Performance APIclass PerformanceMonitor &#123;  constructor() &#123;    this.metrics = &#123;&#125;;    this.init();  &#125;    init() &#123;    // 页面加载性能    this.getNavigationTiming();    // 资源加载性能    this.getResourceTiming();    // 用户交互性能    this.getUserTiming();  &#125;    // 获取导航加载性能  getNavigationTiming() &#123;    const timing = performance.getEntriesByType(&#x27;navigation&#x27;)[0];    this.metrics.navigation = &#123;      // DNS 解析时间      dns: timing.domainLookupEnd - timing.domainLookupStart,      // TCP 连接时间      tcp: timing.connectEnd - timing.connectStart,      // 首字节时间      ttfb: timing.responseStart - timing.requestStart,      // DOM 解析时间      domParse: timing.domInteractive - timing.responseEnd,      // 页面完全加载时间      loadComplete: timing.loadEventEnd - timing.fetchStart    &#125;;  &#125;    // 获取资源加载性能  getResourceTiming() &#123;    const resources = performance.getEntriesByType(&#x27;resource&#x27;);    this.metrics.resources = resources.map(item =&gt; (&#123;      name: item.name,      type: item.initiatorType,      duration: item.duration,      size: item.transferSize    &#125;));  &#125;    // 获取用户交互性能  getUserTiming() &#123;    // 监听首次输入延迟    new PerformanceObserver((entryList) =&gt; &#123;      const entries = entryList.getEntries();      this.metrics.fid = entries[0].processingStart - entries[0].startTime;    &#125;).observe(&#123; entryTypes: [&#x27;first-input&#x27;] &#125;);        // 监听布局偏移    new PerformanceObserver((entryList) =&gt; &#123;      const entries = entryList.getEntries();      this.metrics.cls = entries.reduce((sum, entry) =&gt; sum + entry.value, 0);    &#125;).observe(&#123; entryTypes: [&#x27;layout-shift&#x27;] &#125;);  &#125;&#125;

2. Resource Timing APIclass ResourceMonitor &#123;  constructor() &#123;    this.resourceList = [];  &#125;    // 获取资源加载详情  getResourceDetails() &#123;    const resources = performance.getEntriesByType(&#x27;resource&#x27;);        return resources.map(item =&gt; &#123;      const timings = &#123;        // DNS 查询时间        dns: item.domainLookupEnd - item.domainLookupStart,        // TCP 连接时间        tcp: item.connectEnd - item.connectStart,        // 请求响应时间        request: item.responseEnd - item.requestStart,        // 资源大小        size: item.encodedBodySize      &#125;;            return &#123;        name: item.name,        type: item.initiatorType,        timings      &#125;;    &#125;);  &#125;    // 分析资源加载瓶颈  analyzeBottlenecks() &#123;    const resources = this.getResourceDetails();    const bottlenecks = &#123;      slow_dns: [],      slow_tcp: [],      slow_request: [],      large_files: []    &#125;;        resources.forEach(resource =&gt; &#123;      const &#123; timings, name &#125; = resource;            if (timings.dns &gt; 100) &#123;        bottlenecks.slow_dns.push(name);      &#125;      if (timings.tcp &gt; 100) &#123;        bottlenecks.slow_tcp.push(name);      &#125;      if (timings.request &gt; 500) &#123;        bottlenecks.slow_request.push(name);      &#125;      if (timings.size &gt; 1024 * 1024) &#123;        bottlenecks.large_files.push(name);      &#125;    &#125;);        return bottlenecks;  &#125;&#125;

三、性能分析与优化1. 性能分数计算class PerformanceScore &#123;  // 计算性能得分  calculateScore(metrics) &#123;    const weights = &#123;      fcp: 0.2,      lcp: 0.25,      fid: 0.3,      cls: 0.25    &#125;;        const scores = &#123;      fcp: this.scoreFCP(metrics.fcp),      lcp: this.scoreLCP(metrics.lcp),      fid: this.scoreFID(metrics.fid),      cls: this.scoreCLS(metrics.cls)    &#125;;        return Object.entries(weights).reduce((total, [key, weight]) =&gt; &#123;      return total + scores[key] * weight;    &#125;, 0);  &#125;    // FCP 得分计算  scoreFCP(fcp) &#123;    if (fcp &lt;= 1000) return 1;    if (fcp &lt;= 2500) return 0.7;    if (fcp &lt;= 4000) return 0.3;    return 0;  &#125;    // 其他指标得分计算方法类似...&#125;

2. 性能监控报告class PerformanceReport &#123;  constructor() &#123;    this.monitor = new PerformanceMonitor();    this.resourceMonitor = new ResourceMonitor();    this.scoreCalculator = new PerformanceScore();  &#125;    // 生成性能报告  generateReport() &#123;    const metrics = this.monitor.metrics;    const resources = this.resourceMonitor.getResourceDetails();    const bottlenecks = this.resourceMonitor.analyzeBottlenecks();    const score = this.scoreCalculator.calculateScore(metrics);        return &#123;      score,      metrics,      resources,      bottlenecks,      timestamp: Date.now(),      url: window.location.href    &#125;;  &#125;    // 发送性能数据  async sendReport() &#123;    const report = this.generateReport();    try &#123;      await fetch(&#x27;/api/performance&#x27;, &#123;        method: &#x27;POST&#x27;,        body: JSON.stringify(report)      &#125;);    &#125; catch (error) &#123;      console.error(&#x27;Failed to send performance report:&#x27;, error);    &#125;  &#125;&#125;

四、实践建议1. 指标采集建议
采用抽样策略，避免全量采集
考虑网络环境的影响
过滤异常数据

2. 性能分析建议
建立性能基准线
关注趋势变化
结合业务场景

3. 优化方向// 1. 资源加载优化const optimizeResource = &#123;  // 预加载关键资源  preload: () =&gt; &#123;    const link = document.createElement(&#x27;link&#x27;);    link.rel = &#x27;preload&#x27;;    link.as = &#x27;script&#x27;;    link.href = &#x27;/critical.js&#x27;;    document.head.appendChild(link);  &#125;,    // 按需加载  lazyLoad: () =&gt; &#123;    const observer = new IntersectionObserver((entries) =&gt; &#123;      entries.forEach(entry =&gt; &#123;        if (entry.isIntersecting) &#123;          const img = entry.target;          img.src = img.dataset.src;          observer.unobserve(img);        &#125;      &#125;);    &#125;);  &#125;&#125;;// 2. 渲染优化const optimizeRender = &#123;  // 避免布局抖动  preventLayoutThrashing: () =&gt; &#123;    requestAnimationFrame(() =&gt; &#123;      const elements = document.querySelectorAll(&#x27;.dynamic&#x27;);      const positions = elements.map(el =&gt; el.getBoundingClientRect());            positions.forEach((pos, i) =&gt; &#123;        elements[i].style.transform = `translate($&#123;pos.left&#125;px, $&#123;pos.top&#125;px)`;      &#125;);    &#125;);  &#125;&#125;;

参考文献
Web Vitals
Performance API
Resource Timing API
性能优化最佳实践

]]></content>
      <categories>
        <category>前端</category>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>前端监控</tag>
      </tags>
  </entry>
  <entry>
    <title>前端微服务架构的实践经验</title>
    <url>/2024/09/19/micro-micro-frontend/</url>
    <content><![CDATA[一、什么是微前端微前端是一种类似于微服务的架构理念，它将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的应用，而在用户看来仍然是内聚的单个产品。
1. 核心价值
技术栈无关
独立开发部署
增量升级
团队自治

二、实现方案1. 基于路由分发// router.jsclass MicroRouter &#123;  constructor() &#123;    this.apps = new Map()    this.currentApp = null    this.init()  &#125;    init() &#123;    window.addEventListener(&#x27;popstate&#x27;, () =&gt; &#123;      this.handleRoute(window.location.pathname)    &#125;)  &#125;    register(path, app) &#123;    this.apps.set(path, app)  &#125;    handleRoute(path) &#123;    const app = this.apps.get(path)    if (app) &#123;      if (this.currentApp) &#123;        this.currentApp.unmount()      &#125;      this.currentApp = app      app.mount()    &#125;  &#125;&#125;// 使用示例const router = new MicroRouter()router.register(&#x27;/app1&#x27;, &#123;  mount: () =&gt; &#123;    // 加载并挂载应用1  &#125;,  unmount: () =&gt; &#123;    // 卸载应用1  &#125;&#125;)

2. 基于 Web Componentsclass MicroApp extends HTMLElement &#123;  constructor() &#123;    super()    this.shadow = this.attachShadow(&#123; mode: &#x27;open&#x27; &#125;)  &#125;    static get observedAttributes() &#123;    return [&#x27;name&#x27;, &#x27;url&#x27;]  &#125;    async connectedCallback() &#123;    const name = this.getAttribute(&#x27;name&#x27;)    const url = this.getAttribute(&#x27;url&#x27;)        try &#123;      const module = await this.loadModule(url)      this.mountApp(module)    &#125; catch (error) &#123;      console.error(`Failed to load micro app $&#123;name&#125;:`, error)    &#125;  &#125;    async loadModule(url) &#123;    const response = await fetch(url)    const code = await response.text()    return new Function(&#x27;exports&#x27;, code)  &#125;    mountApp(module) &#123;    const exports = &#123;&#125;    module(exports)        if (exports.render) &#123;      const container = document.createElement(&#x27;div&#x27;)      exports.render(container)      this.shadow.appendChild(container)    &#125;  &#125;    disconnectedCallback() &#123;    // 清理工作  &#125;&#125;customElements.define(&#x27;micro-app&#x27;, MicroApp)

3. 基于 Module Federation// webpack.config.jsconst ModuleFederationPlugin = require(&#x27;webpack/lib/container/ModuleFederationPlugin&#x27;)module.exports = &#123;  plugins: [    new ModuleFederationPlugin(&#123;      name: &#x27;container&#x27;,      remotes: &#123;        app1: &#x27;app1@http://localhost:3001/remoteEntry.js&#x27;,        app2: &#x27;app2@http://localhost:3002/remoteEntry.js&#x27;      &#125;,      shared: [&#x27;react&#x27;, &#x27;react-dom&#x27;]    &#125;)  ]&#125;// App.jsconst App1 = React.lazy(() =&gt; import(&#x27;app1/App&#x27;))const App2 = React.lazy(() =&gt; import(&#x27;app2/App&#x27;))function Container() &#123;  return (    &lt;div&gt;      &lt;React.Suspense fallback=&quot;Loading App1&quot;&gt;        &lt;App1 /&gt;      &lt;/React.Suspense&gt;      &lt;React.Suspense fallback=&quot;Loading App2&quot;&gt;        &lt;App2 /&gt;      &lt;/React.Suspense&gt;    &lt;/div&gt;  )&#125;

三、通信机制1. 事件总线class EventBus &#123;  constructor() &#123;    this.events = new Map()  &#125;    on(event, callback) &#123;    if (!this.events.has(event)) &#123;      this.events.set(event, new Set())    &#125;    this.events.get(event).add(callback)  &#125;    off(event, callback) &#123;    if (this.events.has(event)) &#123;      this.events.get(event).delete(callback)    &#125;  &#125;    emit(event, data) &#123;    if (this.events.has(event)) &#123;      for (const callback of this.events.get(event)) &#123;        callback(data)      &#125;    &#125;  &#125;&#125;// 使用示例const bus = new EventBus()// 应用1bus.on(&#x27;data-update&#x27;, (data) =&gt; &#123;  console.log(&#x27;App1 received:&#x27;, data)&#125;)// 应用2bus.emit(&#x27;data-update&#x27;, &#123; value: 123 &#125;)

2. 状态共享class SharedState &#123;  constructor() &#123;    this.state = &#123;&#125;    this.listeners = new Set()  &#125;    setState(path, value) &#123;    const oldValue = this.getState(path)    if (oldValue !== value) &#123;      this.updateState(path, value)      this.notifyListeners(path, value, oldValue)    &#125;  &#125;    getState(path) &#123;    return path.split(&#x27;.&#x27;).reduce((obj, key) =&gt; obj?.[key], this.state)  &#125;    updateState(path, value) &#123;    const keys = path.split(&#x27;.&#x27;)    const lastKey = keys.pop()    const target = keys.reduce((obj, key) =&gt; &#123;      if (!obj[key]) obj[key] = &#123;&#125;      return obj[key]    &#125;, this.state)    target[lastKey] = value  &#125;    subscribe(callback) &#123;    this.listeners.add(callback)    return () =&gt; this.listeners.delete(callback)  &#125;    notifyListeners(path, value, oldValue) &#123;    for (const listener of this.listeners) &#123;      listener(path, value, oldValue)    &#125;  &#125;&#125;

四、部署策略1. 独立部署class DeploymentManager &#123;  constructor() &#123;    this.apps = new Map()    this.versions = new Map()  &#125;    async deploy(appName, version, assets) &#123;    // 1. 上传资源    await this.uploadAssets(appName, version, assets)        // 2. 更新版本信息    this.versions.set(appName, version)        // 3. 通知其他应用    this.notifyVersionUpdate(appName, version)  &#125;    async uploadAssets(appName, version, assets) &#123;    const cdn = new CDNClient()    const urls = await cdn.upload(`$&#123;appName&#125;/$&#123;version&#125;`, assets)    this.apps.set(appName, urls)  &#125;    notifyVersionUpdate(appName, version) &#123;    // 通知其他应用有新版本发布    window.dispatchEvent(      new CustomEvent(&#x27;app-version-update&#x27;, &#123;        detail: &#123; appName, version &#125;      &#125;)    )  &#125;&#125;

2. 灰度发布class GrayRelease &#123;  constructor() &#123;    this.rules = new Map()  &#125;    addRule(appName, rule) &#123;    this.rules.set(appName, rule)  &#125;    shouldUseNewVersion(appName, context) &#123;    const rule = this.rules.get(appName)    if (!rule) return false        return this.evaluateRule(rule, context)  &#125;    evaluateRule(rule, context) &#123;    // 规则示例：    // &#123;    //   percentage: 10,  // 灰度比例    //   userGroups: [&#x27;test&#x27;],  // 用户组    //   regions: [&#x27;CN&#x27;]  // 地区    // &#125;        if (rule.percentage) &#123;      const random = Math.random() * 100      if (random &gt; rule.percentage) return false    &#125;        if (rule.userGroups &amp;&amp; !rule.userGroups.includes(context.userGroup)) &#123;      return false    &#125;        if (rule.regions &amp;&amp; !rule.regions.includes(context.region)) &#123;      return false    &#125;        return true  &#125;&#125;

五、性能优化1. 资源加载优化class ResourceLoader &#123;  constructor() &#123;    this.cache = new Map()    this.loading = new Map()  &#125;    async load(url) &#123;    // 1. 检查缓存    if (this.cache.has(url)) &#123;      return this.cache.get(url)    &#125;        // 2. 检查是否正在加载    if (this.loading.has(url)) &#123;      return this.loading.get(url)    &#125;        // 3. 开始加载    const promise = this.loadResource(url)    this.loading.set(url, promise)        try &#123;      const resource = await promise      this.cache.set(url, resource)      return resource    &#125; finally &#123;      this.loading.delete(url)    &#125;  &#125;    async loadResource(url) &#123;    const response = await fetch(url)    if (!response.ok) &#123;      throw new Error(`Failed to load $&#123;url&#125;`)    &#125;    return response.text()  &#125;&#125;

2. 预加载策略class PreloadManager &#123;  constructor() &#123;    this.loader = new ResourceLoader()    this.rules = new Map()  &#125;    addRule(path, resources) &#123;    this.rules.set(path, resources)  &#125;    handleRouteChange(path) &#123;    const resources = this.rules.get(path)    if (resources) &#123;      this.preloadResources(resources)    &#125;  &#125;    preloadResources(resources) &#123;    for (const url of resources) &#123;      const link = document.createElement(&#x27;link&#x27;)      link.rel = &#x27;prefetch&#x27;      link.href = url      document.head.appendChild(link)    &#125;  &#125;&#125;

六、监控与日志1. 性能监控class PerformanceMonitor &#123;  constructor() &#123;    this.metrics = &#123;&#125;  &#125;    trackAppLoad(appName) &#123;    const startTime = performance.now()        return &#123;      end: () =&gt; &#123;        const duration = performance.now() - startTime        this.recordMetric(appName, &#x27;load&#x27;, duration)      &#125;    &#125;  &#125;    recordMetric(appName, metric, value) &#123;    if (!this.metrics[appName]) &#123;      this.metrics[appName] = &#123;&#125;    &#125;        if (!this.metrics[appName][metric]) &#123;      this.metrics[appName][metric] = []    &#125;        this.metrics[appName][metric].push(&#123;      value,      timestamp: Date.now()    &#125;)  &#125;    getMetrics(appName) &#123;    return this.metrics[appName] || &#123;&#125;  &#125;&#125;

2. 错误监控class ErrorTracker &#123;  constructor() &#123;    this.errors = []    this.init()  &#125;    init() &#123;    window.addEventListener(&#x27;error&#x27;, (event) =&gt; &#123;      this.trackError(&#123;        type: &#x27;runtime&#x27;,        error: event.error,        source: event.filename,        line: event.lineno,        column: event.colno      &#125;)    &#125;)        window.addEventListener(&#x27;unhandledrejection&#x27;, (event) =&gt; &#123;      this.trackError(&#123;        type: &#x27;promise&#x27;,        error: event.reason      &#125;)    &#125;)  &#125;    trackError(error) &#123;    this.errors.push(&#123;      ...error,      timestamp: Date.now()    &#125;)        this.reportError(error)  &#125;    async reportError(error) &#123;    try &#123;      await fetch(&#x27;/api/errors&#x27;, &#123;        method: &#x27;POST&#x27;,        body: JSON.stringify(error)      &#125;)    &#125; catch (e) &#123;      console.error(&#x27;Failed to report error:&#x27;, e)    &#125;  &#125;&#125;

参考文献
微前端框架对比
Module Federation 文档
Web Components 规范
性能监控最佳实践

]]></content>
      <categories>
        <category>前端</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>微前端</tag>
        <tag>架构</tag>
        <tag>最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title>前端实现即时通讯的常用技术有哪些？</title>
    <url>/2024/05/15/socket-realtime-communication/</url>
    <content><![CDATA[一、技术概述前端实现即时通讯的主要技术方案包括：

传统轮询（Polling）
长轮询（Long Polling）
WebSocket
Server-Sent Events (SSE)
Socket.IO

二、具体实现1. 传统轮询class Polling &#123;  constructor(url, interval = 3000) &#123;    this.url = url;    this.interval = interval;    this.timer = null;  &#125;    start() &#123;    this.timer = setInterval(async () =&gt; &#123;      try &#123;        const response = await fetch(this.url);        const data = await response.json();        this.handleMessage(data);      &#125; catch (error) &#123;        console.error(&#x27;Polling error:&#x27;, error);      &#125;    &#125;, this.interval);  &#125;    stop() &#123;    if (this.timer) &#123;      clearInterval(this.timer);      this.timer = null;    &#125;  &#125;    handleMessage(data) &#123;    // 处理接收到的消息    console.log(&#x27;Received:&#x27;, data);  &#125;&#125;// 使用示例const polling = new Polling(&#x27;/api/messages&#x27;);polling.start();

2. 长轮询class LongPolling &#123;  constructor(url) &#123;    this.url = url;    this.isPolling = false;  &#125;    async start() &#123;    this.isPolling = true;    while (this.isPolling) &#123;      try &#123;        const response = await fetch(this.url, &#123;          timeout: 30000 // 30秒超时        &#125;);                if (response.status === 200) &#123;          const data = await response.json();          this.handleMessage(data);        &#125;      &#125; catch (error) &#123;        console.error(&#x27;Long polling error:&#x27;, error);        // 错误后等待一段时间再重试        await new Promise(resolve =&gt; setTimeout(resolve, 5000));      &#125;    &#125;  &#125;    stop() &#123;    this.isPolling = false;  &#125;    handleMessage(data) &#123;    console.log(&#x27;Received:&#x27;, data);  &#125;&#125;

3. WebSocket3.1 基础实现class WebSocketClient &#123;  constructor(url) &#123;    this.url = url;    this.ws = null;    this.reconnectAttempts = 0;    this.maxReconnectAttempts = 5;    this.reconnectInterval = 3000;  &#125;    connect() &#123;    try &#123;      this.ws = new WebSocket(this.url);      this.bindEvents();    &#125; catch (error) &#123;      console.error(&#x27;WebSocket connection error:&#x27;, error);      this.reconnect();    &#125;  &#125;    bindEvents() &#123;    this.ws.onopen = () =&gt; &#123;      console.log(&#x27;WebSocket connected&#x27;);      this.reconnectAttempts = 0;    &#125;;        this.ws.onmessage = (event) =&gt; &#123;      const data = JSON.parse(event.data);      this.handleMessage(data);    &#125;;        this.ws.onclose = () =&gt; &#123;      console.log(&#x27;WebSocket closed&#x27;);      this.reconnect();    &#125;;        this.ws.onerror = (error) =&gt; &#123;      console.error(&#x27;WebSocket error:&#x27;, error);    &#125;;  &#125;    reconnect() &#123;    if (this.reconnectAttempts &lt; this.maxReconnectAttempts) &#123;      this.reconnectAttempts++;      setTimeout(() =&gt; &#123;        console.log(`Reconnecting... Attempt $&#123;this.reconnectAttempts&#125;`);        this.connect();      &#125;, this.reconnectInterval);    &#125;  &#125;    send(message) &#123;    if (this.ws &amp;&amp; this.ws.readyState === WebSocket.OPEN) &#123;      this.ws.send(JSON.stringify(message));    &#125; else &#123;      console.error(&#x27;WebSocket is not connected&#x27;);    &#125;  &#125;    close() &#123;    if (this.ws) &#123;      this.ws.close();    &#125;  &#125;    handleMessage(data) &#123;    console.log(&#x27;Received:&#x27;, data);  &#125;&#125;

3.2 心跳检测class HeartbeatWebSocket extends WebSocketClient &#123;  constructor(url) &#123;    super(url);    this.heartbeatInterval = 30000; // 30秒    this.heartbeatTimer = null;  &#125;    startHeartbeat() &#123;    this.heartbeatTimer = setInterval(() =&gt; &#123;      this.send(&#123; type: &#x27;ping&#x27; &#125;);    &#125;, this.heartbeatInterval);  &#125;    stopHeartbeat() &#123;    if (this.heartbeatTimer) &#123;      clearInterval(this.heartbeatTimer);      this.heartbeatTimer = null;    &#125;  &#125;    bindEvents() &#123;    super.bindEvents();        this.ws.onopen = () =&gt; &#123;      console.log(&#x27;WebSocket connected&#x27;);      this.reconnectAttempts = 0;      this.startHeartbeat();    &#125;;        this.ws.onclose = () =&gt; &#123;      console.log(&#x27;WebSocket closed&#x27;);      this.stopHeartbeat();      this.reconnect();    &#125;;  &#125;&#125;

4. Server-Sent Eventsclass SSEClient &#123;  constructor(url) &#123;    this.url = url;    this.eventSource = null;  &#125;    connect() &#123;    this.eventSource = new EventSource(this.url);        this.eventSource.onopen = () =&gt; &#123;      console.log(&#x27;SSE connected&#x27;);    &#125;;        this.eventSource.onmessage = (event) =&gt; &#123;      const data = JSON.parse(event.data);      this.handleMessage(data);    &#125;;        this.eventSource.onerror = (error) =&gt; &#123;      console.error(&#x27;SSE error:&#x27;, error);      this.eventSource.close();      // 可以在这里实现重连逻辑    &#125;;  &#125;    close() &#123;    if (this.eventSource) &#123;      this.eventSource.close();    &#125;  &#125;    handleMessage(data) &#123;    console.log(&#x27;Received:&#x27;, data);  &#125;&#125;

5. Socket.IOimport io from &#x27;socket.io-client&#x27;;class SocketIOClient &#123;  constructor(url) &#123;    this.socket = io(url, &#123;      reconnection: true,      reconnectionAttempts: 5,      reconnectionDelay: 3000    &#125;);        this.bindEvents();  &#125;    bindEvents() &#123;    this.socket.on(&#x27;connect&#x27;, () =&gt; &#123;      console.log(&#x27;Socket.IO connected&#x27;);    &#125;);        this.socket.on(&#x27;disconnect&#x27;, () =&gt; &#123;      console.log(&#x27;Socket.IO disconnected&#x27;);    &#125;);        this.socket.on(&#x27;error&#x27;, (error) =&gt; &#123;      console.error(&#x27;Socket.IO error:&#x27;, error);    &#125;);        // 自定义事件监听    this.socket.on(&#x27;message&#x27;, (data) =&gt; &#123;      this.handleMessage(data);    &#125;);  &#125;    send(event, data) &#123;    this.socket.emit(event, data);  &#125;    close() &#123;    this.socket.close();  &#125;    handleMessage(data) &#123;    console.log(&#x27;Received:&#x27;, data);  &#125;&#125;

三、技术对比1. 性能对比class PerformanceTest &#123;  static async runTests() &#123;    const results = &#123;      polling: await this.testPolling(),      longPolling: await this.testLongPolling(),      webSocket: await this.testWebSocket(),      sse: await this.testSSE()    &#125;;        console.table(results);  &#125;    static async testPolling() &#123;    const startTime = performance.now();    // 测试代码...    const endTime = performance.now();        return &#123;      latency: endTime - startTime,      bandwidth: &#x27;高&#x27;,      serverLoad: &#x27;高&#x27;,      realtime: &#x27;低&#x27;    &#125;;  &#125;    // 其他测试方法...&#125;

2. 应用场景class RealtimeStrategy &#123;  static getRecommendedTechnology(requirements) &#123;    const &#123;      messageFrequency,      userCount,      browserSupport,      bidirectional    &#125; = requirements;        if (bidirectional &amp;&amp; browserSupport.webSocket) &#123;      return &#x27;WebSocket&#x27;;    &#125;        if (!bidirectional &amp;&amp; browserSupport.sse) &#123;      return &#x27;SSE&#x27;;    &#125;        if (messageFrequency === &#x27;high&#x27;) &#123;      return &#x27;Long Polling&#x27;;    &#125;        return &#x27;Traditional Polling&#x27;;  &#125;&#125;

四、最佳实践1. 消息可靠性class ReliableMessaging &#123;  constructor() &#123;    this.messageQueue = new Map();    this.messageId = 0;  &#125;    send(message) &#123;    const id = this.messageId++;    this.messageQueue.set(id, message);        this.sendWithRetry(id, message);  &#125;    async sendWithRetry(id, message, retries = 3) &#123;    try &#123;      await this.doSend(message);      this.messageQueue.delete(id);    &#125; catch (error) &#123;      if (retries &gt; 0) &#123;        setTimeout(() =&gt; &#123;          this.sendWithRetry(id, message, retries - 1);        &#125;, 1000);      &#125;    &#125;  &#125;&#125;

2. 断线重连class ReconnectionManager &#123;  constructor() &#123;    this.maxRetries = 5;    this.retryDelay = 3000;    this.exponentialFactor = 2;  &#125;    async reconnect(connectFn) &#123;    let retries = 0;    let delay = this.retryDelay;        while (retries &lt; this.maxRetries) &#123;      try &#123;        await connectFn();        return true;      &#125; catch (error) &#123;        retries++;        console.log(`Reconnection attempt $&#123;retries&#125; failed`);                if (retries &lt; this.maxRetries) &#123;          await new Promise(resolve =&gt; setTimeout(resolve, delay));          delay *= this.exponentialFactor;        &#125;      &#125;    &#125;        return false;  &#125;&#125;

3. 消息压缩class MessageCompression &#123;  static compress(message) &#123;    // 使用 MessagePack 或其他压缩算法    return msgpack.encode(message);  &#125;    static decompress(data) &#123;    return msgpack.decode(data);  &#125;&#125;

参考文献
WebSocket API
Server-Sent Events
Socket.IO 文档
HTTP 轮询最佳实践

]]></content>
      <categories>
        <category>前端</category>
        <category>网络通信</category>
      </categories>
      <tags>
        <tag>WebSocket</tag>
        <tag>即时通讯</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>小心爆炸💥</title>
    <url>/2024/05/15/scene-bubble-effect/</url>
    <content><![CDATA[效果介绍这是我的博客的一个泡泡🫧交互，主要有以下功能：

页面上会漂浮着多个半透明的气泡
气泡会缓慢上升并旋转
点击气泡会产生爆炸效果，并显示随机词汇
词汇包含财运、奶茶等多种趣味文本

实现步骤1. HTML 结构整个特效是通过 JavaScript 动态创建的，使用 DocumentFragment 优化 DOM 操作：
const fragment = document.createDocumentFragment();const container = document.createElement(&#x27;div&#x27;);container.className = &#x27;bubble-container&#x27;;fragment.appendChild(container);document.body.appendChild(fragment);

2. CSS 样式需要添加以下样式来实现气泡和动画效果：
.bubble-container &#123;  position: fixed;  top: 0;  left: 0;  width: 100%;  height: 100%;  pointer-events: none;  z-index: 999;  overflow: hidden;&#125;.bubble &#123;  position: absolute;  bottom: -100px;  width: 30px;  height: 30px;  border-radius: 50%;  background: rgba(255, 255, 255, 0.4);  animation: float 20s linear infinite;  pointer-events: auto;  cursor: pointer;  will-change: transform;&#125;.blessing-text &#123;  position: fixed;  transform: translate(-50%, -50%);  font-size: 1.2em;  white-space: nowrap;  pointer-events: none;  animation: fadeOut 2s forwards;  z-index: 1000;&#125;.particle &#123;  position: fixed;  width: 8px;  height: 8px;  border-radius: 50%;  pointer-events: none;  animation: explode 1s ease-out forwards;  z-index: 1000;&#125;@keyframes float &#123;  from &#123;    transform: translateY(100vh) rotate(0deg);  &#125;  to &#123;    transform: translateY(-100vh) rotate(360deg);  &#125;&#125;@keyframes fadeOut &#123;  0% &#123;    opacity: 0;    transform: translate(-50%, -50%) scale(0.5);  &#125;  50% &#123;    opacity: 1;    transform: translate(-50%, -50%) scale(1.2);  &#125;  100% &#123;    opacity: 0;    transform: translate(-50%, -50%) scale(1);  &#125;&#125;@keyframes explode &#123;  0% &#123;    transform: translate(-50%, -50%) rotate(var(--angle)) translateY(0);    opacity: 1;  &#125;  100% &#123;    transform: translate(-50%, -50%) rotate(var(--angle)) translateY(100px);    opacity: 0;  &#125;&#125;

3. JavaScript 实现3.1 性能优化// 使用 Set 存储活动的泡泡，提高查找和删除效率const activeBubbles = new Set();// 缓存随机数生成函数const random = Math.random;const floor = Math.floor;

3.2 创建气泡function createBubble() &#123;  const bubble = document.createElement(&#x27;div&#x27;);  bubble.className = &#x27;bubble&#x27;;  // 预计算并缓存样式值  const margin = 150;  const startX = margin + random() * (window.innerWidth - 2 * margin);  const duration = 25 + random() * 20;  const delay = random() * 20;  const rotation = random() * 360;  // 使用 cssText 批量设置样式  bubble.style.cssText = `    left:$&#123;startX&#125;px;    animation-duration:$&#123;duration&#125;s;    animation-delay:$&#123;delay&#125;s;    transform:rotate($&#123;rotation&#125;deg)  `;    return bubble;&#125;

4. 趣味文本设计包含了多种主题的祝福语：
const blessings = [  // 财运祝福  &quot;我看你今天要发财啊💰&quot;,  &quot;今天赚它一个亿💴&quot;,  &quot;钞能力MAX✨&quot;,    // 奶茶相关  `今天喝$&#123;milkTeas[random() * milkTeas.length | 0]&#125;🧋`,  &quot;奶茶要加双倍珍珠🧋&quot;,    // 搞笑祝福  &quot;今天要当最强躺赢王👑&quot;,  &quot;今天要当摸鱼王🐟&quot;,  &quot;摸鱼时间到了~&quot;];

性能优化要点
DOM 操作优化

使用 DocumentFragment 批量添加元素
使用 cssText 批量设置样式
减少重排重绘


动画性能优化

使用 transform 实现动画
缓存计算结果
添加 will-change 提示


内存管理优化

使用 Set 存储活动元素
及时清理不需要的元素
避免内存泄漏



使用方法
将 CSS 代码添加到你的样式文件中
将 JavaScript 代码保存为 bubble-effect.js
在页面中引入文件：&lt;script src=&quot;/js/bubble-effect.js&quot;&gt;&lt;/script&gt;

注意事项
气泡效果只在首页和文章列表页显示
已进行性能优化，但仍建议控制气泡数量
可以根据需要调整动画参数
祝福语可以自定义扩展

最后泡泡带来的不只是视觉效果，更是一份美好的祝福 ✨
]]></content>
      <categories>
        <category>交互</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>CSS</tag>
        <tag>前端特效</tag>
      </tags>
  </entry>
  <entry>
    <title>列表页跳转详情页的一些最佳实践？</title>
    <url>/2024/07/15/scene-list-detail-page/</url>
    <content><![CDATA[一、常见问题在列表页跳转到详情页时，通常会遇到以下问题：

详情页数据获取方式
返回列表页如何定位到之前位置
列表页数据缓存
详情页数据共享
URL 参数处理

二、解决方案1. 数据传递方式1.1 URL 参数传递// Vue Router 示例const routes = [  &#123;    path: &#x27;/detail/:id&#x27;,    name: &#x27;detail&#x27;,    component: DetailPage,    props: true // 将路由参数作为组件的 props  &#125;]// 列表页跳转methods: &#123;  goToDetail(id) &#123;    this.$router.push(&#123;      name: &#x27;detail&#x27;,      params: &#123; id &#125;,      query: &#123;         source: &#x27;list&#x27;,        timestamp: Date.now()      &#125;    &#125;)  &#125;&#125;// 详情页组件export default &#123;  props: &#123;    id: &#123;      type: [String, Number],      required: true    &#125;  &#125;,  async created() &#123;    await this.fetchDetail(this.id)  &#125;&#125;

1.2 状态管理传递// Vuex storeconst store = &#123;  state: &#123;    currentItem: null,    listData: [],    listScrollPosition: 0  &#125;,  mutations: &#123;    setCurrentItem(state, item) &#123;      state.currentItem = item    &#125;,    setListScrollPosition(state, position) &#123;      state.listScrollPosition = position    &#125;  &#125;&#125;// 列表页组件export default &#123;  methods: &#123;    goToDetail(item) &#123;      this.$store.commit(&#x27;setCurrentItem&#x27;, item)      this.$store.commit(&#x27;setListScrollPosition&#x27;, window.scrollY)      this.$router.push(`/detail/$&#123;item.id&#125;`)    &#125;  &#125;&#125;// 详情页组件export default &#123;  computed: &#123;    detailData() &#123;      return this.$store.state.currentItem    &#125;  &#125;,  async created() &#123;    if (!this.detailData) &#123;      // 如果没有缓存数据，则请求详情      await this.fetchDetail(this.$route.params.id)    &#125;  &#125;&#125;

2. 列表页位置恢复2.1 基于 scrollBehavior// router/index.jsconst router = new VueRouter(&#123;  scrollBehavior(to, from, savedPosition) &#123;    if (savedPosition) &#123;      // 如果有保存的位置，则恢复      return savedPosition    &#125; else if (from.meta.keepAlive &amp;&amp; to.meta.isBack) &#123;      // 如果是从详情页返回，且列表页需要缓存      return &#123;        x: 0,        y: store.state.listScrollPosition      &#125;    &#125; else &#123;      // 其他情况滚动到顶部      return &#123; x: 0, y: 0 &#125;    &#125;  &#125;&#125;)

2.2 虚拟列表实现&lt;template&gt;  &lt;virtual-list    :data-key=&quot;&#x27;id&#x27;&quot;    :data-sources=&quot;listData&quot;    :data-component=&quot;itemComponent&quot;    :keeps=&quot;30&quot;    :estimate-size=&quot;60&quot;    @scroll=&quot;handleScroll&quot;  /&gt;&lt;/template&gt;&lt;script&gt;import VirtualList from &#x27;vue-virtual-scroll-list&#x27;export default &#123;  components: &#123; VirtualList &#125;,  data() &#123;    return &#123;      listData: [],      scrollState: null    &#125;  &#125;,  methods: &#123;    handleScroll(&#123; offset &#125;) &#123;      // 保存滚动状态      this.scrollState = offset    &#125;,    restoreScroll() &#123;      if (this.scrollState !== null) &#123;        this.$refs.virtualList.scrollToOffset(this.scrollState)      &#125;    &#125;  &#125;,  activated() &#123;    // 在 keep-alive 组件被激活时恢复滚动位置    this.restoreScroll()  &#125;&#125;&lt;/script&gt;

3. 数据缓存策略3.1 Keep-alive 缓存&lt;!-- App.vue --&gt;&lt;template&gt;  &lt;keep-alive :include=&quot;[&#x27;ListView&#x27;]&quot;&gt;    &lt;router-view /&gt;  &lt;/keep-alive&gt;&lt;/template&gt;&lt;!-- ListView.vue --&gt;&lt;script&gt;export default &#123;  name: &#x27;ListView&#x27;,  data() &#123;    return &#123;      page: 1,      list: []    &#125;  &#125;,  activated() &#123;    // 组件被激活时触发    if (this.$route.meta.isBack) &#123;      // 从详情页返回，使用缓存数据      this.restoreState()    &#125; else &#123;      // 新进入页面，重新加载数据      this.loadData()    &#125;  &#125;,  methods: &#123;    async loadData() &#123;      const data = await this.fetchList(this.page)      this.list = [...this.list, ...data]    &#125;,    restoreState() &#123;      // 恢复滚动位置和其他状态    &#125;  &#125;&#125;&lt;/script&gt;

3.2 本地存储缓存class ListCache &#123;  constructor(key) &#123;    this.key = key    this.expireTime = 5 * 60 * 1000 // 5分钟过期  &#125;    save(data) &#123;    const cache = &#123;      data,      timestamp: Date.now()    &#125;    localStorage.setItem(this.key, JSON.stringify(cache))  &#125;    get() &#123;    const cache = localStorage.getItem(this.key)    if (!cache) return null        const &#123; data, timestamp &#125; = JSON.parse(cache)    if (Date.now() - timestamp &gt; this.expireTime) &#123;      localStorage.removeItem(this.key)      return null    &#125;        return data  &#125;    clear() &#123;    localStorage.removeItem(this.key)  &#125;&#125;// 使用示例const listCache = new ListCache(&#x27;list_page_cache&#x27;)export default &#123;  data() &#123;    return &#123;      list: []    &#125;  &#125;,  created() &#123;    // 尝试从缓存恢复数据    const cached = listCache.get()    if (cached) &#123;      this.list = cached    &#125; else &#123;      this.loadData()    &#125;  &#125;,  methods: &#123;    async loadData() &#123;      const data = await this.fetchList()      this.list = data      // 保存到缓存      listCache.save(data)    &#125;  &#125;&#125;

4. 性能优化4.1 预加载详情export default &#123;  methods: &#123;    // 鼠标悬停时预加载详情    async preloadDetail(id) &#123;      try &#123;        const detail = await this.fetchDetail(id)        this.$store.commit(&#x27;cacheDetail&#x27;, &#123; id, detail &#125;)      &#125; catch (error) &#123;        console.error(&#x27;预加载失败:&#x27;, error)      &#125;    &#125;,        // 使用预加载数据    async goToDetail(id) &#123;      const cached = this.$store.state.detailCache[id]      if (cached) &#123;        this.$store.commit(&#x27;setCurrentDetail&#x27;, cached)        this.$router.push(`/detail/$&#123;id&#125;`)      &#125; else &#123;        // 降级为普通加载        this.$router.push(`/detail/$&#123;id&#125;`)      &#125;    &#125;  &#125;&#125;

4.2 列表页懒加载&lt;template&gt;  &lt;div class=&quot;list-container&quot;&gt;    &lt;div      v-for=&quot;item in visibleItems&quot;      :key=&quot;item.id&quot;      class=&quot;list-item&quot;    &gt;      &#123;&#123; item.title &#125;&#125;    &lt;/div&gt;    &lt;div ref=&quot;observer&quot; class=&quot;observer&quot;&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      list: [],      page: 1,      loading: false    &#125;  &#125;,  computed: &#123;    visibleItems() &#123;      return this.list.slice(0, this.page * 20)    &#125;  &#125;,  mounted() &#123;    this.setupIntersectionObserver()  &#125;,  methods: &#123;    setupIntersectionObserver() &#123;      const observer = new IntersectionObserver(        entries =&gt; &#123;          if (entries[0].isIntersecting &amp;&amp; !this.loading) &#123;            this.loadMore()          &#125;        &#125;,        &#123; threshold: 0.1 &#125;      )            observer.observe(this.$refs.observer)    &#125;,    async loadMore() &#123;      this.loading = true      try &#123;        const data = await this.fetchList(this.page)        this.list.push(...data)        this.page++      &#125; finally &#123;        this.loading = false      &#125;    &#125;  &#125;&#125;&lt;/script&gt;

5. 分享页处理5.1 SEO 优化// 详情页组件export default &#123;  async asyncData(&#123; params, $axios &#125;) &#123;    // 服务端渲染时获取数据    const detail = await $axios.$get(`/api/detail/$&#123;params.id&#125;`)    return &#123; detail &#125;  &#125;,    head() &#123;    return &#123;      title: this.detail.title,      meta: [        &#123;          hid: &#x27;description&#x27;,          name: &#x27;description&#x27;,          content: this.detail.description        &#125;,        &#123;          hid: &#x27;keywords&#x27;,          name: &#x27;keywords&#x27;,          content: this.detail.keywords        &#125;,        // Open Graph 标签        &#123;          hid: &#x27;og:title&#x27;,          property: &#x27;og:title&#x27;,          content: this.detail.title        &#125;,        &#123;          hid: &#x27;og:description&#x27;,          property: &#x27;og:description&#x27;,          content: this.detail.description        &#125;,        &#123;          hid: &#x27;og:image&#x27;,          property: &#x27;og:image&#x27;,          content: this.detail.image        &#125;      ]    &#125;  &#125;&#125;

5.2 来源判断export default &#123;  data() &#123;    return &#123;      isFromShare: false    &#125;  &#125;,    created() &#123;    // 判断是否来自分享    this.isFromShare = !this.$route.query.source        // 根据来源设置不同的返回行为    if (this.isFromShare) &#123;      this.handleShareVisit()    &#125;  &#125;,    methods: &#123;    handleShareVisit() &#123;      // 处理分享访问      // 1. 记录分享访问      this.recordShareVisit()            // 2. 显示相关推荐      this.loadRecommendations()            // 3. 设置返回首页而不是列表页      this.setupBackBehavior()    &#125;,        setupBackBehavior() &#123;      // 重写返回按钮行为      this.$router.beforeEach((to, from, next) =&gt; &#123;        if (to.path === &#x27;/back&#x27;) &#123;          next(&#x27;/&#x27;)        &#125; else &#123;          next()        &#125;      &#125;)    &#125;  &#125;&#125;

5.3 分享配置// share.jsexport class ShareService &#123;  constructor(config) &#123;    this.config = config  &#125;    generateShareInfo(detail) &#123;    return &#123;      title: detail.title,      desc: detail.description,      link: this.generateShareLink(detail.id),      imgUrl: detail.image,      type: &#x27;article&#x27;    &#125;  &#125;    generateShareLink(id) &#123;    const baseUrl = process.env.BASE_URL    return `$&#123;baseUrl&#125;/detail/$&#123;id&#125;`  &#125;    // 配置微信分享  async setupWechatShare(shareInfo) &#123;    try &#123;      const wx = await this.initWechatSDK()            wx.updateAppMessageShareData(&#123;        title: shareInfo.title,        desc: shareInfo.desc,        link: shareInfo.link,        imgUrl: shareInfo.imgUrl,        success: () =&gt; &#123;          this.trackShare(&#x27;wechat&#x27;)        &#125;      &#125;)            wx.updateTimelineShareData(&#123;        title: shareInfo.title,        link: shareInfo.link,        imgUrl: shareInfo.imgUrl      &#125;)    &#125; catch (error) &#123;      console.error(&#x27;微信分享配置失败:&#x27;, error)    &#125;  &#125;    // 追踪分享数据  trackShare(platform) &#123;    // 记录分享数据    this.reportShareEvent(&#123;      platform,      timestamp: Date.now()    &#125;)  &#125;&#125;// 使用示例export default &#123;  data() &#123;    return &#123;      shareService: new ShareService(&#123;        appId: &#x27;your-app-id&#x27;,        // 其他配置...      &#125;)    &#125;  &#125;,    async mounted() &#123;    // 生成分享信息    const shareInfo = this.shareService.generateShareInfo(this.detail)        // 配置分享    await this.shareService.setupWechatShare(shareInfo)  &#125;&#125;

5.4 数据统计class ShareAnalytics &#123;  // 记录分享来源  trackShareSource() &#123;    const source = this.getUtmSource()    const medium = this.getUtmMedium()        this.saveAnalytics(&#123;      type: &#x27;share_visit&#x27;,      source,      medium,      timestamp: Date.now()    &#125;)  &#125;    // 记录分享转化  trackConversion(action) &#123;    this.saveAnalytics(&#123;      type: &#x27;share_conversion&#x27;,      action,      timestamp: Date.now()    &#125;)  &#125;    // 获取分享来源  getUtmSource() &#123;    const params = new URLSearchParams(window.location.search)    return params.get(&#x27;utm_source&#x27;) || &#x27;direct&#x27;  &#125;    // 保存统计数据  async saveAnalytics(data) &#123;    try &#123;      await fetch(&#x27;/api/analytics&#x27;, &#123;        method: &#x27;POST&#x27;,        body: JSON.stringify(data)      &#125;)    &#125; catch (error) &#123;      console.error(&#x27;统计数据保存失败:&#x27;, error)    &#125;  &#125;&#125;

参考文献
Vue Router 官方文档
Keep-alive 组件
浏览器存储指南
Intersection Observer API
微信 JS-SDK 文档
SEO 最佳实践

]]></content>
      <categories>
        <category>前端</category>
        <category>最佳实践</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>React</tag>
        <tag>前端路由</tag>
      </tags>
  </entry>
  <entry>
    <title>地图海量点渲染的解决方案有哪些？</title>
    <url>/2024/08/10/scene-map-big-data/</url>
    <content><![CDATA[一、问题背景在地图应用中，经常需要展示海量的点位数据（如出租车、共享单车、监控点位等）。当数据量达到几万甚至几十万个点时，会带来以下问题：

渲染性能下降
交互响应迟缓
内存占用过大
视觉上的点位重叠

二、解决方案1. 数据分层与分块1.1 按层级分组class LayerManager &#123;  constructor() &#123;    this.layers = new Map(); // 存储不同层级的数据  &#125;    addPoint(point, zoom) &#123;    if (!this.layers.has(zoom)) &#123;      this.layers.set(zoom, new Set());    &#125;    this.layers.get(zoom).add(point);  &#125;    getVisiblePoints(zoom) &#123;    return this.layers.get(Math.floor(zoom)) || new Set();  &#125;&#125;

1.2 网格分块class GridManager &#123;  constructor(gridSize) &#123;    this.gridSize = gridSize;    this.grids = new Map();  &#125;    // 计算点位所在的网格  getGridKey(lat, lng) &#123;    const x = Math.floor(lng / this.gridSize);    const y = Math.floor(lat / this.gridSize);    return `$&#123;x&#125;-$&#123;y&#125;`;  &#125;    // 添加点位到网格  addPoint(point) &#123;    const key = this.getGridKey(point.lat, point.lng);    if (!this.grids.has(key)) &#123;      this.grids.set(key, []);    &#125;    this.grids.get(key).push(point);  &#125;    // 获取视野范围内的网格数据  getVisiblePoints(bounds) &#123;    const visiblePoints = [];    const &#123; north, south, east, west &#125; = bounds;        for (let lat = south; lat &lt;= north; lat += this.gridSize) &#123;      for (let lng = west; lng &lt;= east; lng += this.gridSize) &#123;        const key = this.getGridKey(lat, lng);        const points = this.grids.get(key) || [];        visiblePoints.push(...points);      &#125;    &#125;        return visiblePoints;  &#125;&#125;

2. 点位聚合2.1 基础聚合算法class ClusterManager &#123;  constructor(radius) &#123;    this.radius = radius; // 聚合半径  &#125;    // 计算两点距离  getDistance(p1, p2) &#123;    const dx = p1.lng - p2.lng;    const dy = p1.lat - p2.lat;    return Math.sqrt(dx * dx + dy * dy);  &#125;    // 聚合点位  cluster(points) &#123;    const clusters = [];    const processed = new Set();        for (const point of points) &#123;      if (processed.has(point)) continue;            const cluster = &#123;        center: point,        points: [point],        count: 1      &#125;;            for (const other of points) &#123;        if (processed.has(other)) continue;                if (this.getDistance(point, other) &lt;= this.radius) &#123;          cluster.points.push(other);          cluster.count++;          processed.add(other);        &#125;      &#125;            clusters.push(cluster);    &#125;        return clusters;  &#125;&#125;

2.2 四叉树聚合class QuadTree &#123;  constructor(bounds, capacity) &#123;    this.bounds = bounds;    this.capacity = capacity;    this.points = [];    this.divided = false;  &#125;    // 划分区域  subdivide() &#123;    const &#123; x, y, width, height &#125; = this.bounds;    const w = width / 2;    const h = height / 2;        this.northwest = new QuadTree(&#123;x, y, width: w, height: h&#125;, this.capacity);    this.northeast = new QuadTree(&#123;x: x + w, y, width: w, height: h&#125;, this.capacity);    this.southwest = new QuadTree(&#123;x, y: y + h, width: w, height: h&#125;, this.capacity);    this.southeast = new QuadTree(&#123;x: x + w, y: y + h, width: w, height: h&#125;, this.capacity);        this.divided = true;  &#125;    // 插入点位  insert(point) &#123;    if (!this.bounds.contains(point)) &#123;      return false;    &#125;        if (this.points.length &lt; this.capacity) &#123;      this.points.push(point);      return true;    &#125;        if (!this.divided) &#123;      this.subdivide();    &#125;        return (      this.northwest.insert(point) ||      this.northeast.insert(point) ||      this.southwest.insert(point) ||      this.southeast.insert(point)    );  &#125;&#125;

3. 渲染优化3.1 Canvas 渲染class CanvasLayer &#123;  constructor(map) &#123;    this.canvas = document.createElement(&#x27;canvas&#x27;);    this.ctx = this.canvas.getContext(&#x27;2d&#x27;);    this.map = map;  &#125;    // 绘制点位  drawPoints(points) &#123;    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);        for (const point of points) &#123;      const pixel = this.map.latLngToContainerPoint(point);            this.ctx.beginPath();      this.ctx.arc(pixel.x, pixel.y, 4, 0, Math.PI * 2);      this.ctx.fillStyle = point.color || &#x27;#ff0000&#x27;;      this.ctx.fill();    &#125;  &#125;    // 更新 Canvas 大小  resize() &#123;    const size = this.map.getSize();    this.canvas.width = size.x;    this.canvas.height = size.y;  &#125;&#125;

3.2 WebGL 渲染class WebGLLayer &#123;  constructor(map) &#123;    this.canvas = document.createElement(&#x27;canvas&#x27;);    this.gl = this.canvas.getContext(&#x27;webgl&#x27;);    this.map = map;        this.initShaders();    this.initBuffers();  &#125;    // 初始化着色器  initShaders() &#123;    const vertexShader = `      attribute vec2 a_position;      uniform vec2 u_resolution;            void main() &#123;        vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);        gl_PointSize = 4.0;      &#125;    `;        const fragmentShader = `      precision mediump float;      uniform vec4 u_color;            void main() &#123;        float dist = length(gl_PointCoord - vec2(0.5, 0.5));        if (dist &gt; 0.5) &#123;          discard;        &#125;        gl_FragColor = u_color;      &#125;    `;        // ... 编译和链接着色器的代码  &#125;    // 渲染点位  render(points) &#123;    const positions = new Float32Array(points.length * 2);        points.forEach((point, i) =&gt; &#123;      const pixel = this.map.latLngToContainerPoint(point);      positions[i * 2] = pixel.x;      positions[i * 2 + 1] = pixel.y;    &#125;);        // ... WebGL 绘制代码  &#125;&#125;

4. 数据调度优化4.1 视野范围计算class ViewportManager &#123;  constructor(map) &#123;    this.map = map;  &#125;    // 获取当前视野范围  getBounds() &#123;    const bounds = this.map.getBounds();    const ne = bounds.getNorthEast();    const sw = bounds.getSouthWest();        return &#123;      north: ne.lat,      south: sw.lat,      east: ne.lng,      west: sw.lng    &#125;;  &#125;    // 判断点是否在视野内  isPointInView(point) &#123;    const bounds = this.getBounds();    return (      point.lat &lt;= bounds.north &amp;&amp;      point.lat &gt;= bounds.south &amp;&amp;      point.lng &lt;= bounds.east &amp;&amp;      point.lng &gt;= bounds.west    );  &#125;&#125;

4.2 异步加载class DataLoader &#123;  constructor() &#123;    this.cache = new Map();    this.loading = new Set();  &#125;    // 异步加载数据  async loadTileData(x, y, z) &#123;    const key = `$&#123;x&#125;-$&#123;y&#125;-$&#123;z&#125;`;        if (this.cache.has(key)) &#123;      return this.cache.get(key);    &#125;        if (this.loading.has(key)) &#123;      return new Promise(resolve =&gt; &#123;        const checkCache = setInterval(() =&gt; &#123;          if (this.cache.has(key)) &#123;            clearInterval(checkCache);            resolve(this.cache.get(key));          &#125;        &#125;, 100);      &#125;);    &#125;        this.loading.add(key);        try &#123;      const data = await fetch(`/api/points?x=$&#123;x&#125;&amp;y=$&#123;y&#125;&amp;z=$&#123;z&#125;`);      const points = await data.json();            this.cache.set(key, points);      this.loading.delete(key);            return points;    &#125; catch (error) &#123;      this.loading.delete(key);      throw error;    &#125;  &#125;&#125;

三、实践建议
数据处理

预处理数据，提前计算聚合结果
使用 Web Worker 处理大量数据
采用增量加载策略


渲染优化

优先使用 Canvas&#x2F;WebGL 渲染
实现图层缓存机制
控制重绘频率


交互优化

实现节流和防抖
优化事件监听器
添加加载提示



四、完整示例class BigDataMap &#123;  constructor(container) &#123;    this.map = new Map(container);    this.gridManager = new GridManager(0.01);    this.clusterManager = new ClusterManager(50);    this.canvasLayer = new CanvasLayer(this.map);    this.dataLoader = new DataLoader();        this.initEvents();  &#125;    // 初始化事件  initEvents() &#123;    this.map.on(&#x27;moveend&#x27;, this.throttle(this.update.bind(this), 100));    this.map.on(&#x27;zoomend&#x27;, this.throttle(this.update.bind(this), 100));  &#125;    // 更新视图  async update() &#123;    const bounds = this.map.getBounds();    const zoom = this.map.getZoom();        // 加载数据    const points = await this.dataLoader.loadTileData(      bounds.getWest(),      bounds.getSouth(),      zoom    );        // 网格分块    this.gridManager.clear();    points.forEach(point =&gt; this.gridManager.addPoint(point));        // 获取视野内的点    const visiblePoints = this.gridManager.getVisiblePoints(bounds);        // 点位聚合    const clusters = this.clusterManager.cluster(visiblePoints);        // 渲染    this.canvasLayer.drawPoints(clusters);  &#125;    // 节流函数  throttle(fn, delay) &#123;    let timer = null;    return function(...args) &#123;      if (timer) return;      timer = setTimeout(() =&gt; &#123;        fn.apply(this, args);        timer = null;      &#125;, delay);    &#125;;  &#125;&#125;

参考文献
WebGL 基础教程
Canvas 性能优化
四叉树算法详解
地图可视化最佳实践

]]></content>
      <categories>
        <category>前端</category>
        <category>地图开发</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>性能优化</tag>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</title>
    <url>/2025/01/30/vue3-composition/</url>
    <content><![CDATA[ 
开始之前Composition API 可以说是Vue3的最大特点，那么为什么要推出Composition Api，解决了什么问题？
通常使用Vue2开发的项目，普遍会存在以下问题：

代码的可读性随着组件变大而变差
每一种代码复用的方式，都存在缺点
TypeScript支持有限

以上通过使用Composition Api都能迎刃而解
正文一、Options ApiOptions API，即大家常说的选项API，即以vue为后缀的文件，通过定义methods，computed，watch，data等属性与方法，共同处理页面逻辑
如下图：
 
可以看到Options代码编写方式，如果是组件状态，则写在data属性上，如果是方法，则写在methods属性上…
用组件的选项 (data、computed、methods、watch) 组织逻辑在大多数情况下都有效
然而，当组件变得复杂，导致对应属性的列表也会增长，这可能会导致组件难以阅读和理解
二、Composition Api在 Vue3 Composition API 中，组件根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）
即使项目很大，功能很多，我们都能快速的定位到这个功能所用到的所有 API
 
三、对比下面对Composition Api 与Options Api进行两大方面的比较

逻辑组织
逻辑复用

逻辑组织Options API假设一个组件是一个大型组件，其内部有很多处理逻辑关注点（对应下图不用颜色）
 
可以看到，这种碎片化使得理解和维护复杂组件变得困难
选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块
Compostion API而Compositon API正是解决上述问题，将某个逻辑关注点相关的代码全都放在一个函数里，这样当需要修改一个功能时，就不再需要在文件中跳来跳去
下面举个简单例子，将处理count属性相关的代码放在同一个函数了
function useCount() &#123;    let count = ref(10);    let double = computed(() =&gt; &#123;        return count.value * 2;    &#125;);    const handleConut = () =&gt; &#123;        count.value = count.value * 2;    &#125;;    console.log(count);    return &#123;        count,        double,        handleConut,    &#125;;&#125;

组件上中使用count
export default defineComponent(&#123;    setup() &#123;        const &#123; count, double, handleConut &#125; = useCount();        return &#123;            count,            double,            handleConut        &#125;    &#125;,&#125;);

再来一张图进行对比，可以很直观地感受到 Composition API 在逻辑组织方面的优势，以后修改一个属性功能的时候，只需要跳到控制该属性的方法中即可

逻辑复用在Vue2中，我们是用过mixin去复用相同的逻辑
下面举个例子，我们会另起一个mixin.js文件
export const MoveMixin = &#123;  data() &#123;    return &#123;      x: 0,      y: 0,    &#125;;  &#125;,  methods: &#123;    handleKeyup(e) &#123;      console.log(e.code);      // 上下左右 x y      switch (e.code) &#123;        case &quot;ArrowUp&quot;:          this.y--;          break;        case &quot;ArrowDown&quot;:          this.y++;          break;        case &quot;ArrowLeft&quot;:          this.x--;          break;        case &quot;ArrowRight&quot;:          this.x++;          break;      &#125;    &#125;,  &#125;,  mounted() &#123;    window.addEventListener(&quot;keyup&quot;, this.handleKeyup);  &#125;,  unmounted() &#123;    window.removeEventListener(&quot;keyup&quot;, this.handleKeyup);  &#125;,&#125;;

然后在组件中使用
&lt;template&gt;  &lt;div&gt;    Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import mousePositionMixin from &#x27;./mouse&#x27;export default &#123;  mixins: [mousePositionMixin]&#125;&lt;/script&gt;

使用单个mixin似乎问题不大，但是当我们一个组件混入大量不同的 mixins 的时候
mixins: [mousePositionMixin, fooMixin, barMixin, otherMixin]

会存在两个非常明显的问题：

命名冲突
数据来源不清晰

现在通过Compositon API这种方式改写上面的代码
import &#123; onMounted, onUnmounted, reactive &#125; from &quot;vue&quot;;export function useMove() &#123;  const position = reactive(&#123;    x: 0,    y: 0,  &#125;);  const handleKeyup = (e) =&gt; &#123;    console.log(e.code);    // 上下左右 x y    switch (e.code) &#123;      case &quot;ArrowUp&quot;:        // y.value--;        position.y--;        break;      case &quot;ArrowDown&quot;:        // y.value++;        position.y++;        break;      case &quot;ArrowLeft&quot;:        // x.value--;        position.x--;        break;      case &quot;ArrowRight&quot;:        // x.value++;        position.x++;        break;    &#125;  &#125;;  onMounted(() =&gt; &#123;    window.addEventListener(&quot;keyup&quot;, handleKeyup);  &#125;);  onUnmounted(() =&gt; &#123;    window.removeEventListener(&quot;keyup&quot;, handleKeyup);  &#125;);  return &#123; position &#125;;&#125;

在组件中使用
&lt;template&gt;  &lt;div&gt;    Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; useMove &#125; from &quot;./useMove&quot;;import &#123; toRefs &#125; from &quot;vue&quot;;export default &#123;  setup() &#123;    const &#123; position &#125; = useMove();    const &#123; x, y &#125; = toRefs(position);    return &#123;      x,      y,    &#125;;  &#125;,&#125;;&lt;/script&gt;

可以看到，整个数据来源清晰了，即使去编写更多的 hook 函数，也不会出现命名冲突的问题
小结
在逻辑组织和逻辑复用方面，Composition API是优于Options  API
因为Composition API几乎是函数，会有更好的类型推断。
Composition API 对 tree-shaking 友好，代码也更容易压缩
Composition API中见不到this的使用，减少了this指向不明的情况
如果是小型组件，可以继续使用Options API，也是十分友好的

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3.0的设计目标是什么？做了哪些优化</title>
    <url>/2025/01/31/vue3-goal/</url>
    <content><![CDATA[
一、设计目标不以解决实际业务痛点的更新都是耍流氓，下面我们来列举一下Vue3之前我们或许会面临的问题

随着功能的增长，复杂组件的代码变得越来越难以维护

缺少一种比较「干净」的在多个组件之间提取和复用逻辑的机制

类型推断不够友好

bundle的时间太久了


而 Vue3 经过长达两三年时间的筹备，做了哪些事情？
我们从结果反推

更小
更快
TypeScript支持
API设计一致性
提高自身可维护性
开放更多底层功能

一句话概述，就是更小更快更友好了
更小Vue3移除一些不常用的 API
引入tree-shaking，可以将无用模块“剪辑”，仅打包需要的，使打包的整体体积变小了
更快主要体现在编译方面：

diff算法优化
静态提升
事件监听缓存
SSR优化

下篇文章我们会进一步介绍
更友好vue3在兼顾vue2的options API的同时还推出了composition API，大大增加了代码的逻辑组织和代码复用能力
这里代码简单演示下：
存在一个获取鼠标位置的函数
import &#123; toRefs, reactive &#125; from &#x27;vue&#x27;;function useMouse()&#123;    const state = reactive(&#123;x:0,y:0&#125;);    const update = e=&gt;&#123;        state.x = e.pageX;        state.y = e.pageY;    &#125;    onMounted(()=&gt;&#123;        window.addEventListener(&#x27;mousemove&#x27;,update);    &#125;)    onUnmounted(()=&gt;&#123;        window.removeEventListener(&#x27;mousemove&#x27;,update);    &#125;)    return toRefs(state);&#125;

我们只需要调用这个函数，即可获取x、y的坐标，完全不用关注实现过程
试想一下，如果很多类似的第三方库，我们只需要调用即可，不必关注实现过程，开发效率大大提高
同时，VUE3是基于typescipt编写的，可以享受到自动的类型定义提示
三、优化方案vue3从很多层面都做了优化，可以分成三个方面：

源码
性能
语法 API

源码源码可以从两个层面展开：

源码管理
TypeScript

源码管理vue3整个源码是通过 monorepo 的方式维护的，根据功能将不同的模块拆分到packages 目录下面不同的子目录中
 
这样使得模块拆分更细化，职责划分更明确，模块之间的依赖关系也更加明确，开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性
另外一些 package（比如 reactivity 响应式库）是可以独立于 Vue 使用的，这样用户如果只想使用 Vue3 的响应式能力，可以单独依赖这个响应式库而不用去依赖整个 Vue
TypeScriptVue3是基于typeScript编写的，提供了更好的类型检查，能支持复杂的类型推导
性能vue3是从什么哪些方面对性能进行进一步优化呢？

体积优化
编译优化
数据劫持优化

这里讲述数据劫持：
在vue2中，数据劫持是通过Object.defineProperty ，这个 API 有一些缺陷，并不能检测对象属性的添加和删除
Object.defineProperty(data, &#x27;a&#x27;,&#123;  get()&#123;    // track  &#125;,  set()&#123;    // trigger  &#125;&#125;)

尽管 Vue为了解决这个问题提供了 set 和delete 实例方法，但是对于用户来说，还是增加了一定的心智负担
同时在面对嵌套层级比较深的情况下，就存在性能问题
default &#123;  data: &#123;    a: &#123;      b: &#123;          c: &#123;          d: 1        &#125;      &#125;    &#125;  &#125;&#125;

相比之下，vue3是通过proxy监听整个对象，那么对于删除还是监听当然也能监听到
同时Proxy  并不能监听到内部深层次的对象变化，而 Vue3 的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归
语法 API这里当然说的就是composition API，其两大显著的优化：

优化逻辑组织
优化逻辑复用

逻辑组织一张图，我们可以很直观地感受到 Composition API 在逻辑组织方面的优势
 
相同功能的代码编写在一块，而不像options API那样，各个功能的代码混成一块
逻辑复用在vue2中，我们是通过mixin实现功能混合，如果多个mixin混合，会存在两个非常明显的问题：命名冲突和数据来源不清晰
而通过composition这种形式，可以将一些复用的代码抽离出来作为一个函数，只要的使用的地方直接进行调用即可
同样是上文的获取鼠标位置的例子
import &#123; toRefs, reactive, onUnmounted, onMounted &#125; from &#x27;vue&#x27;;function useMouse()&#123;    const state = reactive(&#123;x:0,y:0&#125;);    const update = e=&gt;&#123;        state.x = e.pageX;        state.y = e.pageY;    &#125;    onMounted(()=&gt;&#123;        window.addEventListener(&#x27;mousemove&#x27;,update);    &#125;)    onUnmounted(()=&gt;&#123;        window.removeEventListener(&#x27;mousemove&#x27;,update);    &#125;)    return toRefs(state);&#125;

组件使用
import useMousePosition from &#x27;./mouse&#x27;export default &#123;    setup() &#123;        const &#123; x, y &#125; = useMousePosition()        return &#123; x, y &#125;    &#125;&#125;

可以看到，整个数据来源清晰了，即使去编写更多的hook函数，也不会出现命名冲突的问题
参考文献
https://juejin.cn/post/6850418112878575629#heading-5
https://vue3js.cn/docs/zh

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>用Vue3.0 写过组件吗？如果想实现一个 Modal你会怎么设计？</title>
    <url>/2025/01/22/vue3-modal-component/</url>
    <content><![CDATA[ 
一、组件设计组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式
现在有一个场景，点击新增与编辑都弹框出来进行填写，功能上大同小异，可能只是标题内容或者是显示的主体内容稍微不同
这时候就没必要写两个组件，只需要根据传入的参数不同，组件显示不同内容即可
这样，下次开发相同界面程序时就可以写更少的代码，意义着更高的开发效率，更少的 Bug 和更少的程序体积
二、需求分析实现一个Modal组件，首先确定需要完成的内容：

遮罩层

标题内容

主体内容

确定和取消按钮


主体内容需要灵活，所以可以是字符串，也可以是一段 html 代码
特点是它们在当前vue实例之外独立存在，通常挂载于body之上
除了通过引入import的形式，我们还可通过API的形式进行组件的调用
还可以包括配置全局样式、国际化、与typeScript结合
三、实现流程首先看看大致流程：

目录结构

组件内容

实现 API 形式

事件处理

其他完善


目录结构Modal组件相关的目录结构
├── plugins│   └── modal│       ├── Content.tsx // 维护 Modal 的内容，用于 h 函数和 jsx 语法│       ├── Modal.vue // 基础组件│       ├── config.ts // 全局默认配置│       ├── index.ts // 入口│       ├── locale // 国际化相关│       │   ├── index.ts│       │   └── lang│       │       ├── en-US.ts│       │       ├── zh-CN.ts│       │       └── zh-TW.ts│       └── modal.type.ts // ts类型声明相关

因为 Modal 会被 app.use(Modal) 调用作为一个插件，所以都放在plugins目录下
组件内容首先实现modal.vue的主体显示内容大致如下
&lt;Teleport to=&quot;body&quot; :disabled=&quot;!isTeleport&quot;&gt;    &lt;div v-if=&quot;modelValue&quot; class=&quot;modal&quot;&gt;        &lt;div             class=&quot;mask&quot;             :style=&quot;style&quot;             @click=&quot;maskClose &amp;&amp; !loading &amp;&amp; handleCancel()&quot;             &gt;&lt;/div&gt;        &lt;div class=&quot;modal__main&quot;&gt;            &lt;div class=&quot;modal__title line line--b&quot;&gt;                &lt;span&gt;&#123;&#123; title || t(&quot;r.title&quot;) &#125;&#125;&lt;/span&gt;                &lt;span                      v-if=&quot;close&quot;                      :title=&quot;t(&#x27;r.close&#x27;)&quot;                      class=&quot;close&quot;                      @click=&quot;!loading &amp;&amp; handleCancel()&quot;                      &gt;✕&lt;/span                    &gt;            &lt;/div&gt;            &lt;div class=&quot;modal__content&quot;&gt;                &lt;Content v-if=&quot;typeof content === &#x27;function&#x27;&quot; :render=&quot;content&quot; /&gt;                &lt;slot v-else&gt;                    &#123;&#123; content &#125;&#125;                &lt;/slot&gt;            &lt;/div&gt;            &lt;div class=&quot;modal__btns line line--t&quot;&gt;                &lt;button :disabled=&quot;loading&quot; @click=&quot;handleConfirm&quot;&gt;                    &lt;span class=&quot;loading&quot; v-if=&quot;loading&quot;&gt; ❍ &lt;/span&gt;&#123;&#123; t(&quot;r.confirm&quot;) &#125;&#125;                &lt;/button&gt;                &lt;button @click=&quot;!loading &amp;&amp; handleCancel()&quot;&gt;                    &#123;&#123; t(&quot;r.cancel&quot;) &#125;&#125;                &lt;/button&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/Teleport&gt;

最外层上通过Vue3 Teleport 内置组件进行包裹，其相当于传送门，将里面的内容传送至body之上
并且从DOM结构上来看，把modal该有的内容（遮罩层、标题、内容、底部按钮）都实现了
关于主体内容
&lt;div class=&quot;modal__content&quot;&gt;    &lt;Content v-if=&quot;typeof content===&#x27;function&#x27;&quot;             :render=&quot;content&quot; /&gt;    &lt;slot v-else&gt;        &#123;&#123;content&#125;&#125;    &lt;/slot&gt;&lt;/div&gt;

可以看到根据传入content的类型不同，对应显示不同得到内容
最常见的则是通过调用字符串和默认插槽的形式
// 默认插槽&lt;Modal v-model=&quot;show&quot;       title=&quot;演示 slot&quot;&gt;    &lt;div&gt;hello world~&lt;/div&gt;&lt;/Modal&gt;// 字符串&lt;Modal v-model=&quot;show&quot;       title=&quot;演示 content&quot;       content=&quot;hello world~&quot; /&gt;

通过 API 形式调用Modal组件的时候，content可以使用下面两种

h 函数

$modal.show(&#123;  title: &#x27;演示 h 函数&#x27;,  content(h) &#123;    return h(      &#x27;div&#x27;,      &#123;        style: &#x27;color:red;&#x27;,        onClick: ($event: Event) =&gt; console.log(&#x27;clicked&#x27;, $event.target)      &#125;,      &#x27;hello world ~&#x27;    );  &#125;&#125;);


JSX

$modal.show(&#123;  title: &#x27;演示 jsx 语法&#x27;,  content() &#123;    return (      &lt;div        onClick=&#123;($event: Event) =&gt; console.log(&#x27;clicked&#x27;, $event.target)&#125;      &gt;        hello world ~      &lt;/div&gt;    );  &#125;&#125;);





实现 API 形式那么组件如何实现API形式调用Modal组件呢？
在Vue2中，我们可以借助Vue实例以及Vue.extend的方式获得组件实例，然后挂载到body上
import Modal from &#x27;./Modal.vue&#x27;;const ComponentClass = Vue.extend(Modal);const instance = new ComponentClass(&#123; el: document.createElement(&quot;div&quot;) &#125;);document.body.appendChild(instance.$el);

虽然Vue3移除了Vue.extend方法，但可以通过createVNode实现
import Modal from &#x27;./Modal.vue&#x27;;const container = document.createElement(&#x27;div&#x27;);const vnode = createVNode(Modal);render(vnode, container);const instance = vnode.component;document.body.appendChild(container);

在Vue2中，可以通过this的形式调用全局 API
export default &#123;    install(vue) &#123;       vue.prototype.$create = create    &#125;&#125;

而在 Vue3 的 setup 中已经没有 this 概念了，需要调用app.config.globalProperties挂载到全局
export default &#123;    install(app) &#123;        app.config.globalProperties.$create = create    &#125;&#125;





事件处理下面再看看看Modal组件内部是如何处理「确定」「取消」事件的，既然是Vue3，当然采用Compositon API 形式
// Modal.vuesetup(props, ctx) &#123;  let instance = getCurrentInstance(); // 获得当前组件实例  onBeforeMount(() =&gt; &#123;    instance._hub = &#123;      &#x27;on-cancel&#x27;: () =&gt; &#123;&#125;,      &#x27;on-confirm&#x27;: () =&gt; &#123;&#125;    &#125;;  &#125;);  const handleConfirm = () =&gt; &#123;    ctx.emit(&#x27;on-confirm&#x27;);    instance._hub[&#x27;on-confirm&#x27;]();  &#125;;  const handleCancel = () =&gt; &#123;    ctx.emit(&#x27;on-cancel&#x27;);    ctx.emit(&#x27;update:modelValue&#x27;, false);    instance._hub[&#x27;on-cancel&#x27;]();  &#125;;  return &#123;    handleConfirm,    handleCancel  &#125;;&#125;

在上面代码中，可以看得到除了使用传统emit的形式使父组件监听，还可通过_hub属性中添加 on-cancel，on-confirm方法实现在API中进行监听
app.config.globalProperties.$modal = &#123;   show(&#123;&#125;) &#123;     /* 监听 确定、取消 事件 */   &#125;&#125;



下面再来目睹下_hub是如何实现
// index.tsapp.config.globalProperties.$modal = &#123;    show(&#123;        /* 其他选项 */        onConfirm,        onCancel    &#125;) &#123;        /* ... */        const &#123; props, _hub &#125; = instance;        const _closeModal = () =&gt; &#123;            props.modelValue = false;            container.parentNode!.removeChild(container);        &#125;;        // 往 _hub 新增事件的具体实现        Object.assign(_hub, &#123;            async &#x27;on-confirm&#x27;() &#123;            if (onConfirm) &#123;                const fn = onConfirm();                // 当方法返回为 Promise                if (fn &amp;&amp; fn.then) &#123;                    try &#123;                        props.loading = true;                        await fn;                        props.loading = false;                        _closeModal();                    &#125; catch (err) &#123;                        // 发生错误时，不关闭弹框                        console.error(err);                        props.loading = false;                    &#125;                &#125; else &#123;                    _closeModal();                &#125;            &#125; else &#123;                _closeModal();            &#125;        &#125;,            &#x27;on-cancel&#x27;() &#123;                onCancel &amp;&amp; onCancel();                _closeModal();            &#125;    &#125;);&#125;&#125;;



其他完善关于组件实现国际化、与typsScript结合，大家可以根据自身情况在此基础上进行更改
参考文献
https://segmentfault.com/a/1190000038928664

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3.0性能提升主要是通过哪几方面体现的？</title>
    <url>/2025/01/13/vue3-performance/</url>
    <content><![CDATA[ 
一、编译阶段回顾Vue2，我们知道每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把用到的数据property记录为依赖，当依赖发生改变，触发setter，则会通知watcher，从而使关联的组件重新渲染
 
试想一下，一个组件结构如下图
&lt;template&gt;    &lt;div id=&quot;content&quot;&gt;        &lt;p class=&quot;text&quot;&gt;静态文本&lt;/p&gt;        &lt;p class=&quot;text&quot;&gt;静态文本&lt;/p&gt;        &lt;p class=&quot;text&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;        &lt;p class=&quot;text&quot;&gt;静态文本&lt;/p&gt;        ...        &lt;p class=&quot;text&quot;&gt;静态文本&lt;/p&gt;    &lt;/div&gt;&lt;/template&gt;

可以看到，组件内部只有一个动态节点，剩余一堆都是静态节点，所以这里很多 diff 和遍历其实都是不需要的，造成性能浪费
因此，Vue3在编译阶段，做了进一步优化。主要有如下：

diff算法优化
静态提升
事件监听缓存
SSR优化

diff算法优化vue3在diff算法中相比vue2增加了静态标记
关于这个静态标记，其作用是为了会发生变化的地方添加一个flag标记，下次发生变化的时候直接找该地方进行比较
下图这里，已经标记静态节点的p标签在diff过程中则不会比较，把性能进一步提高
 
关于静态类型枚举如下
export const enum PatchFlags &#123;  TEXT = 1,// 动态的文本节点  CLASS = 1 &lt;&lt; 1,  // 2 动态的 class  STYLE = 1 &lt;&lt; 2,  // 4 动态的 style  PROPS = 1 &lt;&lt; 3,  // 8 动态属性，不包括类名和样式  FULL_PROPS = 1 &lt;&lt; 4,  // 16 动态 key，当 key 变化时需要完整的 diff 算法做比较  HYDRATE_EVENTS = 1 &lt;&lt; 5,  // 32 表示带有事件监听器的节点  STABLE_FRAGMENT = 1 &lt;&lt; 6,   // 64 一个不会改变子节点顺序的 Fragment  KEYED_FRAGMENT = 1 &lt;&lt; 7, // 128 带有 key 属性的 Fragment  UNKEYED_FRAGMENT = 1 &lt;&lt; 8, // 256 子节点没有 key 的 Fragment  NEED_PATCH = 1 &lt;&lt; 9,   // 512  DYNAMIC_SLOTS = 1 &lt;&lt; 10,  // 动态 solt  HOISTED = -1,  // 特殊标志是负整数表示永远不会用作 diff  BAIL = -2 // 一个特殊的标志，指代差异算法&#125;



静态提升Vue3中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用
这样就免去了重复的创建节点，大型应用会受益于这个改动，免去了重复的创建操作，优化了运行时候的内存占用
&lt;span&gt;你好&lt;/span&gt;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;

没有做静态提升之前
export function render(_ctx, _cache, $props, $setup, $data, $options) &#123;  return (_openBlock(), _createBlock(_Fragment, null, [    _createVNode(&quot;span&quot;, null, &quot;你好&quot;),    _createVNode(&quot;div&quot;, null, _toDisplayString(_ctx.message), 1 /* TEXT */)  ], 64 /* STABLE_FRAGMENT */))&#125;

做了静态提升之后
const _hoisted_1 = /*#__PURE__*/_createVNode(&quot;span&quot;, null, &quot;你好&quot;, -1 /* HOISTED */)export function render(_ctx, _cache, $props, $setup, $data, $options) &#123;  return (_openBlock(), _createBlock(_Fragment, null, [    _hoisted_1,    _createVNode(&quot;div&quot;, null, _toDisplayString(_ctx.message), 1 /* TEXT */)  ], 64 /* STABLE_FRAGMENT */))&#125;// Check the console for the AST

静态内容_hoisted_1被放置在render 函数外，每次渲染的时候只要取 _hoisted_1 即可
同时 _hoisted_1 被打上了 PatchFlag ，静态标记值为 -1 ，特殊标志是负整数表示永远不会用于 Diff
事件监听缓存默认情况下绑定事件行为会被视为动态绑定，所以每次都会去追踪它的变化
&lt;div&gt;  &lt;button @click = &#x27;onClick&#x27;&gt;点我&lt;/button&gt;&lt;/div&gt;

没开启事件监听器缓存
export const render = /*#__PURE__*/_withId(function render(_ctx, _cache, $props, $setup, $data, $options) &#123;  return (_openBlock(), _createBlock(&quot;div&quot;, null, [    _createVNode(&quot;button&quot;, &#123; onClick: _ctx.onClick &#125;, &quot;点我&quot;, 8 /* PROPS */, [&quot;onClick&quot;])                                             // PROPS=1&lt;&lt;3,// 8 //动态属性，但不包含类名和样式  ]))&#125;)

开启事件侦听器缓存后
export function render(_ctx, _cache, $props, $setup, $data, $options) &#123;  return (_openBlock(), _createBlock(&quot;div&quot;, null, [    _createVNode(&quot;button&quot;, &#123;      onClick: _cache[1] || (_cache[1] = (...args) =&gt; (_ctx.onClick(...args)))    &#125;, &quot;点我&quot;)  ]))&#125;

上述发现开启了缓存后，没有了静态标记。也就是说下次diff算法的时候直接使用
SSR优化当静态内容大到一定量级时候，会用createStaticVNode方法在客户端去生成一个static node，这些静态node，会被直接innerHtml，就不需要创建对象，然后根据对象渲染
div&gt;	&lt;div&gt;		&lt;span&gt;你好&lt;/span&gt;	&lt;/div&gt;	...  // 很多个静态属性	&lt;div&gt;		&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;	&lt;/div&gt;&lt;/div&gt;

编译后
import &#123; mergeProps as _mergeProps &#125; from &quot;vue&quot;import &#123; ssrRenderAttrs as _ssrRenderAttrs, ssrInterpolate as _ssrInterpolate &#125; from &quot;@vue/server-renderer&quot;export function ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) &#123;  const _cssVars = &#123; style: &#123; color: _ctx.color &#125;&#125;  _push(`&lt;div$&#123;    _ssrRenderAttrs(_mergeProps(_attrs, _cssVars))  &#125;&gt;&lt;div&gt;&lt;span&gt;你好&lt;/span&gt;...&lt;div&gt;&lt;span&gt;你好&lt;/span&gt;&lt;div&gt;&lt;span&gt;$&#123;    _ssrInterpolate(_ctx.message)  &#125;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;`)&#125;



二、源码体积相比Vue2，Vue3整体体积变小了，除了移出一些不常用的API，再重要的是Tree shanking
任何一个函数，如ref、reavtived、computed等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小
import &#123; computed, defineComponent, ref &#125; from &#x27;vue&#x27;;export default defineComponent(&#123;    setup(props, context) &#123;        const age = ref(18)        let state = reactive(&#123;            name: &#x27;test&#x27;        &#125;)        const readOnlyAge = computed(() =&gt; age.value++) // 19        return &#123;            age,            state,            readOnlyAge        &#125;    &#125;&#125;);



三、响应式系统vue2中采用 defineProperty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式
vue3采用proxy重写了响应式系统，因为proxy可以对整个对象进行监听，所以不需要深度遍历

可以监听动态属性的添加
可以监听到数组的索引和数组length属性
可以监听删除属性

关于这两个 API 具体的不同，我们下篇文章会进行一个更加详细的介绍
参考文献
https://juejin.cn/post/6903171037211557895

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？</title>
    <url>/2025/01/14/vue3-proxy/</url>
    <content><![CDATA[ 
一、Object.defineProperty定义：Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象
为什么能实现响应式通过defineProperty 两个属性，get及set

get

属性的 getter 函数，当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值

set

属性的 setter 函数，当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。默认为 undefined
下面通过代码展示：
定义一个响应式函数defineReactive
function update() &#123;    app.innerText = obj.foo&#125;function defineReactive(obj, key, val) &#123;    Object.defineProperty(obj, key, &#123;        get() &#123;            console.log(`get $&#123;key&#125;:$&#123;val&#125;`);            return val        &#125;,        set(newVal) &#123;            if (newVal !== val) &#123;                val = newVal                update()            &#125;        &#125;    &#125;)&#125;

调用defineReactive，数据发生变化触发update方法，实现数据响应式
const obj = &#123;&#125;defineReactive(obj, &#x27;foo&#x27;, &#x27;&#x27;)setTimeout(()=&gt;&#123;    obj.foo = new Date().toLocaleTimeString()&#125;,1000)

在对象存在多个key情况下，需要进行遍历
function observe(obj) &#123;    if (typeof obj !== &#x27;object&#x27; || obj == null) &#123;        return    &#125;    Object.keys(obj).forEach(key =&gt; &#123;        defineReactive(obj, key, obj[key])    &#125;)&#125;

如果存在嵌套对象的情况，还需要在defineReactive中进行递归
function defineReactive(obj, key, val) &#123;    observe(val)    Object.defineProperty(obj, key, &#123;        get() &#123;            console.log(`get $&#123;key&#125;:$&#123;val&#125;`);            return val        &#125;,        set(newVal) &#123;            if (newVal !== val) &#123;                val = newVal                update()            &#125;        &#125;    &#125;)&#125;

当给key赋值为对象的时候，还需要在set属性中进行递归
set(newVal) &#123;    if (newVal !== val) &#123;        observe(newVal) // 新值是对象的情况        notifyUpdate()    &#125;&#125;

上述例子能够实现对一个对象的基本响应式，但仍然存在诸多问题
现在对一个对象进行删除与添加属性操作，无法劫持到
const obj = &#123;    foo: &quot;foo&quot;,    bar: &quot;bar&quot;&#125;observe(obj)delete obj.foo // no okobj.jar = &#x27;xxx&#x27; // no ok

当我们对一个数组进行监听的时候，并不那么好使了
const arrData = [1,2,3,4,5];arrData.forEach((val,index)=&gt;&#123;    defineProperty(arrData,index,val)&#125;)arrData.push() // no okarrData.pop()  // no okarrDate[0] = 99 // ok

可以看到数据的api无法劫持到，从而无法实现数据响应式，
所以在Vue2中，增加了set、delete API，并且对数组api方法进行一个重写
还有一个问题则是，如果存在深层的嵌套对象关系，需要深层的进行监听，造成了性能的极大问题
小结
检测不到对象属性的添加和删除
数组API方法无法监听到
需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题

二、proxyProxy的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性了
在ES6系列中，我们详细讲解过Proxy的使用，就不再述说了
下面通过代码进行展示：
定义一个响应式方法reactive
function reactive(obj) &#123;    if (typeof obj !== &#x27;object&#x27; &amp;&amp; obj != null) &#123;        return obj    &#125;    // Proxy相当于在对象外层加拦截    const observed = new Proxy(obj, &#123;        get(target, key, receiver) &#123;            const res = Reflect.get(target, key, receiver)            console.log(`获取$&#123;key&#125;:$&#123;res&#125;`)            return res        &#125;,        set(target, key, value, receiver) &#123;            const res = Reflect.set(target, key, value, receiver)            console.log(`设置$&#123;key&#125;:$&#123;value&#125;`)            return res        &#125;,        deleteProperty(target, key) &#123;            const res = Reflect.deleteProperty(target, key)            console.log(`删除$&#123;key&#125;:$&#123;res&#125;`)            return res        &#125;    &#125;)    return observed&#125;

测试一下简单数据的操作，发现都能劫持
const state = reactive(&#123;    foo: &#x27;foo&#x27;&#125;)// 1.获取state.foo // ok// 2.设置已存在属性state.foo = &#x27;fooooooo&#x27; // ok// 3.设置不存在属性state.dong = &#x27;dong&#x27; // ok// 4.删除属性delete state.dong // ok

再测试嵌套对象情况，这时候发现就不那么 OK 了
const state = reactive(&#123;    bar: &#123; a: 1 &#125;&#125;)// 设置嵌套对象属性state.bar.a = 10 // no ok

如果要解决，需要在get之上再进行一层代理
function reactive(obj) &#123;    if (typeof obj !== &#x27;object&#x27; &amp;&amp; obj != null) &#123;        return obj    &#125;    // Proxy相当于在对象外层加拦截    const observed = new Proxy(obj, &#123;        get(target, key, receiver) &#123;            const res = Reflect.get(target, key, receiver)            console.log(`获取$&#123;key&#125;:$&#123;res&#125;`)            return isObject(res) ? reactive(res) : res        &#125;,    return observed&#125;


三、总结Object.defineProperty只能遍历对象属性进行劫持
function observe(obj) &#123;    if (typeof obj !== &#x27;object&#x27; || obj == null) &#123;        return    &#125;    Object.keys(obj).forEach(key =&gt; &#123;        defineReactive(obj, key, obj[key])    &#125;)&#125;

Proxy直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的
function reactive(obj) &#123;    if (typeof obj !== &#x27;object&#x27; &amp;&amp; obj != null) &#123;        return obj    &#125;    // Proxy相当于在对象外层加拦截    const observed = new Proxy(obj, &#123;        get(target, key, receiver) &#123;            const res = Reflect.get(target, key, receiver)            console.log(`获取$&#123;key&#125;:$&#123;res&#125;`)            return res        &#125;,        set(target, key, value, receiver) &#123;            const res = Reflect.set(target, key, value, receiver)            console.log(`设置$&#123;key&#125;:$&#123;value&#125;`)            return res        &#125;,        deleteProperty(target, key) &#123;            const res = Reflect.deleteProperty(target, key)            console.log(`删除$&#123;key&#125;:$&#123;res&#125;`)            return res        &#125;    &#125;)    return observed&#125;

Proxy可以直接监听数组的变化（push、shift、splice）
const obj = [1,2,3]const proxtObj = reactive(obj)obj.psuh(4) // ok

Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等，这是Object.defineProperty不具备的
正因为defineProperty自身的缺陷，导致Vue2在实现响应式过程需要实现其他的方法辅助（如重写数组方法、增加额外set、delete方法）
// 数组重写const originalProto = Array.prototypeconst arrayProto = Object.create(originalProto)[&#x27;push&#x27;, &#x27;pop&#x27;, &#x27;shift&#x27;, &#x27;unshift&#x27;, &#x27;splice&#x27;, &#x27;reverse&#x27;, &#x27;sort&#x27;].forEach(method =&gt; &#123;  arrayProto[method] = function () &#123;    originalProto[method].apply(this.arguments)    dep.notice()  &#125;&#125;);// set、deleteVue.set(obj,&#x27;bar&#x27;,&#x27;newbar&#x27;)Vue.delete(obj),&#x27;bar&#x27;)

Proxy 不兼容IE，也没有 polyfill, defineProperty 能支持到IE9
参考文献
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>说说Vue 3.0中Treeshaking特性？举例说明一下？</title>
    <url>/2025/01/12/vue3-treeshaking/</url>
    <content><![CDATA[ 
一、是什么Tree shaking 是一种通过清除多余代码方式来优化项目打包体积的技术，专业术语叫 Dead code elimination
简单来讲，就是在保持代码运行结果不变的前提下，去除无用的代码
如果把代码打包比作制作蛋糕，传统的方式是把鸡蛋（带壳）全部丢进去搅拌，然后放入烤箱，最后把（没有用的）蛋壳全部挑选并剔除出去
而treeshaking则是一开始就把有用的蛋白蛋黄（import）放入搅拌，最后直接作出蛋糕
也就是说 ，tree shaking 其实是找出使用的代码
在Vue2中，无论我们使用什么功能，它们最终都会出现在生产代码中。主要原因是Vue实例在项目中是单例的，捆绑程序无法检测到该对象的哪些属性在代码中被使用到
import Vue from &#x27;vue&#x27; Vue.nextTick(() =&gt; &#123;&#125;)

而Vue3源码引入tree shaking特性，将全局 API 进行分块。如果您不使用其某些功能，它们将不会包含在您的基础包中
import &#123; nextTick, observable &#125; from &#x27;vue&#x27; nextTick(() =&gt; &#123;&#125;)



二、如何做Tree shaking是基于ES6模板语法（import与exports），主要是借助ES6模块的静态编译思想，在编译时就能确定模块的依赖关系，以及输入和输出的变量
Tree shaking无非就是做了两件事：

编译阶段利用ES6 Module判断哪些模块已经加载
判断那些模块和变量未被使用或者引用，进而删除对应代码

下面就来举个例子：
通过脚手架vue-cli安装Vue2与Vue3项目
vue create vue-demo

Vue2 项目组件中使用data属性
&lt;script&gt;    export default &#123;        data: () =&gt; (&#123;            count: 1,        &#125;),    &#125;;&lt;/script&gt;

对项目进行打包，体积如下图

为组件设置其他属性（compted、watch）
export default &#123;    data: () =&gt; (&#123;        question:&quot;&quot;,         count: 1,    &#125;),    computed: &#123;        double: function () &#123;            return this.count * 2;        &#125;,    &#125;,    watch: &#123;        question: function (newQuestion, oldQuestion) &#123;            this.answer = &#x27;xxxx&#x27;        &#125;&#125;;

再一次打包，发现打包出来的体积并没有变化

Vue3 项目组件中简单使用
import &#123; reactive, defineComponent &#125; from &quot;vue&quot;;export default defineComponent(&#123;  setup() &#123;    const state = reactive(&#123;      count: 1,    &#125;);    return &#123;      state,    &#125;;  &#125;,&#125;);

将项目进行打包

在组件中引入computed和watch
import &#123; reactive, defineComponent, computed, watch &#125; from &quot;vue&quot;;export default defineComponent(&#123;  setup() &#123;    const state = reactive(&#123;      count: 1,    &#125;);    const double = computed(() =&gt; &#123;      return state.count * 2;    &#125;);    watch(      () =&gt; state.count,      (count, preCount) =&gt; &#123;        console.log(count);        console.log(preCount);      &#125;    );    return &#123;      state,      double,    &#125;;  &#125;,&#125;);

再次对项目进行打包，可以看到在引入computer和watch之后，项目整体体积变大了
 
三、作用通过Tree shaking，Vue3给我们带来的好处是：

减少程序体积（更小）
减少程序执行时间（更快）
便于将来对程序架构进行优化（更友好）

参考文献
https://segmentfault.com/a/1190000038962700

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>面试官：vue3有了解过吗？能说说跟vue2的区别吗？</title>
    <url>/2025/01/12/vue3-vue3-vue2/</url>
    <content><![CDATA[ 
一、Vue3介绍关于vue3的重构背景，尤大是这样说的：
「Vue 新版本的理念成型于 2018 年末，当时 Vue 2 的代码库已经有两岁半了。比起通用软件的生命周期来这好像也没那么久，但在这段时期，前端世界已经今昔非比了
在我们更新（和重写）Vue 的主要版本时，主要考虑两点因素：首先是新的 JavaScript 语言特性在主流浏览器中的受支持水平；其次是当前代码库中随时间推移而逐渐暴露出来的一些设计和架构问题」
简要就是：

利用新的语言特性(es6)
解决架构问题

哪些变化 
从上图中，我们可以概览Vue3的新特性，如下：

速度更快
体积减少
更易维护
更接近原生
更易使用

速度更快vue3相比vue2

重写了虚拟Dom实现

编译模板的优化

更高效的组件初始化

undate性能提高1.3~2倍

SSR速度提高了2~3倍


 
体积更小通过webpack的tree-shaking功能，可以将无用模块“剪辑”，仅打包需要的
能够tree-shaking，有两大好处：

对开发人员，能够对vue实现更多其他的功能，而不必担忧整体体积过大

对使用者，打包出来的包体积变小了


vue可以开发出更多其他的功能，而不必担忧vue打包出来的整体体积过多
  
更易维护compositon Api
可与现有的Options API一起使用
灵活的逻辑组合与复用
Vue3模块可以和其他框架搭配使用

 
更好的Typescript支持VUE3是基于typescipt编写的，可以享受到自动的类型定义提示

编译器重写
更接近原生可以自定义渲染 API

更易使用响应式 Api 暴露出来

轻松识别组件重新渲染原因

二、Vue3新增特性Vue 3 中需要关注的一些新功能包括：

framents
Teleport
composition Api
createRenderer

framents在 Vue3.x 中，组件现在支持有多个根节点
&lt;!-- Layout.vue --&gt;&lt;template&gt;  &lt;header&gt;...&lt;/header&gt;  &lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt;  &lt;footer&gt;...&lt;/footer&gt;&lt;/template&gt;



TeleportTeleport 是一种能够将我们的模板移动到 DOM 中 Vue app 之外的其他位置的技术，就有点像哆啦A梦的“任意门”
在vue2中，像 modals,toast 等这样的元素，如果我们嵌套在 Vue 的某个组件内部，那么处理嵌套组件的定位、z-index 和样式就会变得很困难
通过Teleport，我们可以在组件的逻辑位置写模板代码，然后在 Vue 应用范围之外渲染它
&lt;button @click=&quot;showToast&quot; class=&quot;btn&quot;&gt;打开 toast&lt;/button&gt;&lt;!-- to 属性就是目标位置 --&gt;&lt;teleport to=&quot;#teleport-target&quot;&gt;    &lt;div v-if=&quot;visible&quot; class=&quot;toast-wrap&quot;&gt;        &lt;div class=&quot;toast-msg&quot;&gt;我是一个 Toast 文案&lt;/div&gt;    &lt;/div&gt;&lt;/teleport&gt;



createRenderer通过createRenderer，我们能够构建自定义渲染器，我们能够将 vue 的开发模型扩展到其他平台
我们可以将其生成在canvas画布上

关于createRenderer，我们了解下基本使用，就不展开讲述了
import &#123; createRenderer &#125; from &#x27;@vue/runtime-core&#x27;const &#123; render, createApp &#125; = createRenderer(&#123;  patchProp,  insert,  remove,  createElement,  // ...&#125;)export &#123; render, createApp &#125;export * from &#x27;@vue/runtime-core&#x27;



composition Apicomposition Api，也就是组合式api，通过这种形式，我们能够更加容易维护我们的代码，将相同功能的变量进行一个集中式的管理
 
关于compositon api的使用，这里以下图展开

简单使用:
export default &#123;    setup() &#123;        const count = ref(0)        const double = computed(() =&gt; count.value * 2)        function increment() &#123;            count.value++        &#125;        onMounted(() =&gt; console.log(&#x27;component mounted!&#x27;))        return &#123;            count,            double,            increment        &#125;    &#125;&#125;



三、非兼容变更Global API
全局 Vue API 已更改为使用应用程序实例
全局和内部 API 已经被重构为可 tree-shakable

模板指令
组件上 v-model 用法已更改
&lt;template v-for&gt;和 非 v-for节点上key用法已更改
在同一元素上使用的 v-if 和 v-for 优先级已更改
v-bind=&quot;object&quot; 现在排序敏感
v-for 中的 ref 不再注册 ref 数组

组件
只能使用普通函数创建功能组件
functional 属性在单文件组件 (SFC) 
异步组件现在需要 defineAsyncComponent 方法来创建

渲染函数
渲染函数API改变
$scopedSlots property 已删除，所有插槽都通过 $slots 作为函数暴露
自定义指令 API 已更改为与组件生命周期一致
一些转换 class 被重命名了：
v-enter -&gt; v-enter-from
v-leave -&gt; v-leave-from


组件 watch 选项和实例方法 $watch不再支持点分隔字符串路径，请改用计算函数作为参数
在 Vue 2.x 中，应用根容器的 outerHTML 将替换为根组件模板 (如果根组件没有模板&#x2F;渲染选项，则最终编译为模板)。VUE3.x 现在使用应用程序容器的 innerHTML。

其他小改变
destroyed 生命周期选项被重命名为 unmounted
beforeDestroy 生命周期选项被重命名为 beforeUnmount
[prop default工厂函数不再有权访问 this 是上下文
自定义指令 API 已更改为与组件生命周期一致
data 应始终声明为函数
来自 mixin 的 data 选项现在可简单地合并
attribute 强制策略已更改
一些过渡 class 被重命名
组建 watch 选项和实例方法 $watch不再支持以点分隔的字符串路径。请改用计算属性函数作为参数。
&lt;template&gt; 没有特殊指令的标记 (v-if/else-if/else、v-for 或 v-slot) 现在被视为普通元素，并将生成原生的 &lt;template&gt; 元素，而不是渲染其内部内容。
在 Vue 2.x 中，应用根容器的 outerHTML 将替换为根组件模板 (如果根组件没有模板&#x2F;渲染选项，则最终编译为模板)。Vue 3.x 现在使用应用容器的 innerHTML，这意味着容器本身不再被视为模板的一部分。

移除 API
keyCode 支持作为 v-on 的修饰符
$on，$off 和 $once 实例方法
过滤filter
内联模板 attribute
$destroy 实例方法。用户不应再手动管理单个 Vue 组件的生命周期。

参考文献
https://vue3js.cn/docs/zh/guide/migration/introduction.html#%E6%A8%A1%E6%9D%BF%E6%8C%87%E4%BB%A4
https://composition-api.vuejs.org/zh/#api-%E4%BB%8B%E7%BB%8D

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack的热更新是如何做到的？原理是什么？</title>
    <url>/2024/01/17/webpack-HMR/</url>
    <content><![CDATA[ 
一、是什么HMR 全称 Hot Module Replacement，可以理解为模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用
例如，我们在应用运行过程中修改了某个模块，通过自动刷新会导致整个应用的整体刷新，那页面中的状态信息都会丢失
如果使用的是 HMR，就可以实现只将修改的模块实时替换至应用中，不必完全刷新整个应用
在webpack中配置开启热模块也非常的简单，如下代码：
const webpack = require(&#x27;webpack&#x27;)module.exports = &#123;  // ...  devServer: &#123;    // 开启 HMR 特性    hot: true    // hotOnly: true  &#125;&#125;

通过上述这种配置，如果我们修改并保存css文件，确实能够以不刷新的形式更新到页面中
但是，当我们修改并保存js文件之后，页面依旧自动刷新了，这里并没有触发热模块
所以，HMR 并不像 Webpack 的其他特性一样可以开箱即用，需要有一些额外的操作
我们需要去指定哪些模块发生更新时进行HRM，如下代码：
if(module.hot)&#123;    module.hot.accept(&#x27;./util.js&#x27;,()=&gt;&#123;        console.log(&quot;util.js更新了&quot;)    &#125;)&#125;



二、实现原理首先来看看一张图，如下：
 

Webpack Compile：将 JS 源代码编译成 bundle.js
HMR Server：用来将热更新的文件输出给 HMR Runtime
Bundle Server：静态资源文件服务器，提供文件访问路径
HMR Runtime：socket服务器，会被注入到浏览器，更新文件的变化
bundle.js：构建输出的文件
在HMR Runtime 和 HMR Server之间建立 websocket，即图上4号线，用于实时更新文件变化

上面图中，可以分成两个阶段：

启动阶段为上图 1 - 2 - A - B

在编写未经过webpack打包的源代码后，Webpack Compile 将源代码和 HMR Runtime 一起编译成 bundle 文件，传输给 Bundle Server 静态资源服务器

更新阶段为上图 1 - 2 - 3 - 4

当某一个文件或者模块发生变化时，webpack 监听到文件变化对文件重新编译打包，编译生成唯一的hash值，这个hash 值用来作为下一次热更新的标识
根据变化的内容生成两个补丁文件：manifest（包含了 hash 和 chundId ，用来说明变化的内容）和 chunk.js 模块
由于socket服务器在HMR Runtime 和 HMR Server之间建立 websocket链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的hash值，如下图的h属性，作为下一次热更细的标识
 
在浏览器接受到这条消息之前，浏览器已经在上一次 socket 消息中已经记住了此时的 hash 标识，这时候我们会创建一个 ajax 去服务端请求获取到变化内容的 manifest 文件
mainfest文件包含重新build生成的hash值，以及变化的模块，对应上图的c属性
浏览器根据 manifest 文件获取模块变化的内容，从而触发render流程，实现局部模块更新
 
三、总结关于webpack热模块更新的总结如下：

通过webpack-dev-server创建两个服务器：提供静态资源的服务（express）和Socket服务
express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）
socket server 是一个 websocket 的长连接，双方可以通信
当 socket server 监听到对应的模块发生变化时，会生成两个文件.json（manifest文件）和.js文件（update chunk）
通过长连接，socket server 可以直接将这两个文件主动发送给客户端（浏览器）
浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新

参考文献
https://zhuanlan.zhihu.com/p/138446061
https://github.com/Jocs/jocs.github.io/issues/15
https://juejin.cn/post/6844904134697549832
https://vue3js.cn/interview/

]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>如何提高webpack的构建速度？</title>
    <url>/2024/01/20/webpack-improve-build/</url>
    <content><![CDATA[ 
一、背景随着我们的项目涉及到页面越来越多，功能和业务代码也会随着越多，相应的 webpack 的构建时间也会越来越久
构建时间与我们日常开发效率密切相关，当我们本地开发启动 devServer 或者 build 的时候，如果时间过长，会大大降低我们的工作效率
所以，优化webpack 构建速度是十分重要的环节
二、如何优化常见的提升构建速度的手段有如下：

优化 loader 配置
合理使用 resolve.extensions
优化 resolve.modules
优化 resolve.alias
使用 DLLPlugin 插件
使用 cache-loader
terser 启动多线程
合理使用 sourceMap

优化loader配置在使用loader时，可以通过配置include、exclude、test属性来匹配文件，接触include、exclude规定哪些匹配应用loader
如采用 ES6 的项目为例，在配置 babel-loader 时，可以这样：
module.exports = &#123;  module: &#123;    rules: [      &#123;        // 如果项目源码中只有 js 文件就不要写成 /\.jsx?$/，提升正则表达式性能        test: /\.js$/,        // babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启        use: [&#x27;babel-loader?cacheDirectory&#x27;],        // 只对项目根目录下的 src 目录中的文件采用 babel-loader        include: path.resolve(__dirname, &#x27;src&#x27;),      &#125;,    ]  &#125;,&#125;;



合理使用 resolve.extensions在开发中我们会有各种各样的模块依赖，这些模块可能来自于自己编写的代码，也可能来自第三方库， resolve可以帮助webpack从每个 require/import 语句中，找到需要引入到合适的模块代码
通过resolve.extensions是解析到文件时自动添加拓展名，默认情况如下：
module.exports = &#123;    ...    extensions:[&quot;.warm&quot;,&quot;.mjs&quot;,&quot;.js&quot;,&quot;.json&quot;]&#125;

当我们引入文件的时候，若没有文件后缀名，则会根据数组内的值依次查找
当我们配置的时候，则不要随便把所有后缀都写在里面，这会调用多次文件的查找，这样就会减慢打包速度
优化 resolve.modulesresolve.modules 用于配置 webpack 去哪些目录下寻找第三方模块。默认值为[&#39;node_modules&#39;]，所以默认会从node_modules中查找文件当安装的第三方模块都放在项目根目录下的 ./node_modules 目录下时，所以可以指明存放第三方模块的绝对路径，以减少寻找，配置如下：
module.exports = &#123;  resolve: &#123;    // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤    // 其中 __dirname 表示当前工作目录，也就是项目根目录    modules: [path.resolve(__dirname, &#x27;node_modules&#x27;)]  &#125;,&#125;;



优化 resolve.aliasalias给一些常用的路径起一个别名，特别当我们的项目目录结构比较深的时候，一个文件的路径可能是./../../的形式
通过配置alias以减少查找过程
module.exports = &#123;    ...    resolve:&#123;        alias:&#123;            &quot;@&quot;:path.resolve(__dirname,&#x27;./src&#x27;)        &#125;    &#125;&#125;





使用 DLLPlugin 插件DLL全称是 动态链接库，是为软件在winodw种实现共享函数库的一种实现方式，而Webpack也内置了DLL的功能，为的就是可以共享，不经常改变的代码，抽成一个共享的库。这个库在之后的编译过程中，会被引入到其他项目的代码中
使用步骤分成两部分：

打包一个 DLL 库
引入 DLL 库

打包一个 DLL 库webpack内置了一个DllPlugin可以帮助我们打包一个DLL的库文件
module.exports = &#123;    ...    plugins:[        new webpack.DllPlugin(&#123;            name:&#x27;dll_[name]&#x27;,            path:path.resolve(__dirname,&quot;./dll/[name].mainfest.json&quot;)        &#125;)    ]&#125;



引入 DLL 库使用 webpack 自带的 DllReferencePlugin 插件对 mainfest.json 映射文件进行分析，获取要使用的DLL库
然后再通过AddAssetHtmlPlugin插件，将我们打包的DLL库引入到Html模块中
module.exports = &#123;    ...    new webpack.DllReferencePlugin(&#123;        context:path.resolve(__dirname,&quot;./dll/dll_react.js&quot;),        mainfest:path.resolve(__dirname,&quot;./dll/react.mainfest.json&quot;)    &#125;),    new AddAssetHtmlPlugin(&#123;        outputPath:&quot;./auto&quot;,        filepath:path.resolve(__dirname,&quot;./dll/dll_react.js&quot;)    &#125;)&#125;



使用 cache-loader在一些性能开销较大的 loader 之前添加 cache-loader，以将结果缓存到磁盘里，显著提升二次构建速度
保存和读取这些缓存文件会有一些时间开销，所以请只对性能开销较大的 loader 使用此 loader
module.exports = &#123;    module: &#123;        rules: [            &#123;                test: /\.ext$/,                use: [&#x27;cache-loader&#x27;, ...loaders],                include: path.resolve(&#x27;src&#x27;),            &#125;,        ],    &#125;,&#125;;



terser 启动多线程使用多进程并行运行来提高构建速度
module.exports = &#123;  optimization: &#123;    minimizer: [      new TerserPlugin(&#123;        parallel: true,      &#125;),    ],  &#125;,&#125;;



合理使用 sourceMap打包生成  sourceMap 的时候，如果信息越详细，打包速度就会越慢。对应属性取值如下所示：

三、总结可以看到，优化webpack构建的方式有很多，主要可以从优化搜索时间、缩小文件搜索范围、减少不必要的编译等方面入手
参考文献
https://github.com/ly2011/blog/issues/44
https://xie.infoq.cn/article/541418eb82a674741a0ad8865
https://zhuanlan.zhihu.com/p/139498741
https://vue3js.cn/interview

]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack的构建流程</title>
    <url>/2024/02/19/webpack-build-process/</url>
    <content><![CDATA[
一、运行流程webpack 的运行流程是一个串行的过程，它的工作流程就是将各个插件串联起来
在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条webpack机制中，去改变webpack的运作，使得整个系统扩展性良好
从启动到结束会依次执行以下三大步骤：

初始化流程：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数
编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理
输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统

 
初始化流程从配置文件和 Shell 语句中读取与合并参数，得出最终的参数
配置文件默认下为webpack.config.js，也或者通过命令的形式指定配置文件，主要作用是用于激活webpack的加载项和插件
关于文件配置内容分析，如下注释：
var path = require(&#x27;path&#x27;);var node_modules = path.resolve(__dirname, &#x27;node_modules&#x27;);var pathToReact = path.resolve(node_modules, &#x27;react/dist/react.min.js&#x27;);module.exports = &#123;  // 入口文件，是模块构建的起点，同时每一个入口文件对应最后生成的一个 chunk。  entry: &#x27;./path/to/my/entry/file.js&#x27;，  // 文件路径指向(可加快打包过程)。  resolve: &#123;    alias: &#123;      &#x27;react&#x27;: pathToReact    &#125;  &#125;,  // 生成文件，是模块构建的终点，包括输出文件与输出路径。  output: &#123;    path: path.resolve(__dirname, &#x27;build&#x27;),    filename: &#x27;[name].js&#x27;  &#125;,  // 这里配置了处理各模块的 loader ，包括 css 预处理 loader ，es6 编译 loader，图片处理 loader。  module: &#123;    loaders: [      &#123;        test: /\.js$/,        loader: &#x27;babel&#x27;,        query: &#123;          presets: [&#x27;es2015&#x27;, &#x27;react&#x27;]        &#125;      &#125;    ],    noParse: [pathToReact]  &#125;,  // webpack 各插件对象，在 webpack 的事件流中执行对应的方法。  plugins: [    new webpack.HotModuleReplacementPlugin()  ]&#125;;

webpack 将 webpack.config.js 中的各个配置项拷贝到 options 对象中，并加载用户配置的  plugins
完成上述步骤之后，则开始初始化Compiler编译对象，该对象掌控者webpack声明周期，不执行具体的任务，只是进行一些调度工作
class Compiler extends Tapable &#123;    constructor(context) &#123;        super();        this.hooks = &#123;            beforeCompile: new AsyncSeriesHook([&quot;params&quot;]),            compile: new SyncHook([&quot;params&quot;]),            afterCompile: new AsyncSeriesHook([&quot;compilation&quot;]),            make: new AsyncParallelHook([&quot;compilation&quot;]),            entryOption: new SyncBailHook([&quot;context&quot;, &quot;entry&quot;])            // 定义了很多不同类型的钩子        &#125;;        // ...    &#125;&#125;function webpack(options) &#123;  var compiler = new Compiler();  ...// 检查options,若watch字段为true,则开启watch线程  return compiler;&#125;...

Compiler 对象继承自 Tapable，初始化时定义了很多钩子函数
编译构建流程根据配置中的 entry 找出所有的入口文件
module.exports = &#123;  entry: &#x27;./src/file.js&#x27;&#125;

初始化完成后会调用Compiler的run来真正启动webpack编译构建流程，主要流程如下：

compile 开始编译
make 从入口点分析模块及其依赖的模块，创建这些模块对象
build-module 构建模块
seal 封装构建结果
emit 把各个chunk输出到结果文件

compile 编译执行了run方法后，首先会触发compile，主要是构建一个Compilation对象
该对象是编译阶段的主要执行者，主要会依次下述流程：执行模块创建、依赖收集、分块、打包等主要任务的对象
make 编译模块当完成了上述的compilation对象后，就开始从Entry入口文件开始读取，主要执行_addModuleChain()函数，如下：
_addModuleChain(context, dependency, onModule, callback) &#123;   ...   // 根据依赖查找对应的工厂函数   const Dep = /** @type &#123;DepConstructor&#125; */ (dependency.constructor);   const moduleFactory = this.dependencyFactories.get(Dep);      // 调用工厂函数NormalModuleFactory的create来生成一个空的NormalModule对象   moduleFactory.create(&#123;       dependencies: [dependency]       ...   &#125;, (err, module) =&gt; &#123;       ...       const afterBuild = () =&gt; &#123;        this.processModuleDependencies(module, err =&gt; &#123;         if (err) return callback(err);         callback(null, module);           &#125;);    &#125;;              this.buildModule(module, false, null, null, err =&gt; &#123;           ...           afterBuild();       &#125;)   &#125;)&#125;

过程如下：
_addModuleChain中接收参数dependency传入的入口依赖，使用对应的工厂函数NormalModuleFactory.create方法生成一个空的module对象
回调中会把此module存入compilation.modules对象和dependencies.module对象中，由于是入口文件，也会存入compilation.entries中
随后执行buildModule进入真正的构建模块module内容的过程
build module 完成模块编译这里主要调用配置的loaders，将我们的模块转成标准的JS模块
在用 Loader 对一个模块转换完后，使用 acorn 解析转换后的内容，输出对应的抽象语法树（AST），以方便 Webpack 后面对代码的分析
从配置的入口模块开始，分析其 AST，当遇到require等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系
输出流程seal 输出资源seal方法主要是要生成chunks，对chunks进行一系列的优化操作，并生成要输出的代码
webpack 中的 chunk ，可以理解为配置在 entry 中的模块，或者是动态引入的模块
根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表
emit 输出完成在确定好输出内容后，根据配置确定输出的路径和文件名
output: &#123;    path: path.resolve(__dirname, &#x27;build&#x27;),        filename: &#x27;[name].js&#x27;&#125;

在 Compiler 开始生成文件前，钩子 emit 会被执行，这是我们修改最终文件的最后一个机会
从而webpack整个打包过程则结束了
小结 
参考文献
https://github.com/Cosen95/blog/issues/48
https://developer.aliyun.com/article/61047

]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue项目中有封装过axios吗？主要是封装哪方面的？</title>
    <url>/2025/01/16/vue-axios/</url>
    <content><![CDATA[
一、axios是什么axios 是一个轻量的 HTTP客户端
基于 XMLHttpRequest 服务来执行 HTTP 请求，支持丰富的配置，支持 Promise，支持浏览器端和 Node.js 端。自Vue2.0起，尤大宣布取消对 vue-resource 的官方推荐，转而推荐 axios。现在 axios 已经成为大部分 Vue 开发者的首选
特性
从浏览器中创建 XMLHttpRequests
从 node.js 创建 http请求
支持 Promise API
拦截请求和响应
转换请求数据和响应数据
取消请求
自动转换 JSON 数据
客户端支持防御XSRF

基本使用安装
// 项目中安装npm install axios --S// cdn 引入&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;

导入
import axios from &#x27;axios&#x27;

发送请求
axios(&#123;          url:&#x27;xxx&#x27;,    // 设置请求的地址  method:&quot;GET&quot;, // 设置请求方法  params:&#123;      // get请求使用params进行参数凭借,如果是post请求用data    type: &#x27;&#x27;,    page: 1  &#125;&#125;).then(res =&gt; &#123;    // res为后端返回的数据  console.log(res);   &#125;)



并发请求axios.all([])
function getUserAccount() &#123;    return axios.get(&#x27;/user/12345&#x27;);&#125;function getUserPermissions() &#123;    return axios.get(&#x27;/user/12345/permissions&#x27;);&#125;axios.all([getUserAccount(), getUserPermissions()])    .then(axios.spread(function (res1, res2) &#123;     // res1第一个请求的返回的内容，res2第二个请求返回的内容    // 两个请求都执行完成才会执行&#125;));



二、为什么要封装axios 的 API 很友好，你完全可以很轻松地在项目中直接使用。
不过随着项目规模增大，如果每发起一次HTTP请求，就要把这些比如设置超时时间、设置请求头、根据项目环境判断使用哪个请求地址、错误处理等等操作，都需要写一遍
这种重复劳动不仅浪费时间，而且让代码变得冗余不堪，难以维护。为了提高我们的代码质量，我们应该在项目中二次封装一下 axios 再使用
举个例子：
axios(&#x27;http://localhost:3000/data&#x27;, &#123;  // 配置代码  method: &#x27;GET&#x27;,  timeout: 1000,  withCredentials: true,  headers: &#123;    &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,    Authorization: &#x27;xxx&#x27;,  &#125;,  transformRequest: [function (data, headers) &#123;    return data;  &#125;],  // 其他请求配置...&#125;).then((data) =&gt; &#123;  // todo: 真正业务逻辑代码  console.log(data);&#125;, (err) =&gt; &#123;  // 错误处理代码    if (err.response.status === 401) &#123;  // handle authorization error  &#125;  if (err.response.status === 403) &#123;  // handle server forbidden error  &#125;  // 其他错误处理.....  console.log(err);&#125;);

如果每个页面都发送类似的请求，都要写一堆的配置与错误处理，就显得过于繁琐了
这时候我们就需要对axios进行二次封装，让使用更为便利
三、如何封装封装的同时，你需要和 后端协商好一些约定，请求头，状态码，请求超时时间…….
设置接口请求前缀：根据开发、测试、生产环境的不同，前缀需要加以区分
请求头 :  来实现一些具体的业务，必须携带一些参数才可以请求(例如：会员业务)
状态码:   根据接口返回的不同status ， 来执行不同的业务，这块需要和后端约定好
请求方法：根据get、post等方法进行一个再次封装，使用起来更为方便
请求拦截器:  根据请求的请求头设定，来决定哪些请求可以访问
响应拦截器： 这块就是根据 后端&#96;返回来的状态码判定执行不同业务
设置接口请求前缀利用node环境变量来作判断，用来区分开发、测试、生产环境
if (process.env.NODE_ENV === &#x27;development&#x27;) &#123;  axios.defaults.baseURL = &#x27;http://dev.xxx.com&#x27;&#125; else if (process.env.NODE_ENV === &#x27;production&#x27;) &#123;  axios.defaults.baseURL = &#x27;http://prod.xxx.com&#x27;&#125;

在本地调试的时候，还需要在vue.config.js文件中配置devServer实现代理转发，从而实现跨域
devServer: &#123;    proxy: &#123;      &#x27;/proxyApi&#x27;: &#123;        target: &#x27;http://dev.xxx.com&#x27;,        changeOrigin: true,        pathRewrite: &#123;          &#x27;/proxyApi&#x27;: &#x27;&#x27;        &#125;      &#125;    &#125;  &#125;



设置请求头与超时时间大部分情况下，请求头都是固定的，只有少部分情况下，会需要一些特殊的请求头，这里将普适性的请求头作为基础配置。当需要特殊请求头时，将特殊请求头作为参数传入，覆盖基础配置
const service = axios.create(&#123;    ...    timeout: 30000,  // 请求 30s 超时	  headers: &#123;        get: &#123;          &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded;charset=utf-8&#x27;          // 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来        &#125;,        post: &#123;          &#x27;Content-Type&#x27;: &#x27;application/json;charset=utf-8&#x27;          // 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来        &#125;  &#125;,&#125;)



封装请求方法先引入封装好的方法，在要调用的接口重新封装成一个方法暴露出去
// get 请求export function httpGet(&#123;  url,  params = &#123;&#125;&#125;) &#123;  return new Promise((resolve, reject) =&gt; &#123;    axios.get(url, &#123;      params    &#125;).then((res) =&gt; &#123;      resolve(res.data)    &#125;).catch(err =&gt; &#123;      reject(err)    &#125;)  &#125;)&#125;// post// post请求export function httpPost(&#123;  url,  data = &#123;&#125;,  params = &#123;&#125;&#125;) &#123;  return new Promise((resolve, reject) =&gt; &#123;    axios(&#123;      url,      method: &#x27;post&#x27;,      transformRequest: [function (data) &#123;        let ret = &#x27;&#x27;        for (let it in data) &#123;          ret += encodeURIComponent(it) + &#x27;=&#x27; + encodeURIComponent(data[it]) + &#x27;&amp;&#x27;        &#125;        return ret      &#125;],      // 发送的数据      data,      // url参数      params    &#125;).then(res =&gt; &#123;      resolve(res.data)    &#125;)  &#125;)&#125;

把封装的方法放在一个api.js文件中
import &#123; httpGet, httpPost &#125; from &#x27;./http&#x27;export const getorglist = (params = &#123;&#125;) =&gt; httpGet(&#123; url: &#x27;apps/api/org/list&#x27;, params &#125;)

页面中就能直接调用
// .vueimport &#123; getorglist &#125; from &#x27;@/assets/js/api&#x27;getorglist(&#123; id: 200 &#125;).then(res =&gt; &#123;  console.log(res)&#125;)

这样可以把api统一管理起来，以后维护修改只需要在api.js文件操作即可
请求拦截器请求拦截器可以在每个请求里加上token，做了统一处理后维护起来也方便
// 请求拦截器axios.interceptors.request.use(  config =&gt; &#123;    // 每次发送请求之前判断是否存在token    // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况，此处token一般是用户完成登录后储存到localstorage里的    token &amp;&amp; (config.headers.Authorization = token)    return config  &#125;,  error =&gt; &#123;    return Promise.error(error)  &#125;)



响应拦截器响应拦截器可以在接收到响应后先做一层操作，如根据状态码判断登录状态、授权
// 响应拦截器axios.interceptors.response.use(response =&gt; &#123;  // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据  // 否则的话抛出错误  if (response.status === 200) &#123;    if (response.data.code === 511) &#123;      // 未授权调取授权接口    &#125; else if (response.data.code === 510) &#123;      // 未登录跳转登录页    &#125; else &#123;      return Promise.resolve(response)    &#125;  &#125; else &#123;    return Promise.reject(response)  &#125;&#125;, error =&gt; &#123;  // 我们可以在这里对异常状态作统一处理  if (error.response.status) &#123;    // 处理请求失败的情况    // 对不同返回码对相应处理    return Promise.reject(error.response)  &#125;&#125;)



小结
封装是编程中很有意义的手段，简单的axios封装，就可以让我们可以领略到它的魅力
封装 axios 没有一个绝对的标准，只要你的封装可以满足你的项目需求，并且用起来方便，那就是一个好的封装方案

参考文献
https://www.html.cn/qa/vue-js/20544.html
https://juejin.cn/post/6844904033782611976
https://juejin.cn/post/6844903801451708429

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>前端监控体系的搭建经验</title>
    <url>/2024/03/19/engine-frontend-monitor/</url>
    <content><![CDATA[一、监控维度前端监控体系主要包含以下维度：

性能监控
错误监控
用户行为监控
业务监控
资源监控

二、具体实现1. 性能监控1.1 核心指标采集class PerformanceMonitor &#123;  constructor() &#123;    this.metrics = &#123;&#125;    this.initObservers()  &#125;    initObservers() &#123;    // FCP 监控    new PerformanceObserver((entryList) =&gt; &#123;      const entries = entryList.getEntries()      this.metrics.fcp = entries[0].startTime    &#125;).observe(&#123; entryTypes: [&#x27;paint&#x27;] &#125;)        // LCP 监控    new PerformanceObserver((entryList) =&gt; &#123;      const entries = entryList.getEntries()      this.metrics.lcp = entries[entries.length - 1].startTime    &#125;).observe(&#123; entryTypes: [&#x27;largest-contentful-paint&#x27;] &#125;)        // FID 监控    new PerformanceObserver((entryList) =&gt; &#123;      const entries = entryList.getEntries()      this.metrics.fid = entries[0].processingStart - entries[0].startTime    &#125;).observe(&#123; entryTypes: [&#x27;first-input&#x27;] &#125;)  &#125;    // 获取性能指标  getMetrics() &#123;    const navigationTiming = performance.getEntriesByType(&#x27;navigation&#x27;)[0]        return &#123;      ...this.metrics,      // DNS 解析时间      dns: navigationTiming.domainLookupEnd - navigationTiming.domainLookupStart,      // TCP 连接时间      tcp: navigationTiming.connectEnd - navigationTiming.connectStart,      // 首字节时间      ttfb: navigationTiming.responseStart - navigationTiming.requestStart,      // DOM 解析时间      domParse: navigationTiming.domInteractive - navigationTiming.responseEnd,      // 资源加载时间      resourceLoad: navigationTiming.loadEventStart - navigationTiming.domContentLoadedEventEnd    &#125;  &#125;&#125;

1.2 资源性能监控class ResourceMonitor &#123;  constructor() &#123;    this.resources = new Map()    this.initObserver()  &#125;    initObserver() &#123;    new PerformanceObserver((entryList) =&gt; &#123;      const entries = entryList.getEntries()      entries.forEach(entry =&gt; &#123;        this.recordResource(entry)      &#125;)    &#125;).observe(&#123; entryTypes: [&#x27;resource&#x27;] &#125;)  &#125;    recordResource(entry) &#123;    const metrics = &#123;      name: entry.name,      type: entry.initiatorType,      duration: entry.duration,      size: entry.transferSize,      protocol: entry.nextHopProtocol,      // 资源时序信息      timing: &#123;        dns: entry.domainLookupEnd - entry.domainLookupStart,        tcp: entry.connectEnd - entry.connectStart,        ttfb: entry.responseStart - entry.requestStart,        download: entry.responseEnd - entry.responseStart      &#125;    &#125;        this.resources.set(entry.name, metrics)  &#125;    getSlowResources(threshold = 1000) &#123;    const slowResources = []    this.resources.forEach((metrics, url) =&gt; &#123;      if (metrics.duration &gt; threshold) &#123;        slowResources.push(&#123; url, ...metrics &#125;)      &#125;    &#125;)    return slowResources  &#125;&#125;

2. 错误监控2.1 全局错误捕获class ErrorMonitor &#123;  constructor() &#123;    this.errors = []    this.config = &#123;      maxErrors: 100,      sampling: 1 // 采样率    &#125;    this.initHandlers()  &#125;    initHandlers() &#123;    // JS 运行时错误    window.addEventListener(&#x27;error&#x27;, (event) =&gt; &#123;      this.handleError(&#123;        type: &#x27;runtime&#x27;,        error: event.error,        message: event.message,        filename: event.filename,        line: event.lineno,        column: event.colno,        stack: event.error?.stack      &#125;)    &#125;, true)        // Promise 未捕获错误    window.addEventListener(&#x27;unhandledrejection&#x27;, (event) =&gt; &#123;      this.handleError(&#123;        type: &#x27;promise&#x27;,        error: event.reason,        message: event.reason?.message,        stack: event.reason?.stack      &#125;)    &#125;)        // 资源加载错误    window.addEventListener(&#x27;error&#x27;, (event) =&gt; &#123;      if (event.target &amp;&amp; (event.target.src || event.target.href)) &#123;        this.handleError(&#123;          type: &#x27;resource&#x27;,          url: event.target.src || event.target.href,          tagName: event.target.tagName,          html: event.target.outerHTML        &#125;)      &#125;    &#125;, true)  &#125;    handleError(error) &#123;    // 采样处理    if (Math.random() &gt; this.config.sampling) &#123;      return    &#125;        // 错误数量限制    if (this.errors.length &gt;= this.config.maxErrors) &#123;      this.errors.shift()    &#125;        const errorInfo = &#123;      ...error,      timestamp: Date.now(),      url: window.location.href,      userAgent: navigator.userAgent    &#125;        this.errors.push(errorInfo)    this.reportError(errorInfo)  &#125;    async reportError(error) &#123;    try &#123;      await fetch(&#x27;/api/errors&#x27;, &#123;        method: &#x27;POST&#x27;,        body: JSON.stringify(error)      &#125;)    &#125; catch (e) &#123;      console.error(&#x27;Failed to report error:&#x27;, e)    &#125;  &#125;&#125;

3. 用户行为监控3.1 行为采集class BehaviorMonitor &#123;  constructor() &#123;    this.events = []    this.config = &#123;      maxEvents: 100,      // 行为类型配置      behaviorTypes: &#123;        CLICK: &#x27;click&#x27;,        INPUT: &#x27;input&#x27;,        ROUTE: &#x27;route&#x27;,        API: &#x27;api&#x27;      &#125;    &#125;    this.initTrackers()  &#125;    initTrackers() &#123;    // 点击行为追踪    document.addEventListener(&#x27;click&#x27;, (event) =&gt; &#123;      const target = event.target      this.trackEvent(&#123;        type: this.config.behaviorTypes.CLICK,        element: target.tagName,        content: target.textContent,        path: this.getElementPath(target)      &#125;)    &#125;, true)        // 输入行为追踪    document.addEventListener(&#x27;input&#x27;, this.debounce((event) =&gt; &#123;      const target = event.target      if (target.tagName === &#x27;INPUT&#x27; || target.tagName === &#x27;TEXTAREA&#x27;) &#123;        this.trackEvent(&#123;          type: this.config.behaviorTypes.INPUT,          element: target.tagName,          name: target.name || target.id        &#125;)      &#125;    &#125;, 500), true)        // 路由变化追踪    this.trackRouteChange()  &#125;    // 获取元素路径  getElementPath(element) &#123;    const path = []    while (element &amp;&amp; element.nodeType === Node.ELEMENT_NODE) &#123;      let selector = element.tagName.toLowerCase()      if (element.id) &#123;        selector += `#$&#123;element.id&#125;`      &#125; else if (element.className) &#123;        selector += `.$&#123;element.className.split(&#x27; &#x27;).join(&#x27;.&#x27;)&#125;`      &#125;      path.unshift(selector)      element = element.parentNode    &#125;    return path.join(&#x27; &gt; &#x27;)  &#125;    // 路由变化追踪  trackRouteChange() &#123;    let lastUrl = window.location.href        // History API    const originalPushState = window.history.pushState    window.history.pushState = (...args) =&gt; &#123;      originalPushState.apply(window.history, args)      this.handleUrlChange()    &#125;        // 监听 popstate 事件    window.addEventListener(&#x27;popstate&#x27;, () =&gt; &#123;      this.handleUrlChange()    &#125;)  &#125;    handleUrlChange() &#123;    const currentUrl = window.location.href    this.trackEvent(&#123;      type: this.config.behaviorTypes.ROUTE,      from: lastUrl,      to: currentUrl    &#125;)    lastUrl = currentUrl  &#125;    // 防抖函数  debounce(fn, delay) &#123;    let timer = null    return function(...args) &#123;      if (timer) clearTimeout(timer)      timer = setTimeout(() =&gt; &#123;        fn.apply(this, args)      &#125;, delay)    &#125;  &#125;    trackEvent(event) &#123;    const eventInfo = &#123;      ...event,      timestamp: Date.now(),      url: window.location.href,      userAgent: navigator.userAgent    &#125;        this.events.push(eventInfo)    if (this.events.length &gt; this.config.maxEvents) &#123;      this.events.shift()    &#125;        this.reportEvent(eventInfo)  &#125;    async reportEvent(event) &#123;    try &#123;      await fetch(&#x27;/api/events&#x27;, &#123;        method: &#x27;POST&#x27;,        body: JSON.stringify(event)      &#125;)    &#125; catch (e) &#123;      console.error(&#x27;Failed to report event:&#x27;, e)    &#125;  &#125;&#125;

4. 业务监控4.1 API 监控class APIMonitor &#123;  constructor() &#123;    this.requests = new Map()    this.initInterceptor()  &#125;    initInterceptor() &#123;    // 拦截 XMLHttpRequest    this.interceptXHR()    // 拦截 Fetch    this.interceptFetch()  &#125;    interceptXHR() &#123;    const originalXHR = window.XMLHttpRequest    const self = this        window.XMLHttpRequest = function() &#123;      const xhr = new originalXHR()      const originalOpen = xhr.open      const originalSend = xhr.send            xhr.open = function(...args) &#123;        const [method, url] = args        this._url = url        this._method = method        this._startTime = Date.now()        originalOpen.apply(this, args)      &#125;            xhr.send = function(data) &#123;        this.addEventListener(&#x27;load&#x27;, function() &#123;          self.handleRequest(&#123;            url: this._url,            method: this._method,            status: this.status,            duration: Date.now() - this._startTime,            requestData: data,            responseData: this.responseText          &#125;)        &#125;)                originalSend.apply(this, arguments)      &#125;            return xhr    &#125;  &#125;    interceptFetch() &#123;    const originalFetch = window.fetch    const self = this        window.fetch = function(url, options = &#123;&#125;) &#123;      const startTime = Date.now()            return originalFetch(url, options)        .then(async (response) =&gt; &#123;          const duration = Date.now() - startTime          const clonedResponse = response.clone()          const responseData = await clonedResponse.text()                    self.handleRequest(&#123;            url,            method: options.method || &#x27;GET&#x27;,            status: response.status,            duration,            requestData: options.body,            responseData          &#125;)                    return response        &#125;)    &#125;  &#125;    handleRequest(requestInfo) &#123;    // 记录请求信息    this.requests.set(requestInfo.url, requestInfo)        // 分析请求    this.analyzeRequest(requestInfo)  &#125;    analyzeRequest(requestInfo) &#123;    // 慢请求检测    if (requestInfo.duration &gt; 1000) &#123;      this.reportSlowAPI(requestInfo)    &#125;        // 错误请求检测    if (requestInfo.status &gt;= 400) &#123;      this.reportErrorAPI(requestInfo)    &#125;  &#125;    async reportSlowAPI(requestInfo) &#123;    try &#123;      await fetch(&#x27;/api/slow-requests&#x27;, &#123;        method: &#x27;POST&#x27;,        body: JSON.stringify(requestInfo)      &#125;)    &#125; catch (e) &#123;      console.error(&#x27;Failed to report slow API:&#x27;, e)    &#125;  &#125;    async reportErrorAPI(requestInfo) &#123;    try &#123;      await fetch(&#x27;/api/error-requests&#x27;, &#123;        method: &#x27;POST&#x27;,        body: JSON.stringify(requestInfo)      &#125;)    &#125; catch (e) &#123;      console.error(&#x27;Failed to report error API:&#x27;, e)    &#125;  &#125;&#125;

三、数据上报1. 数据上报策略class Reporter &#123;  constructor() &#123;    this.queue = []    this.config = &#123;      url: &#x27;/api/collect&#x27;,      batchSize: 10,      flushInterval: 5000    &#125;    this.startTimer()  &#125;    add(data) &#123;    this.queue.push(&#123;      ...data,      timestamp: Date.now()    &#125;)        if (this.queue.length &gt;= this.config.batchSize) &#123;      this.flush()    &#125;  &#125;    startTimer() &#123;    setInterval(() =&gt; &#123;      if (this.queue.length &gt; 0) &#123;        this.flush()      &#125;    &#125;, this.config.flushInterval)  &#125;    async flush() &#123;    if (this.queue.length === 0) return        const data = this.queue.splice(0, this.config.batchSize)        try &#123;      if (navigator.sendBeacon) &#123;        // 使用 Beacon API        navigator.sendBeacon(this.config.url, JSON.stringify(data))      &#125; else &#123;        // 降级使用 fetch        await fetch(this.config.url, &#123;          method: &#x27;POST&#x27;,          body: JSON.stringify(data)        &#125;)      &#125;    &#125; catch (e) &#123;      console.error(&#x27;Failed to report data:&#x27;, e)      // 失败重试      this.queue.unshift(...data)    &#125;  &#125;&#125;

四、监控告警1. 告警规则class AlertManager &#123;  constructor() &#123;    this.rules = new Map()  &#125;    addRule(name, rule) &#123;    this.rules.set(name, rule)  &#125;    checkMetric(name, value) &#123;    const rule = this.rules.get(name)    if (!rule) return        if (this.evaluateRule(rule, value)) &#123;      this.triggerAlert(name, value)    &#125;  &#125;    evaluateRule(rule, value) &#123;    const &#123; operator, threshold &#125; = rule        switch (operator) &#123;      case &#x27;&gt;&#x27;:        return value &gt; threshold      case &#x27;&lt;&#x27;:        return value &lt; threshold      case &#x27;&gt;=&#x27;:        return value &gt;= threshold      case &#x27;&lt;=&#x27;:        return value &lt;= threshold      case &#x27;==&#x27;:        return value === threshold      default:        return false    &#125;  &#125;    async triggerAlert(name, value) &#123;    const alert = &#123;      name,      value,      timestamp: Date.now()    &#125;        try &#123;      await fetch(&#x27;/api/alerts&#x27;, &#123;        method: &#x27;POST&#x27;,        body: JSON.stringify(alert)      &#125;)    &#125; catch (e) &#123;      console.error(&#x27;Failed to send alert:&#x27;, e)    &#125;  &#125;&#125;

参考文献
Web Vitals
Performance API
Beacon API
Error Handling

]]></content>
      <categories>
        <category>前端</category>
        <category>监控</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>前端监控</tag>
        <tag>错误处理</tag>
      </tags>
  </entry>
  <entry>
    <title>vue项目本地开发完成后部署到服务器后报404是什么原因呢？</title>
    <url>/2024/03/19/vue-404/</url>
    <content><![CDATA[vue项目本地开发完成后部署到服务器后报404是什么原因呢？
一、如何部署前后端分离开发模式下，前后端是独立布署的，前端只需要将最后的构建物上传至目标服务器的web容器指定的静态目录下即可
我们知道vue项目在构建后，是生成一系列的静态文件

常规布署我们只需要将这个目录上传至目标服务器即可
// scp 上传 user为主机登录用户，host为主机外网ip, xx为web容器静态资源路径scp dist.zip user@host:/xx/xx/xx

让web容器跑起来，以nginx为例
server &#123;  listen  80;  server_name  www.xxx.com;  location / &#123;    index  /data/dist/index.html;  &#125;&#125;
配置完成记得重启nginx
// 检查配置是否正确nginx -t // 平滑重启nginx -s reload

操作完后就可以在浏览器输入域名进行访问了
当然上面只是提到最简单也是最直接的一种布署方式
什么自动化，镜像，容器，流水线布署，本质也是将这套逻辑抽象，隔离，用程序来代替重复性的劳动，本文不展开
二、404问题这是一个经典的问题，相信很多同学都有遇到过，那么你知道其真正的原因吗？
我们先还原一下场景：

vue项目在本地时运行正常，但部署到服务器中，刷新页面，出现了404错误

先定位一下，HTTP 404 错误意味着链接指向的资源不存在
问题在于为什么不存在？且为什么只有history模式下会出现这个问题？
为什么history模式下有问题Vue是属于单页应用（single-page application）
而SPA是一种网络应用程序或网站的模型，所有用户交互是通过动态重写当前页面，前面我们也看到了，不管我们应用有多少页面，构建物都只会产出一个index.html
现在，我们回头来看一下我们的nginx配置
server &#123;  listen  80;  server_name  www.xxx.com;  location / &#123;    index  /data/dist/index.html;  &#125;&#125;

可以根据 nginx 配置得出，当我们在地址栏输入 www.xxx.com 时，这时会打开我们 dist 目录下的 index.html 文件，然后我们在跳转路由进入到 www.xxx.com/login
关键在这里，当我们在 website.com/login 页执行刷新操作，nginx location 是没有相关配置的，所以就会出现 404 的情况
为什么hash模式下没有问题router hash 模式我们都知道是用符号#表示的，如  website.com/#/login, hash 的值为 #/login
它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对服务端完全没有影响，因此改变 hash 不会重新加载页面
hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 website.com/#/login 只有 website.com 会被包含在请求中 ，因此对于服务端来说，即使没有配置location，也不会返回404错误
解决方案看到这里我相信大部分同学都能想到怎么解决问题了，
产生问题的本质是因为我们的路由是通过JS来执行视图切换的，
当我们进入到子路由时刷新页面，web容器没有相对应的页面此时会出现404
所以我们只需要配置将任意页面都重定向到 index.html，把路由交由前端处理
对nginx配置文件.conf修改，添加try_files $uri $uri/ /index.html;
server &#123;  listen  80;  server_name  www.xxx.com;  location / &#123;    index  /data/dist/index.html;    try_files $uri $uri/ /index.html;  &#125;&#125;

修改完配置文件后记得配置的更新
nginx -s reload

这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件
为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面
const router = new VueRouter(&#123;  mode: &#x27;history&#x27;,  routes: [    &#123; path: &#x27;*&#x27;, component: NotFoundComponent &#125;  ]&#125;)

关于后端配置方案还有：Apache、nodejs等，思想是一致的，这里就不展开述说了
参考文献
https://juejin.cn/post/6844903872637632525
https://vue-js.com/topic/5f8cf91d96b2cb0032c385c0

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue组件之间的通信方式都有哪些？</title>
    <url>/2025/01/18/vue-communication/</url>
    <content><![CDATA[
一、组件间通信的概念开始之前，我们把组件间通信这个词进行拆分

组件
通信

都知道组件是vue最强大的功能之一，vue中每一个.vue我们都可以视之为一个组件通信指的是发送者通过某种媒体以某种格式来传递信息到收信者以达到某个目的。广义上，任何信息的交通都是通信组件间通信即指组件(.vue)通过某种方式来传递信息以达到某个目的举个栗子我们在使用UI框架中的table组件，可能会往table组件中传入某些数据，这个本质就形成了组件之间的通信
二、组件间通信解决了什么在古代，人们通过驿站、飞鸽传书、烽火报警、符号、语言、眼神、触碰等方式进行信息传递，到了今天，随着科技水平的飞速发展，通信基本完全利用有线或无线电完成，相继出现了有线电话、固定电话、无线电话、手机、互联网甚至视频电话等各种通信方式从上面这段话，我们可以看到通信的本质是信息同步，共享回到vue中，每个组件之间的都有独自的作用域，组件间的数据是无法共享的但实际开发工作中我们常常需要让组件之间共享数据，这也是组件通信的目的要让它们互相之间能进行通讯，这样才能构成一个有机的完整系统
二、组件间通信的分类组件间通信的分类可以分成以下

父子组件之间的通信
兄弟组件之间的通信
祖孙与后代组件之间的通信
非关系组件间之间的通信

关系图:
 
三、组件间通信的方案整理vue中8种常规的通信方案

通过 props 传递
通过 $emit 触发自定义事件
使用 ref
EventBus
$parent 或$root
attrs 与 listeners
Provide 与 Inject
Vuex

props传递数据 

适用场景：父组件传递数据给子组件
子组件设置props属性，定义接收父组件传递过来的参数
父组件在使用子组件标签中通过字面量来传递值

Children.vue
props:&#123;      // 字符串形式   name:String // 接收的类型参数      // 对象形式      age:&#123;            type:Number, // 接收的类型为数值          defaule:18,  // 默认值为18         require:true // age属性必须传递      &#125;  &#125;  

Father.vue组件
&lt;Children name=&quot;jack&quot; age=18 /&gt;  

$emit 触发自定义事件
适用场景：子组件传递数据给父组件
子组件通过$emit触发自定义事件，$emit第二个参数为传递的数值
父组件绑定监听器获取到子组件传递过来的参数

Chilfen.vue
this.$emit(&#x27;add&#x27;, good)  

Father.vue
&lt;Children @add=&quot;cartAdd($event)&quot; /&gt;  

ref
父组件在使用子组件的时候设置ref
父组件通过设置子组件ref来获取数据

父组件
&lt;Children ref=&quot;foo&quot; /&gt;    this.$refs.foo  // 获取子组件实例，通过子组件实例我们就能拿到对应的数据  

EventBus
使用场景：兄弟组件传值
创建一个中央事件总线EventBus
兄弟组件通过$emit触发自定义事件，$emit第二个参数为传递的数值
另一个兄弟组件通过$on监听自定义事件

Bus.js
// 创建一个中央时间总线类  class Bus &#123;    constructor() &#123;      this.callbacks = &#123;&#125;;   // 存放事件的名字    &#125;    $on(name, fn) &#123;      this.callbacks[name] = this.callbacks[name] || [];      this.callbacks[name].push(fn);    &#125;    $emit(name, args) &#123;      if (this.callbacks[name]) &#123;        this.callbacks[name].forEach((cb) =&gt; cb(args));      &#125;    &#125;  &#125;    // main.js  Vue.prototype.$bus = new Bus() // 将$bus挂载到vue实例的原型上  // 另一种方式  Vue.prototype.$bus = new Vue() // Vue已经实现了Bus的功能  

Children1.vue
this.$bus.$emit(&#x27;foo&#x27;)  

Children2.vue
this.$bus.$on(&#x27;foo&#x27;, this.handle)  

$parent 或$ root
通过共同祖辈$parent或者$root搭建通信桥连

兄弟组件
this.$parent.on(&#39;add&#39;,this.add)   
另一个兄弟组件
this.$parent.emit(&#39;add&#39;)   
$attrs  与$ listeners
适用场景：祖先传递数据给子孙
设置批量向下传属性$attrs和 $listeners
包含了父级作用域中不作为 prop 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。
可以通过 v-bind=&quot;$attrs&quot; 传⼊内部组件

// child：并未在props中声明foo  &lt;p&gt;&#123;&#123;$attrs.foo&#125;&#125;&lt;/p&gt;    // parent  &lt;HelloWorld foo=&quot;foo&quot;/&gt;  

// 给Grandson隔代传值，communication/index.vue  &lt;Child2 msg=&quot;lalala&quot; @some-event=&quot;onSomeEvent&quot;&gt;&lt;/Child2&gt;    // Child2做展开  &lt;Grandson v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/Grandson&gt;    // Grandson使⽤  &lt;div @click=&quot;$emit(&#x27;some-event&#x27;, &#x27;msg from grandson&#x27;)&quot;&gt;  &#123;&#123;msg&#125;&#125;  &lt;/div&gt;  

provide 与 inject
在祖先组件定义provide属性，返回传递的值
在后代组件通过inject接收组件传递过来的值

祖先组件
provide()&#123;      return &#123;          foo:&#x27;foo&#x27;      &#125;  &#125;  

后代组件
inject:[&#x27;foo&#x27;] // 获取到祖先组件传递过来的值  

vuex
适用场景: 复杂关系的组件数据传递

Vuex作用相当于一个用来存储共享变量的容器 

state用来存放共享变量的地方

getter，可以增加一个getter派生状态，(相当于store中的计算属性），用来获得共享变量的值

mutations用来存放修改state的方法。

actions也是用来存放修改state的方法，不过action是在mutations的基础上进行。常用来做一些异步操作


小结
父子关系的组件数据传递选择 props  与 $emit进行传递，也可选择ref
兄弟关系的组件数据传递可选择$bus，其次可以选择$parent进行传递
祖先与后代组件数据传递可选择attrs与listeners或者 Provide与 Inject
复杂关系的组件数据传递可以通过vuex存放共享的变量

参考文献
https://juejin.cn/post/6844903990052782094#heading-0
https://zh.wikipedia.org/wiki/\%E9\%80\%9A\%E4\%BF\%A1
https://vue3js.cn/docs/zh

面试官VUE系列总进度：5／33
面试官：说说你对vue的理解?  
面试官：说说你对SPA（单页应用）的理解?
面试官：说说你对双向绑定的理解?  
面试官：说说你对Vue生命周期的理解?  
 
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中组件和插件有什么区别？</title>
    <url>/2025/01/21/vue-components-plugin/</url>
    <content><![CDATA[
一、组件是什么回顾以前对组件的定义：
组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在Vue中每一个.vue文件都可以视为一个组件
组件的优势

降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现

调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单

提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级


二、插件是什么插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：

添加全局方法或者属性。如: vue-custom-element
添加全局资源：指令&#x2F;过滤器&#x2F;过渡等。如 vue-touch
通过全局混入来添加一些组件选项。如 vue-router
添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。
一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 vue-router

三、两者的区别两者的区别主要表现在以下几个方面：

编写形式
注册形式
使用场景

编写形式编写组件编写一个组件，可以有很多方式，我们最常见的就是vue单文件的这种格式，每一个.vue文件我们都可以看成是一个组件
vue文件标准格式
&lt;template&gt;&lt;/template&gt;&lt;script&gt;export default&#123;     ...&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;

我们还可以通过template属性来编写一个组件，如果组件内容多，我们可以在外部定义template组件内容，如果组件内容并不多，我们可直接写在template属性上
&lt;template id=&quot;testComponent&quot;&gt;     // 组件显示的内容    &lt;div&gt;component!&lt;/div&gt;   &lt;/template&gt;Vue.component(&#x27;componentA&#x27;,&#123;     template: &#x27;#testComponent&#x27;      template: `&lt;div&gt;component&lt;/div&gt;`  // 组件内容少可以通过这种形式&#125;)

编写插件vue插件的实现应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象
MyPlugin.install = function (Vue, options) &#123;  // 1. 添加全局方法或 property  Vue.myGlobalMethod = function () &#123;    // 逻辑...  &#125;  // 2. 添加全局资源  Vue.directive(&#x27;my-directive&#x27;, &#123;    bind (el, binding, vnode, oldVnode) &#123;      // 逻辑...    &#125;    ...  &#125;)  // 3. 注入组件选项  Vue.mixin(&#123;    created: function () &#123;      // 逻辑...    &#125;    ...  &#125;)  // 4. 添加实例方法  Vue.prototype.$myMethod = function (methodOptions) &#123;    // 逻辑...  &#125;&#125;


注册形式组件注册vue组件注册主要分为全局注册与局部注册
全局注册通过Vue.component方法，第一个参数为组件的名称，第二个参数为传入的配置项
Vue.component(&#x27;my-component-name&#x27;, &#123; /* ... */ &#125;)

局部注册只需在用到的地方通过components属性注册一个组件
const component1 = &#123;...&#125; // 定义一个组件export default &#123;	components:&#123;		component1   // 局部注册	&#125;&#125;


插件注册插件的注册通过Vue.use()的方式进行注册（安装），第一个参数为插件的名字，第二个参数是可选择的配置项
Vue.use(插件名字,&#123; /* ... */&#125; )

注意的是：
注册插件的时候，需要在调用 new Vue() 启动应用之前完成
Vue.use会自动阻止多次注册相同插件，只会注册一次
使用场景具体的其实在插件是什么章节已经表述了，这里在总结一下
组件 (Component) 是用来构成你的 App 的业务模块，它的目标是 App.vue
插件 (Plugin) 是用来增强你的技术栈的功能模块，它的目标是 Vue 本身
简单来说，插件就是指对Vue的功能的增强或补充
参考文献
https://vue3js.cn/docs/zh

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue项目中你是如何解决跨域的呢？</title>
    <url>/2025/01/11/vue-cors/</url>
    <content><![CDATA[
一、跨域是什么跨域本质是浏览器基于同源策略的一种安全手段
同源策略（Sameoriginpolicy），是一种约定，它是浏览器最核心也最基本的安全功能
所谓同源（即指在同一个域）具有以下三个相同点

协议相同（protocol）
主机相同（host）
端口相同（port）

反之非同源请求，也就是协议、端口、主机其中一项不相同的时候，这时候就会产生跨域

一定要注意跨域是浏览器的限制，你用抓包工具抓取接口数据，是可以看到接口已经把数据返回回来了，只是浏览器的限制，你获取不到数据。用postman请求接口能够请求到数据。这些再次印证了跨域是浏览器的限制。

二、如何解决解决跨域的方法有很多，下面列举了三种：

JSONP
CORS
Proxy

而在vue项目中，我们主要针对CORS或Proxy这两种方案进行展开
CORSCORS （Cross-Origin Resource Sharing，跨域资源共享）是一个系统，它由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应
CORS 实现起来非常方便，只需要增加一些 HTTP 头，让服务器能声明允许的访问来源
只要后端实现了 CORS，就实现了跨域
 
以 koa框架举例
添加中间件，直接设置Access-Control-Allow-Origin响应头
app.use(async (ctx, next)=&gt; &#123;  ctx.set(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);  ctx.set(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild&#x27;);  ctx.set(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;PUT, POST, GET, DELETE, OPTIONS&#x27;);  if (ctx.method == &#x27;OPTIONS&#x27;) &#123;    ctx.body = 200;   &#125; else &#123;    await next();  &#125;&#125;)

ps: Access-Control-Allow-Origin 设置为*其实意义不大，可以说是形同虚设，实际应用中，上线前我们会将Access-Control-Allow-Origin 值设为我们目标host
Proxy代理（Proxy）也称网络代理，是一种特殊的网络服务，允许一个（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击
方案一
如果是通过vue-cli脚手架工具搭建项目，我们可以通过webpack为我们起一个本地服务器作为请求的代理对象
通过该服务器转发请求至目标服务器，得到结果再转发给前端，但是最终发布上线时如果web应用和接口服务器不在一起仍会跨域
在vue.config.js文件，新增以下代码
amodule.exports = &#123;    devServer: &#123;        host: &#x27;127.0.0.1&#x27;,        port: 8084,        open: true,// vue项目启动时自动打开浏览器        proxy: &#123;            &#x27;/api&#x27;: &#123; // &#x27;/api&#x27;是代理标识，用于告诉node，url前面是/api的就是使用代理的                target: &quot;http://xxx.xxx.xx.xx:8080&quot;, //目标地址，一般是指后台服务器地址                changeOrigin: true, //是否跨域                pathRewrite: &#123; // pathRewrite 的作用是把实际Request Url中的&#x27;/api&#x27;用&quot;&quot;代替                    &#x27;^/api&#x27;: &quot;&quot;                 &#125;            &#125;        &#125;    &#125;&#125;

通过axios发送请求中，配置请求的根路径
axios.defaults.baseURL = &#x27;/api&#x27;



方案二
此外，还可通过服务端实现代理请求转发
以express框架为例
var express = require(&#x27;express&#x27;);const proxy = require(&#x27;http-proxy-middleware&#x27;)const app = express()app.use(express.static(__dirname + &#x27;/&#x27;))app.use(&#x27;/api&#x27;, proxy(&#123; target: &#x27;http://localhost:4000&#x27;, changeOrigin: false                      &#125;));module.exports = app



方案三
通过配置nginx实现代理
server &#123;    listen    80;    # server_name www.josephxia.com;    location / &#123;        root  /var/www/html;        index  index.html index.htm;        try_files $uri $uri/ /index.html;    &#125;    location /api &#123;        proxy_pass  http://127.0.0.1:3000;        proxy_redirect   off;        proxy_set_header  Host       $host;        proxy_set_header  X-Real-IP     $remote_addr;        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;    &#125;&#125;
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>双向数据绑定是什么</title>
    <url>/2025/02/02/vue-bind/</url>
    <content><![CDATA[
1. 基本原理双向绑定主要包含两个方向的数据同步：

数据层（Model）到视图层（View）的绑定
视图层（View）到数据层（Model）的绑定

2. 实现机制主要通过三个重要部分实现：

数据劫持（Observer）

// 通过 Object.defineProperty 实现数据劫持function defineReactive(obj, key, val) &#123;  const dep = new Dep();  Object.defineProperty(obj, key, &#123;    get() &#123;      // 依赖收集      if (Dep.target) &#123;        dep.addDep(Dep.target);      &#125;      return val;    &#125;,    set(newVal) &#123;      if (newVal === val) return;      val = newVal;      // 通知所有依赖进行更新      dep.notify();    &#125;,  &#125;);&#125;


依赖收集器（Dep）

class Dep &#123;  constructor() &#123;    this.subs = []; // 存储所有的依赖  &#125;  addDep(sub) &#123;    this.subs.push(sub);  &#125;  notify() &#123;    // 通知所有依赖更新    this.subs.forEach((sub) =&gt; sub.update());  &#125;&#125;


观察者（Watcher）

class Watcher &#123;  constructor(vm, key, cb) &#123;    this.vm = vm;    this.key = key;    this.cb = cb;    // 触发 getter，进行依赖收集    Dep.target = this;    this.vm[this.key];    Dep.target = null;  &#125;  update() &#123;    // 更新视图    this.cb.call(this.vm, this.vm[this.key]);  &#125;&#125;

3. 工作流程
初始化阶段：

对数据进行劫持，设置 getter&#x2F;setter
编译模板，找到动态绑定的数据
创建 Watcher 实例


数据更新阶段：

Model 更新：触发 setter → 通知依赖 → 更新 View
View 更新：触发事件 → 更新 Model → 触发 setter → 更新相关视图



4. 简单示例&lt;div id=&quot;app&quot;&gt;  &lt;input v-model=&quot;message&quot; /&gt;  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;  const vm = new Vue(&#123;    el: &quot;#app&quot;,    data: &#123;      message: &quot;Hello&quot;,    &#125;,  &#125;);&lt;/script&gt;

在这个例子中：

当输入框的值改变时，会触发 setter，更新数据并通知相关依赖更新视图
当 message 数据改变时，会通过依赖通知机制更新显示的文本

5. Vue 3 的改进Vue 3 使用 Proxy 替代了 Object.defineProperty，提供了更好的性能和功能：
// Vue 3 的响应式实现function reactive(obj) &#123;  return new Proxy(obj, &#123;    get(target, key) &#123;      // 依赖收集      track(target, key);      return target[key];    &#125;,    set(target, key, value) &#123;      target[key] = value;      // 触发更新      trigger(target, key);      return true;    &#125;,  &#125;);&#125;

主要优势：

可以监听数组变化
可以监听对象属性的添加和删除
支持 Map、Set 等数据结构
性能更好，不需要递归遍历对象

注意事项
性能考虑：

不要在大型数组或对象上使用双向绑定
使用 v-once 处理静态内容
合理使用计算属性和侦听器


可能的问题：

数据量大时可能会有性能问题
复杂的双向绑定可能导致数据流向难以追踪
需要考虑内存泄漏问题



理解双向绑定的原理对于更好地使用框架和优化应用性能非常重要。在实际开发中，我们通常不需要自己实现双向绑定，但了解其原理有助于我们更好地使用和调试应用。
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>动态给vue的data添加一个新的属性时会发生什么？怎样解决？</title>
    <url>/2025/01/01/vue-data-object-add-attrs/</url>
    <content><![CDATA[
一、直接添加属性的问题我们从一个例子开始
定义一个p标签，通过v-for指令进行遍历
然后给botton标签绑定点击事件，我们预期点击按钮时，数据新增一个属性，界面也 新增一行
&lt;p v-for=&quot;(value,key) in item&quot; :key=&quot;key&quot;&gt;    &#123;&#123; value &#125;&#125;&lt;/p&gt;&lt;button @click=&quot;addProperty&quot;&gt;动态添加新属性&lt;/button&gt;

实例化一个vue实例，定义data属性和methods方法
const app = new Vue(&#123;    el:&quot;#app&quot;,   	data:()=&gt;&#123;       	item:&#123;            oldProperty:&quot;旧属性&quot;        &#125;    &#125;,    methods:&#123;        addProperty()&#123;            this.items.newProperty = &quot;新属性&quot;  // 为items添加新属性            console.log(this.items)  // 输出带有newProperty的items        &#125;    &#125;&#125;)

点击按钮，发现结果不及预期，数据虽然更新了（console打印出了新属性），但页面并没有更新
二、原理分析为什么产生上面的情况呢？
下面来分析一下
vue2是用过Object.defineProperty实现数据响应式
const obj = &#123;&#125;Object.defineProperty(obj, &#x27;foo&#x27;, &#123;        get() &#123;            console.log(`get foo:$&#123;val&#125;`);            return val        &#125;,        set(newVal) &#123;            if (newVal !== val) &#123;                console.log(`set foo:$&#123;newVal&#125;`);                val = newVal            &#125;        &#125;    &#125;)&#125;

当我们访问foo属性或者设置foo值的时候都能够触发setter与getter
obj.foo   obj.foo = &#x27;new&#x27;

但是我们为obj添加新属性的时候，却无法触发事件属性的拦截
obj.bar  = &#x27;新属性&#x27;

原因是一开始obj的foo属性被设成了响应式数据，而bar是后面新增的属性，并没有通过Object.defineProperty设置成响应式数据
三、解决方案Vue 不允许在已经创建的实例上动态添加新的响应式属性
若想实现数据与视图同步更新，可采取下面三种解决方案：

Vue.set()
Object.assign()
$forcecUpdated()

Vue.set()Vue.set( target, propertyName&#x2F;index, value )
参数

&#123;Object | Array&#125; target
&#123;string | number&#125; propertyName/index
&#123;any&#125; value

返回值：设置的值
通过Vue.set向响应式对象中添加一个property，并确保这个新 property 同样是响应式的，且触发视图更新
关于Vue.set源码（省略了很多与本节不相关的代码）
源码位置：src\core\observer\index.js
function set (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123;  ...  defineReactive(ob.value, key, val)  ob.dep.notify()  return val&#125;

这里无非再次调用defineReactive方法，实现新增属性的响应式
关于defineReactive方法，内部还是通过Object.defineProperty实现属性拦截
大致代码如下：
function defineReactive(obj, key, val) &#123;    Object.defineProperty(obj, key, &#123;        get() &#123;            console.log(`get $&#123;key&#125;:$&#123;val&#125;`);            return val        &#125;,        set(newVal) &#123;            if (newVal !== val) &#123;                console.log(`set $&#123;key&#125;:$&#123;newVal&#125;`);                val = newVal            &#125;        &#125;    &#125;)&#125;



Object.assign()直接使用Object.assign()添加到对象的新属性不会触发更新
应创建一个新的对象，合并原对象和混入对象的属性
this.someObject = Object.assign(&#123;&#125;,this.someObject,&#123;newProperty1:1,newProperty2:2 ...&#125;)



$forceUpdate如果你发现你自己需要在 Vue 中做一次强制更新，99.9% 的情况，是你在某个地方做错了事
$forceUpdate迫使 Vue 实例重新渲染
PS：仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。
小结
如果为对象添加少量的新属性，可以直接采用Vue.set()

如果需要为新对象添加大量的新属性，则通过Object.assign()创建新对象

如果你实在不知道怎么操作时，可采取$forceUpdate()进行强制刷新 (不建议)


PS：vue3是用过proxy实现数据响应式的，直接动态添加新属性仍可以实现数据响应式
参考文献
https://cn.vuejs.org/v2/api/#Vue-set
https://vue3js.cn/docs/zh

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>你有写过自定义指令吗？自定义指令的应用场景有哪些？</title>
    <url>/2024/11/15/vue-directive/</url>
    <content><![CDATA[  
一、什么是指令开始之前我们先学习一下指令系统这个词
指令系统是计算机硬件的语言系统，也叫机器语言，它是系统程序员看到的计算机的主要属性。因此指令系统表征了计算机的基本功能决定了机器所要求的能力
在vue中提供了一套为数据驱动视图更为方便的操作，这些操作被称为指令系统
我们看到的v- 开头的行内属性，都是指令，不同的指令可以完成或实现不同的功能
除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令
指令使用的几种方式：
//会实例化一个指令，但这个指令没有参数 `v-xxx`// -- 将值传到指令中`v-xxx=&quot;value&quot;`  // -- 将字符串传入到指令中，如`v-html=&quot;&#x27;&lt;p&gt;内容&lt;/p&gt;&#x27;&quot;``v-xxx=&quot;&#x27;string&#x27;&quot;` // -- 传参数（`arg`），如`v-bind:class=&quot;className&quot;``v-xxx:arg=&quot;value&quot;` // -- 使用修饰符（`modifier`）`v-xxx:arg.modifier=&quot;value&quot;` 

二、如何实现注册一个自定义指令有全局注册与局部注册
全局注册主要是通过Vue.directive方法进行注册
Vue.directive第一个参数是指令的名字（不需要写上v-前缀），第二个参数可以是对象数据，也可以是一个指令函数
// 注册一个全局自定义指令 `v-focus`Vue.directive(&#x27;focus&#x27;, &#123;  // 当被绑定的元素插入到 DOM 中时……  inserted: function (el) &#123;    // 聚焦元素    el.focus()  // 页面加载完成之后自动让输入框获取到焦点的小功能  &#125;&#125;)

局部注册通过在组件options选项中设置directive属性
directives: &#123;  focus: &#123;    // 指令的定义    inserted: function (el) &#123;      el.focus() // 页面加载完成之后自动让输入框获取到焦点的小功能    &#125;  &#125;&#125;

然后你可以在模板中任何元素上使用新的 v-focus property，如下：
&lt;input v-focus /&gt;

自定义指令也像组件那样存在钩子函数：

bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置

inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)

update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新

componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用

unbind：只调用一次，指令与元素解绑时调用


所有的钩子函数的参数都有以下：

el：指令所绑定的元素，可以用来直接操作 DOM
binding：一个对象，包含以下 property：
name：指令名，不包括 v- 前缀。
value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。
oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。
expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 &quot;1 + 1&quot;。
arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。
modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 &#123; foo: true, bar: true &#125;


vnode：Vue 编译生成的虚拟节点
oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用


除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行

举个例子：
&lt;div v-demo=&quot;&#123; color: &#x27;white&#x27;, text: &#x27;hello!&#x27; &#125;&quot;&gt;&lt;/div&gt;&lt;script&gt;    Vue.directive(&#x27;demo&#x27;, function (el, binding) &#123;    console.log(binding.value.color) // &quot;white&quot;    console.log(binding.value.text)  // &quot;hello!&quot;    &#125;)&lt;/script&gt;



三、应用场景使用自定义指令可以满足我们日常一些场景，这里给出几个自定义指令的案例：

表单防止重复提交
图片懒加载
一键 Copy的功能

表单防止重复提交表单防止重复提交这种情况设置一个v-throttle自定义指令来实现
举个例子：
// 1.设置v-throttle自定义指令Vue.directive(&#x27;throttle&#x27;, &#123;  bind: (el, binding) =&gt; &#123;    let throttleTime = binding.value; // 节流时间    if (!throttleTime) &#123; // 用户若不设置节流时间，则默认2s      throttleTime = 2000;    &#125;    let cbFun;    el.addEventListener(&#x27;click&#x27;, event =&gt; &#123;      if (!cbFun) &#123; // 第一次执行        cbFun = setTimeout(() =&gt; &#123;          cbFun = null;        &#125;, throttleTime);      &#125; else &#123;        event &amp;&amp; event.stopImmediatePropagation();      &#125;    &#125;, true);  &#125;,&#125;);// 2.为button标签设置v-throttle自定义指令&lt;button @click=&quot;sayHello&quot; v-throttle&gt;提交&lt;/button&gt;



图片懒加载设置一个v-lazy自定义指令完成图片懒加载
const LazyLoad = &#123;    // install方法    install(Vue,options)&#123;    	  // 代替图片的loading图        let defaultSrc = options.default;        Vue.directive(&#x27;lazy&#x27;,&#123;            bind(el,binding)&#123;                LazyLoad.init(el,binding.value,defaultSrc);            &#125;,            inserted(el)&#123;                // 兼容处理                if(&#x27;IntersectionObserver&#x27; in window)&#123;                    LazyLoad.observe(el);                &#125;else&#123;                    LazyLoad.listenerScroll(el);                &#125;                            &#125;,        &#125;)    &#125;,    // 初始化    init(el,val,def)&#123;        // data-src 储存真实src        el.setAttribute(&#x27;data-src&#x27;,val);        // 设置src为loading图        el.setAttribute(&#x27;src&#x27;,def);    &#125;,    // 利用IntersectionObserver监听el    observe(el)&#123;        let io = new IntersectionObserver(entries =&gt; &#123;            let realSrc = el.dataset.src;            if(entries[0].isIntersecting)&#123;                if(realSrc)&#123;                    el.src = realSrc;                    el.removeAttribute(&#x27;data-src&#x27;);                &#125;            &#125;        &#125;);        io.observe(el);    &#125;,    // 监听scroll事件    listenerScroll(el)&#123;        let handler = LazyLoad.throttle(LazyLoad.load,300);        LazyLoad.load(el);        window.addEventListener(&#x27;scroll&#x27;,() =&gt; &#123;            handler(el);        &#125;);    &#125;,    // 加载真实图片    load(el)&#123;        let windowHeight = document.documentElement.clientHeight        let elTop = el.getBoundingClientRect().top;        let elBtm = el.getBoundingClientRect().bottom;        let realSrc = el.dataset.src;        if(elTop - windowHeight&lt;0&amp;&amp;elBtm &gt; 0)&#123;            if(realSrc)&#123;                el.src = realSrc;                el.removeAttribute(&#x27;data-src&#x27;);            &#125;        &#125;    &#125;,    // 节流    throttle(fn,delay)&#123;        let timer;         let prevTime;        return function(...args)&#123;            let currTime = Date.now();            let context = this;            if(!prevTime) prevTime = currTime;            clearTimeout(timer);                        if(currTime - prevTime &gt; delay)&#123;                prevTime = currTime;                fn.apply(context,args);                clearTimeout(timer);                return;            &#125;            timer = setTimeout(function()&#123;                prevTime = Date.now();                timer = null;                fn.apply(context,args);            &#125;,delay);        &#125;    &#125;&#125;export default LazyLoad;



一键 Copy的功能import &#123; Message &#125; from &#x27;ant-design-vue&#x27;;const vCopy = &#123; //  /*    bind 钩子函数，第一次绑定时调用，可以在这里做初始化设置    el: 作用的 dom 对象    value: 传给指令的值，也就是我们要 copy 的值  */  bind(el, &#123; value &#125;) &#123;    el.$value = value; // 用一个全局属性来存传进来的值，因为这个值在别的钩子函数里还会用到    el.handler = () =&gt; &#123;      if (!el.$value) &#123;      // 值为空的时候，给出提示，我这里的提示是用的 ant-design-vue 的提示，你们随意        Message.warning(&#x27;无复制内容&#x27;);        return;      &#125;      // 动态创建 textarea 标签      const textarea = document.createElement(&#x27;textarea&#x27;);      // 将该 textarea 设为 readonly 防止 iOS 下自动唤起键盘，同时将 textarea 移出可视区域      textarea.readOnly = &#x27;readonly&#x27;;      textarea.style.position = &#x27;absolute&#x27;;      textarea.style.left = &#x27;-9999px&#x27;;      // 将要 copy 的值赋给 textarea 标签的 value 属性      textarea.value = el.$value;      // 将 textarea 插入到 body 中      document.body.appendChild(textarea);      // 选中值并复制      textarea.select();      // textarea.setSelectionRange(0, textarea.value.length);      const result = document.execCommand(&#x27;Copy&#x27;);      if (result) &#123;        Message.success(&#x27;复制成功&#x27;);      &#125;      document.body.removeChild(textarea);    &#125;;    // 绑定点击事件，就是所谓的一键 copy 啦    el.addEventListener(&#x27;click&#x27;, el.handler);  &#125;,  // 当传进来的值更新的时候触发  componentUpdated(el, &#123; value &#125;) &#123;    el.$value = value;  &#125;,  // 指令与元素解绑的时候，移除事件绑定  unbind(el) &#123;    el.removeEventListener(&#x27;click&#x27;, el.handler);  &#125;,&#125;;export default vCopy;

关于自定义指令还有很多应用场景，如：拖拽指令、页面水印、权限校验等等应用场景
参考文献
https://vue3js.cn/docs/zh
https://juejin.cn/post/6844904197448531975#heading-5
https://www.cnblogs.com/chenwenhao/p/11924161.html#_label2

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么data属性是一个函数而不是一个对象？</title>
    <url>/2024/11/21/vue-data/</url>
    <content><![CDATA[ 
一、实例和组件定义data的区别vue实例的时候定义data属性既可以是一个对象，也可以是一个函数
const app = new Vue(&#123;    el:&quot;#app&quot;,    // 对象格式    data:&#123;        foo:&quot;foo&quot;    &#125;,    // 函数格式    data()&#123;        return &#123;             foo:&quot;foo&quot;        &#125;    &#125;&#125;)

组件中定义data属性，只能是一个函数
如果为组件data直接定义为一个对象
Vue.component(&#x27;component1&#x27;,&#123;    template:`&lt;div&gt;组件&lt;/div&gt;`,    data:&#123;        foo:&quot;foo&quot;    &#125;&#125;)

则会得到警告信息
 
警告说明：返回的data应该是一个函数在每一个组件实例中
二、组件data定义函数与对象的区别上面讲到组件data必须是一个函数，不知道大家有没有思考过这是为什么呢？
在我们定义好一个组件的时候，vue最终都会通过Vue.extend()构成组件实例
这里我们模仿组件构造函数，定义data属性，采用对象的形式
function Component()&#123; &#125;Component.prototype.data = &#123;	count : 0&#125;

创建两个组件实例
const componentA = new Component()const componentB = new Component()

修改componentA组件data属性的值，componentB中的值也发生了改变
console.log(componentB.data.count)  // 0componentA.data.count = 1console.log(componentB.data.count)  // 1

产生这样的原因这是两者共用了同一个内存地址，componentA修改的内容，同样对componentB产生了影响
如果我们采用函数的形式，则不会出现这种情况（函数返回的对象内存地址并不相同）
function Component()&#123;	this.data = this.data()&#125;Component.prototype.data = function ()&#123;    return &#123;   		count : 0    &#125;&#125;

修改componentA组件data属性的值，componentB中的值不受影响
console.log(componentB.data.count)  // 0componentA.data.count = 1console.log(componentB.data.count)  // 0

vue组件可能会有很多个实例，采用函数返回一个全新data形式，使每个实例对象的数据不会受到其他实例对象数据的污染
三、原理分析首先可以看看vue初始化data的代码，data的定义可以是函数也可以是对象
源码位置：/vue-dev/src/core/instance/state.js
function initData (vm: Component) &#123;  let data = vm.$options.data  data = vm._data = typeof data === &#x27;function&#x27;    ? getData(data, vm)    : data || &#123;&#125;    ...&#125;
data既能是object也能是function，那为什么还会出现上文警告呢？
别急，继续看下文
组件在创建的时候，会进行选项的合并
源码位置：/vue-dev/src/core/util/options.js
自定义组件会进入mergeOptions进行选项合并
Vue.prototype._init = function (options?: Object) &#123;    ...    // merge options    if (options &amp;&amp; options._isComponent) &#123;      // optimize internal component instantiation      // since dynamic options merging is pretty slow, and none of the      // internal component options needs special treatment.      initInternalComponent(vm, options)    &#125; else &#123;      vm.$options = mergeOptions(        resolveConstructorOptions(vm.constructor),        options || &#123;&#125;,        vm      )    &#125;    ...  &#125;

定义data会进行数据校验
源码位置：/vue-dev/src/core/instance/init.js
这时候vm实例为undefined，进入if判断，若data类型不是function，则出现警告提示
strats.data = function (  parentVal: any,  childVal: any,  vm?: Component): ?Function &#123;  if (!vm) &#123;    if (childVal &amp;&amp; typeof childVal !== &quot;function&quot;) &#123;      process.env.NODE_ENV !== &quot;production&quot; &amp;&amp;        warn(          &#x27;The &quot;data&quot; option should be a function &#x27; +            &quot;that returns a per-instance value in component &quot; +            &quot;definitions.&quot;,          vm        );      return parentVal;    &#125;    return mergeDataOrFn(parentVal, childVal);  &#125;  return mergeDataOrFn(parentVal, childVal, vm);&#125;;

四、结论
根实例对象data可以是对象也可以是函数（根实例是单例），不会产生数据污染情况
组件实例对象data必须为函数，目的是为了防止多个组件实例对象之间共用一个data，产生数据污染。采用函数的形式，initData时会将其作为工厂函数都会返回全新data对象

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>你是怎么处理vue项目中的错误的？</title>
    <url>/2024/11/12/vue-error/</url>
    <content><![CDATA[ 
一、错误类型任何一个框架，对于错误的处理都是一种必备的能力
在Vue 中，则是定义了一套对应的错误处理规则给到使用者，且在源代码级别，对部分必要的过程做了一定的错误处理。
主要的错误来源包括：

后端接口错误
代码中本身逻辑错误

二、如何处理后端接口错误通过axios的interceptor实现网络请求的response先进行一层拦截
apiClient.interceptors.response.use(  response =&gt; &#123;    return response;  &#125;,  error =&gt; &#123;    if (error.response.status == 401) &#123;      router.push(&#123; name: &quot;Login&quot; &#125;);    &#125; else &#123;      message.error(&quot;出错了&quot;);      return Promise.reject(error);    &#125;  &#125;);



代码逻辑问题全局设置错误处理设置全局错误处理函数
Vue.config.errorHandler = function (err, vm, info) &#123;  // handle error  // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子  // 只在 2.2.0+ 可用&#125;

errorHandler指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例
不过值得注意的是，在不同 Vue 版本中，该全局 API 作用的范围会有所不同：

从 2.2.0 起，这个钩子也会捕获组件生命周期钩子里的错误。同样的，当这个钩子是 undefined 时，被捕获的错误会通过 console.error 输出而避免应用崩


从 2.4.0 起，这个钩子也会捕获 Vue 自定义事件处理函数内部的错误了


从 2.6.0 起，这个钩子也会捕获 v-on DOM 监听器内部抛出的错误。另外，如果任何被覆盖的钩子或处理函数返回一个 Promise 链 (例如 async 函数)，则来自其 Promise 链的错误也会被处理

生命周期钩子errorCaptured是 2.5.0 新增的一个生命钩子函数，当捕获到一个来自子孙组件的错误时被调用
基本类型
(err: Error, vm: Component, info: string) =&gt; ?boolean

此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播
参考官网，错误传播规则如下：

默认情况下，如果全局的 config.errorHandler 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报
如果一个组件的继承或父级从属链路中存在多个 errorCaptured 钩子，则它们将会被相同的错误逐个唤起。
如果此 errorCaptured 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 config.errorHandler
一个 errorCaptured 钩子能够返回 false 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 errorCaptured 钩子和全局的 config.errorHandler

下面来看个例子
定义一个父组件cat
Vue.component(&#x27;cat&#x27;, &#123;    template:`        &lt;div&gt;			&lt;h1&gt;Cat: &lt;/h1&gt;        	&lt;slot&gt;&lt;/slot&gt;        &lt;/div&gt;`,    props:&#123;        name:&#123;            required:true,            type:String        &#125;    &#125;,    errorCaptured(err,vm,info) &#123;        console.log(`cat EC: $&#123;err.toString()&#125;\ninfo: $&#123;info&#125;`);         return false;    &#125;&#125;);

定义一个子组件kitten，其中dontexist()并没有定义，存在错误
Vue.component(&#x27;kitten&#x27;, &#123;    template:&#x27;&lt;div&gt;&lt;h1&gt;Kitten: &#123;&#123; dontexist() &#125;&#125;&lt;/h1&gt;&lt;/div&gt;&#x27;,    props:&#123;        name:&#123;            required:true,            type:String        &#125;    &#125;&#125;);

页面中使用组件
&lt;div id=&quot;app&quot; v-cloak&gt;    &lt;cat name=&quot;my cat&quot;&gt;        &lt;kitten&gt;&lt;/kitten&gt;    &lt;/cat&gt;&lt;/div&gt;

在父组件的errorCaptured则能够捕获到信息
cat EC: TypeError: dontexist is not a functioninfo: render



三、源码分析异常处理源码
源码位置：&#x2F;src&#x2F;core&#x2F;util&#x2F;error.js
// Vue 全局配置,也就是上面的Vue.configimport config from &#x27;../config&#x27;import &#123; warn &#125; from &#x27;./debug&#x27;// 判断环境import &#123; inBrowser, inWeex &#125; from &#x27;./env&#x27;// 判断是否是Promise，通过val.then === &#x27;function&#x27; &amp;&amp; val.catch === &#x27;function&#x27;, val ！=== null &amp;&amp; val !== undefinedimport &#123; isPromise &#125; from &#x27;shared/util&#x27;// 当错误函数处理错误时，停用deps跟踪以避免可能出现的infinite rendering// 解决以下出现的问题https://github.com/vuejs/vuex/issues/1505的问题import &#123; pushTarget, popTarget &#125; from &#x27;../observer/dep&#x27;export function handleError (err: Error, vm: any, info: string) &#123;    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.    pushTarget()    try &#123;        // vm指当前报错的组件实例        if (vm) &#123;            let cur = vm            // 首先获取到报错的组件，之后递归查找当前组件的父组件，依次调用errorCaptured 方法。            // 在遍历调用完所有 errorCaptured 方法、或 errorCaptured 方法有报错时，调用 globalHandleError 方法            while ((cur = cur.$parent)) &#123;                const hooks = cur.$options.errorCaptured                // 判断是否存在errorCaptured钩子函数                if (hooks) &#123;                    // 选项合并的策略，钩子函数会被保存在一个数组中                    for (let i = 0; i &lt; hooks.length; i++) &#123;                        // 如果errorCaptured 钩子执行自身抛出了错误，                        // 则用try&#123;&#125;catch&#123;&#125;捕获错误，将这个新错误和原本被捕获的错误都会发送给全局的config.errorHandler                        // 调用globalHandleError方法                        try &#123;                            // 当前errorCaptured执行，根据返回是否是false值                            // 是false，capture = true，阻止其它任何会被这个错误唤起的 errorCaptured 钩子和全局的 config.errorHandler                            // 是true capture = fale，组件的继承或父级从属链路中存在的多个 errorCaptured 钩子，会被相同的错误逐个唤起                            // 调用对应的钩子函数，处理错误                            const capture = hooks[i].call(cur, err, vm, info) === false                            if (capture) return                        &#125; catch (e) &#123;                            globalHandleError(e, cur, &#x27;errorCaptured hook&#x27;)                        &#125;                    &#125;                &#125;            &#125;        &#125;        // 除非禁止错误向上传播，否则都会调用全局的错误处理函数        globalHandleError(err, vm, info)    &#125; finally &#123;        popTarget()    &#125;&#125;// 异步错误处理函数export function invokeWithErrorHandling (handler: Function, context: any, args: null | any[],    vm: any,        info: string        ) &#123;            let res            try &#123;                // 根据参数选择不同的handle执行方式                res = args ? handler.apply(context, args) : handler.call(context)                // handle返回结果存在                // res._isVue an flag to avoid this being observed，如果传入值的_isVue为ture时(即传入的值是Vue实例本身)不会新建observer实例                // isPromise(res) 判断val.then === &#x27;function&#x27; &amp;&amp; val.catch === &#x27;function&#x27;, val ！=== null &amp;&amp; val !== undefined                // !res._handled  _handle是Promise 实例的内部变量之一，默认是false，代表onFulfilled,onRejected是否被处理                if (res &amp;&amp; !res._isVue &amp;&amp; isPromise(res) &amp;&amp; !res._handled) &#123;                    res.catch(e =&gt; handleError(e, vm, info + ` (Promise/async)`))                    // avoid catch triggering multiple times when nested calls                    // 避免嵌套调用时catch多次的触发                    res._handled = true                &#125;            &#125; catch (e) &#123;                // 处理执行错误                handleError(e, vm, info)            &#125;            return res        &#125;//全局错误处理function globalHandleError (err, vm, info) &#123;    // 获取全局配置，判断是否设置处理函数，默认undefined    // 已配置    if (config.errorHandler) &#123;        // try&#123;&#125;catch&#123;&#125; 住全局错误处理函数        try &#123;            // 执行设置的全局错误处理函数，handle error 想干啥就干啥💗            return config.errorHandler.call(null, err, vm, info)        &#125; catch (e) &#123;            // 如果开发者在errorHandler函数中手动抛出同样错误信息throw err            // 判断err信息是否相等，避免log两次            // 如果抛出新的错误信息throw err Error(&#x27;你好毒&#x27;)，将会一起log输出            if (e !== err) &#123;                logError(e, null, &#x27;config.errorHandler&#x27;)            &#125;        &#125;    &#125;    // 未配置常规log输出    logError(err, vm, info)&#125;// 错误输出函数function logError (err, vm, info) &#123;    if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;        warn(`Error in $&#123;info&#125;: &quot;$&#123;err.toString()&#125;&quot;`, vm)    &#125;    /* istanbul ignore else */    if ((inBrowser || inWeex) &amp;&amp; typeof console !== &#x27;undefined&#x27;) &#123;        console.error(err)    &#125; else &#123;        throw err    &#125;&#125;

小结
handleError在需要捕获异常的地方调用，首先获取到报错的组件，之后递归查找当前组件的父组件，依次调用errorCaptured 方法，在遍历调用完所有 errorCaptured 方法或 errorCaptured 方法有报错时，调用 globalHandleError 方法
globalHandleError 调用全局的 errorHandler 方法，再通过logError判断环境输出错误信息
invokeWithErrorHandling更好的处理异步错误信息
logError判断环境，选择不同的抛错方式。非生产环境下，调用warn方法处理错误

参考文献
https://juejin.cn/post/6844904096936230925

https://segmentfault.com/a/1190000018606181


]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中的过滤器了解吗？过滤器的应用场景有哪些？</title>
    <url>/2024/10/31/vue-filter/</url>
    <content><![CDATA[ 
一、是什么过滤器（filter）是输送介质管道上不可缺少的一种装置
大白话，就是把一些不必要的东西过滤掉
过滤器实质不改变原始数据，只是对数据进行加工处理后返回过滤后的数据再进行调用处理，我们也可以理解其为一个纯函数
Vue 允许你自定义过滤器，可被用于一些常见的文本格式化
ps: Vue3中已废弃filter
二、如何用vue中的过滤器可以用在两个地方：双花括号插值和 v-bind 表达式，过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示：
&lt;!-- 在双花括号中 --&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;!-- 在 `v-bind` 中 --&gt;&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;

定义filter在组件的选项中定义本地的过滤器
filters: &#123;  capitalize: function (value) &#123;    if (!value) return &#x27;&#x27;    value = value.toString()    return value.charAt(0).toUpperCase() + value.slice(1)  &#125;&#125;

定义全局过滤器：
Vue.filter(&#x27;capitalize&#x27;, function (value) &#123;  if (!value) return &#x27;&#x27;  value = value.toString()  return value.charAt(0).toUpperCase() + value.slice(1)&#125;)new Vue(&#123;  // ...&#125;)

注意：当全局过滤器和局部过滤器重名时，会采用局部过滤器
过滤器函数总接收表达式的值 (之前的操作链的结果) 作为第一个参数。在上述例子中，capitalize 过滤器函数将会收到 message 的值作为第一个参数
过滤器可以串联：
&#123;&#123; message | filterA | filterB &#125;&#125;

在这个例子中，filterA 被定义为接收单个参数的过滤器函数，表达式 message 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 filterB，将 filterA 的结果传递到 filterB 中。
过滤器是 JavaScript 函数，因此可以接收参数：
&#123;&#123; message | filterA(&#x27;arg1&#x27;, arg2) &#125;&#125;

这里，filterA 被定义为接收三个参数的过滤器函数。
其中 message 的值作为第一个参数，普通字符串 &#39;arg1&#39; 作为第二个参数，表达式 arg2 的值作为第三个参数
举个例子：
&lt;div id=&quot;app&quot;&gt;    &lt;p&gt;&#123;&#123; msg | msgFormat(&#x27;疯狂&#x27;,&#x27;--&#x27;)&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;    // 定义一个 Vue 全局的过滤器，名字叫做  msgFormat    Vue.filter(&#x27;msgFormat&#x27;, function(msg, arg, arg2) &#123;        // 字符串的  replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则        return msg.replace(/单纯/g, arg+arg2)    &#125;)&lt;/script&gt;

小结：
部过滤器优先于全局过滤器被调用
一个表达式可以使用多个过滤器。过滤器之间需要用管道符“|”隔开。其执行顺序从左往右

三、应用场景平时开发中，需要用到过滤器的地方有很多，比如单位转换、数字打点、文本格式化、时间格式化之类的等
比如我们要实现将30000 &#x3D;&gt; 30,000，这时候我们就需要使用过滤器
Vue.filter(&#x27;toThousandFilter&#x27;, function (value) &#123;     if (!value) return &#x27;&#x27;     value = value.toString()     return .replace(str.indexOf(&#x27;.&#x27;) &gt; -1 ? /(\d)(?=(\d&#123;3&#125;)+\.)/g : /(\d)(?=(?:\d&#123;3&#125;)+$)/g, &#x27;$1,&#x27;)&#125;)



四、原理分析使用过滤器
&#123;&#123; message | capitalize &#125;&#125;

在模板编译阶段过滤器表达式将会被编译为过滤器函数，主要是用过parseFilters，我们放到最后讲
_s(_f(&#x27;filterFormat&#x27;)(message))

首先分析一下_f：
_f 函数全名是：resolveFilter，这个函数的作用是从this.$options.filters中找出注册的过滤器并返回
// 变为this.$options.filters[&#x27;filterFormat&#x27;](message) // message为参数

关于resolveFilter
import &#123; indentity,resolveAsset &#125; from &#x27;core/util/index&#x27; export function resolveFilter(id)&#123;    return resolveAsset(this.$options,&#x27;filters&#x27;,id,true) || identity&#125;

内部直接调用resolveAsset，将option对象，类型，过滤器id，以及一个触发警告的标志作为参数传递，如果找到，则返回过滤器；
resolveAsset的代码如下：
export function resolveAsset(options,type,id,warnMissing)&#123; // 因为我们找的是过滤器，所以在 resolveFilter函数中调用时 type 的值直接给的 &#x27;filters&#x27;,实际这个函数还可以拿到其他很多东西    if(typeof id !== &#x27;string&#x27;)&#123; // 判断传递的过滤器id 是不是字符串，不是则直接返回        return     &#125;    const assets = options[type]  // 将我们注册的所有过滤器保存在变量中    // 接下来的逻辑便是判断id是否在assets中存在，即进行匹配    if(hasOwn(assets,id)) return assets[id] // 如找到，直接返回过滤器    // 没有找到，代码继续执行    const camelizedId  = camelize(id) // 万一你是驼峰的呢    if(hasOwn(assets,camelizedId)) return assets[camelizedId]    // 没找到，继续执行    const PascalCaseId = capitalize(camelizedId) // 万一你是首字母大写的驼峰呢    if(hasOwn(assets,PascalCaseId)) return assets[PascalCaseId]    // 如果还是没找到，则检查原型链(即访问属性)    const result = assets[id] || assets[camelizedId] || assets[PascalCaseId]    // 如果依然没找到，则在非生产环境的控制台打印警告    if(process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warnMissing &amp;&amp; !result)&#123;        warn(&#x27;Failed to resolve &#x27; + type.slice(0,-1) + &#x27;: &#x27; + id, options)    &#125;    // 无论是否找到，都返回查找结果    return result&#125;

下面再来分析一下_s：
 _s 函数的全称是 toString,过滤器处理后的结果会当作参数传递给 toString函数，最终 toString函数执行后的结果会保存到Vnode中的text属性中，渲染到视图中
function toString(value)&#123;    return value == null    ? &#x27;&#x27;    : typeof value === &#x27;object&#x27;      ? JSON.stringify(value,null,2)// JSON.stringify()第三个参数可用来控制字符串里面的间距      : String(value)&#125;

最后，在分析下parseFilters，在模板编译阶段使用该函数阶段将模板过滤器解析为过滤器函数调用表达式
function parseFilters (filter) &#123;    let filters = filter.split(&#x27;|&#x27;)    let expression = filters.shift().trim() // shift()删除数组第一个元素并将其返回，该方法会更改原数组    let i    if (filters) &#123;        for(i = 0;i &lt; filters.length;i++)&#123;            experssion = warpFilter(expression,filters[i].trim()) // 这里传进去的expression实际上是管道符号前面的字符串，即过滤器的第一个参数        &#125;    &#125;    return expression&#125;// warpFilter函数实现function warpFilter(exp,filter)&#123;    // 首先判断过滤器是否有其他参数    const i = filter.indexof(&#x27;(&#x27;)    if(i&lt;0)&#123; // 不含其他参数，直接进行过滤器表达式字符串的拼接        return `_f(&quot;$&#123;filter&#125;&quot;)($&#123;exp&#125;)`    &#125;else&#123;        const name = filter.slice(0,i) // 过滤器名称        const args = filter.slice(i+1) // 参数，但还多了 ‘)’        return `_f(&#x27;$&#123;name&#125;&#x27;)($&#123;exp&#125;,$&#123;args&#125;` // 注意这一步少给了一个 &#x27;)&#x27;    &#125;&#125;

小结：
在编译阶段通过parseFilters将过滤器编译成函数调用（串联过滤器则是一个嵌套的函数调用，前一个过滤器执行的结果是后一个过滤器函数的参数）
编译后通过调用resolveFilter函数找到对应过滤器并返回结果
执行结果作为参数传递给toString函数，而toString执行后，其结果会保存在Vnode的text属性中，渲染到视图

参考文献
https://cn.vuejs.org/v2/guide/filters.html#ad
https://blog.csdn.net/weixin_42724176/article/details/105546684
https://vue3js.cn

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>SPA首屏加载速度慢的怎么解决？</title>
    <url>/2024/10/21/vue-first-page-time/</url>
    <content><![CDATA[
一、什么是首屏加载首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容
首屏加载可以说是用户体验中最重要的环节
关于计算首屏时间利用performance.timing提供的数据：

通过DOMContentLoad或者performance来计算出首屏时间
// 方案一：document.addEventListener(&#x27;DOMContentLoaded&#x27;, (event) =&gt; &#123;    console.log(&#x27;first contentful painting&#x27;);&#125;);// 方案二：performance.getEntriesByName(&quot;first-contentful-paint&quot;)[0].startTime// performance.getEntriesByName(&quot;first-contentful-paint&quot;)[0]// 会返回一个 PerformancePaintTiming的实例，结构如下：&#123;  name: &quot;first-contentful-paint&quot;,  entryType: &quot;paint&quot;,  startTime: 507.80000002123415,  duration: 0,&#125;;

二、加载慢的原因在页面渲染的过程，导致加载速度慢的因素可能如下：

网络延时问题
资源文件体积是否过大
资源是否重复发送请求去加载了
加载脚本的时候，渲染内容堵塞了

三、解决方案常见的几种 SPA 首屏优化方式

减小入口文件积
静态资源本地缓存
UI 框架按需加载
图片资源的压缩
组件重复打包
开启 GZip 压缩
使用 SSR

减小入口文件体积常用的手段是路由懒加载，把不同路由对应的组件分割成不同的代码块，待路由被请求的时候会单独打包路由，使得入口文件变小，加载速度大大增加

在vue-router配置路由的时候，采用动态加载路由的形式
routes:[    path: &#x27;Blogs&#x27;,    name: &#x27;ShowBlogs&#x27;,    component: () =&gt; import(&#x27;./components/ShowBlogs.vue&#x27;)]

以函数的形式加载路由，这样就可以把各自的路由文件分别打包，只有在解析给定的路由时，才会加载路由组件
静态资源本地缓存后端返回资源问题：

采用HTTP缓存，设置Cache-Control，Last-Modified，Etag等响应头

采用Service Worker离线缓存


前端合理利用localStorage
UI 框架按需加载在日常使用UI框架，例如element-UI、或者antd，我们经常性直接引用整个UI库
import ElementUI from &quot;element-ui&quot;;Vue.use(ElementUI);

但实际上我用到的组件只有按钮，分页，表格，输入与警告 所以我们要按需引用
import &#123;  Button,  Input,  Pagination,  Table,  TableColumn,  MessageBox,&#125; from &quot;element-ui&quot;;Vue.use(Button);Vue.use(Input);Vue.use(Pagination);

组件重复打包假设A.js文件是一个常用的库，现在有多个路由使用了A.js文件，这就造成了重复下载
解决方案：在webpack的config文件中，修改CommonsChunkPlugin的配置
minChunks: 3;

minChunks为 3 表示会把使用 3 次及以上的包抽离出来，放进公共依赖文件，避免了重复加载组件
图片资源的压缩图片资源虽然不在编码过程中，但它却是对页面性能影响最大的因素
对于所有的图片资源，我们可以进行适当的压缩
对页面上使用到的icon，可以使用在线字体图标，或者雪碧图，将众多小图标合并到同一张图上，用以减轻http请求压力。
开启 GZip 压缩拆完包之后，我们再用gzip做一下压缩 安装compression-webpack-plugin
cnmp i compression-webpack-plugin -D

在vue.congig.js中引入并修改webpack配置
const CompressionPlugin = require(&#x27;compression-webpack-plugin&#x27;)configureWebpack: (config) =&gt; &#123;        if (process.env.NODE_ENV === &#x27;production&#x27;) &#123;            // 为生产环境修改配置...            config.mode = &#x27;production&#x27;            return &#123;                plugins: [new CompressionPlugin(&#123;                    test: /\.js$|\.html$|\.css/, //匹配文件名                    threshold: 10240, //对超过10k的数据进行压缩                    deleteOriginalAssets: false //是否删除原文件                &#125;)]            &#125;        &#125;

在服务器我们也要做相应的配置 如果发送请求的浏览器支持gzip，就发送给它gzip格式的文件 我的服务器是用express框架搭建的 只要安装一下compression就能使用
const compression = require(&#x27;compression&#x27;)app.use(compression())  // 在其他中间件使用之前调用

使用 SSRSSR（Server side ），也就是服务端渲染，组件或页面通过服务器生成 html 字符串，再发送到浏览器
从头搭建一个服务端渲染是很复杂的，vue应用建议使用Nuxt.js实现服务端渲染
小结：减少首屏渲染时间的方法有很多，总的来讲可以分成两大部分 ：资源加载优化 和 页面渲染优化
下图是更为全面的首屏优化的方案

大家可以根据自己项目的情况选择各种方式进行首屏渲染的优化
参考文献
https://zhuanlan.zhihu.com/p/88639980?utm_source=wechat_session
https://www.chengrang.com/how-browsers-work.html
https://juejin.cn/post/6844904185264095246
https://vue3js.cn/docs/zh

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Vue3 的前端工程化实践</title>
    <url>/2024/10/11/vue-frontend-engineering/</url>
    <content><![CDATA[一、工程化概述Vue3 项目工程化主要包含以下几个方面：

项目搭建（Vite + Vue3 + TypeScript）
代码规范
组件设计
状态管理
自动化部署

二、具体实现1. 项目搭建1.1 目录结构├── src/│   ├── api/          # API 接口│   ├── assets/       # 静态资源│   ├── components/   # 公共组件│   ├── composables/  # 组合式函数│   ├── layouts/      # 布局组件│   ├── pages/        # 页面组件│   ├── stores/       # Pinia 状态管理│   ├── styles/       # 全局样式│   ├── types/        # 类型定义│   └── App.vue       # 根组件├── env.d.ts          # 环境变量类型声明├── vite.config.ts    # Vite 配置└── tsconfig.json     # TypeScript 配置

1.2 基础配置// vite.config.tsimport &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import Components from &#x27;unplugin-vue-components/vite&#x27;import AutoImport from &#x27;unplugin-auto-import/vite&#x27;import &#123; ElementPlusResolver &#125; from &#x27;unplugin-vue-components/resolvers&#x27;export default defineConfig(&#123;  plugins: [    vue(),    // 自动导入组件    Components(&#123;      resolvers: [ElementPlusResolver()],      dts: &#x27;src/types/components.d.ts&#x27;    &#125;),    // 自动导入 API    AutoImport(&#123;      imports: [&#x27;vue&#x27;, &#x27;vue-router&#x27;, &#x27;pinia&#x27;],      resolvers: [ElementPlusResolver()],      dts: &#x27;src/types/auto-imports.d.ts&#x27;    &#125;)  ],  resolve: &#123;    alias: &#123;      &#x27;@&#x27;: &#x27;/src&#x27;    &#125;  &#125;&#125;)

2. 组件设计规范2.1 组件基本结构&lt;!-- UserProfile.vue --&gt;&lt;script setup lang=&quot;ts&quot;&gt;interface Props &#123;  userId: string  role?: &#x27;admin&#x27; | &#x27;user&#x27;&#125;// 属性定义const props = withDefaults(defineProps&lt;Props&gt;(), &#123;  role: &#x27;user&#x27;&#125;)// 事件定义const emit = defineEmits&lt;&#123;  (e: &#x27;update&#x27;, id: string): void  (e: &#x27;delete&#x27;, id: string): void&#125;&gt;()// 组合式函数const &#123; user, loading, error &#125; = useUser(props.userId)// 方法定义const handleUpdate = () =&gt; &#123;  emit(&#x27;update&#x27;, props.userId)&#125;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;user-profile&quot;&gt;    &lt;el-card v-loading=&quot;loading&quot;&gt;      &lt;template #header&gt;        &lt;span&gt;&#123;&#123; user?.name &#125;&#125;&lt;/span&gt;      &lt;/template&gt;            &lt;div class=&quot;user-info&quot;&gt;        &lt;el-descriptions :column=&quot;2&quot;&gt;          &lt;el-descriptions-item label=&quot;Email&quot;&gt;            &#123;&#123; user?.email &#125;&#125;          &lt;/el-descriptions-item&gt;          &lt;el-descriptions-item label=&quot;Role&quot;&gt;            &#123;&#123; props.role &#125;&#125;          &lt;/el-descriptions-item&gt;        &lt;/el-descriptions&gt;      &lt;/div&gt;            &lt;div class=&quot;actions&quot;&gt;        &lt;el-button @click=&quot;handleUpdate&quot;&gt;          更新        &lt;/el-button&gt;      &lt;/div&gt;    &lt;/el-card&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.user-profile &#123;  .user-info &#123;    margin: 16px 0;  &#125;    .actions &#123;    text-align: right;  &#125;&#125;&lt;/style&gt;

2.2 组合式函数// composables/useUser.tsimport type &#123; User &#125; from &#x27;@/types&#x27;export function useUser(id: string) &#123;  const user = ref&lt;User | null&gt;(null)  const loading = ref(true)  const error = ref&lt;Error | null&gt;(null)    const fetchUser = async () =&gt; &#123;    try &#123;      loading.value = true      const data = await userApi.getUser(id)      user.value = data    &#125; catch (e) &#123;      error.value = e as Error    &#125; finally &#123;      loading.value = false    &#125;  &#125;    onMounted(() =&gt; &#123;    fetchUser()  &#125;)    return &#123;    user,    loading,    error,    refresh: fetchUser  &#125;&#125;

3. 状态管理3.1 Pinia Store 设计// stores/user.tsimport &#123; defineStore &#125; from &#x27;pinia&#x27;import type &#123; User &#125; from &#x27;@/types&#x27;export const useUserStore = defineStore(&#x27;user&#x27;, &#123;  state: () =&gt; (&#123;    currentUser: null as User | null,    users: [] as User[],    loading: false  &#125;),    getters: &#123;    isAdmin: (state) =&gt; state.currentUser?.role === &#x27;admin&#x27;,    userById: (state) =&gt; &#123;      return (id: string) =&gt; state.users.find(u =&gt; u.id === id)    &#125;  &#125;,    actions: &#123;    async fetchUsers() &#123;      this.loading = true      try &#123;        const users = await userApi.getUsers()        this.users = users      &#125; finally &#123;        this.loading = false      &#125;    &#125;,        async updateUser(id: string, data: Partial&lt;User&gt;) &#123;      const user = await userApi.updateUser(id, data)      const index = this.users.findIndex(u =&gt; u.id === id)      if (index &gt; -1) &#123;        this.users[index] = user      &#125;    &#125;  &#125;&#125;)

4. 路由配置4.1 基于角色的路由控制// router/index.tsimport &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;import &#123; useUserStore &#125; from &#x27;@/stores/user&#x27;const router = createRouter(&#123;  history: createWebHistory(),  routes: [    &#123;      path: &#x27;/dashboard&#x27;,      component: () =&gt; import(&#x27;@/pages/Dashboard.vue&#x27;),      meta: &#123; requiresAuth: true &#125;    &#125;,    &#123;      path: &#x27;/admin&#x27;,      component: () =&gt; import(&#x27;@/pages/Admin.vue&#x27;),      meta: &#123; requiresAuth: true, roles: [&#x27;admin&#x27;] &#125;    &#125;  ]&#125;)router.beforeEach(async (to, from, next) =&gt; &#123;  const userStore = useUserStore()    if (to.meta.requiresAuth &amp;&amp; !userStore.currentUser) &#123;    next(&#x27;/login&#x27;)    return  &#125;    if (to.meta.roles &amp;&amp; !to.meta.roles.includes(userStore.currentUser?.role)) &#123;    next(&#x27;/403&#x27;)    return  &#125;    next()&#125;)export default router

5. API 封装5.1 请求封装// utils/request.tsimport axios from &#x27;axios&#x27;import type &#123; AxiosInstance, AxiosRequestConfig &#125; from &#x27;axios&#x27;class Request &#123;  private instance: AxiosInstance    constructor(config: AxiosRequestConfig) &#123;    this.instance = axios.create(config)    this.setupInterceptors()  &#125;    private setupInterceptors() &#123;    this.instance.interceptors.request.use(      config =&gt; &#123;        // 添加 token        const token = localStorage.getItem(&#x27;token&#x27;)        if (token) &#123;          config.headers.Authorization = `Bearer $&#123;token&#125;`        &#125;        return config      &#125;,      error =&gt; Promise.reject(error)    )        this.instance.interceptors.response.use(      response =&gt; response.data,      error =&gt; &#123;        if (error.response?.status === 401) &#123;          // 处理未授权          router.push(&#x27;/login&#x27;)        &#125;        return Promise.reject(error)      &#125;    )  &#125;    public request&lt;T = any&gt;(config: AxiosRequestConfig): Promise&lt;T&gt; &#123;    return this.instance.request(config)  &#125;&#125;export const request = new Request(&#123;  baseURL: import.meta.env.VITE_API_BASE_URL,  timeout: 10000&#125;)

5.2 API 模块化// api/user.tsimport &#123; request &#125; from &#x27;@/utils/request&#x27;import type &#123; User &#125; from &#x27;@/types&#x27;export const userApi = &#123;  getUsers() &#123;    return request.request&lt;User[]&gt;(&#123;      url: &#x27;/users&#x27;,      method: &#x27;GET&#x27;    &#125;)  &#125;,    getUser(id: string) &#123;    return request.request&lt;User&gt;(&#123;      url: `/users/$&#123;id&#125;`,      method: &#x27;GET&#x27;    &#125;)  &#125;,    updateUser(id: string, data: Partial&lt;User&gt;) &#123;    return request.request&lt;User&gt;(&#123;      url: `/users/$&#123;id&#125;`,      method: &#x27;PUT&#x27;,      data    &#125;)  &#125;&#125;

6. 自动化部署6.1 构建配置// vite.config.ts 生产环境配置export default defineConfig(&#123;  build: &#123;    target: &#x27;es2015&#x27;,    minify: &#x27;terser&#x27;,    cssCodeSplit: true,    rollupOptions: &#123;      output: &#123;        manualChunks: &#123;          &#x27;vue-vendor&#x27;: [&#x27;vue&#x27;, &#x27;vue-router&#x27;, &#x27;pinia&#x27;],          &#x27;element-plus&#x27;: [&#x27;element-plus&#x27;],          &#x27;utils&#x27;: [/src\/utils/],          &#x27;components&#x27;: [/src\/components/]        &#125;      &#125;    &#125;  &#125;&#125;)

6.2 Docker 部署# DockerfileFROM node:16 as builderWORKDIR /appCOPY package*.json ./RUN npm ciCOPY . .RUN npm run buildFROM nginx:alpineCOPY --from=builder /app/dist /usr/share/nginx/htmlCOPY nginx.conf /etc/nginx/conf.d/default.confEXPOSE 80CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]

参考文献
Vue3 官方文档
Vite 官方文档
Pinia 官方文档
Vue Router 文档

]]></content>
      <categories>
        <category>前端</category>
        <category>工程化</category>
      </categories>
      <tags>
        <tag>最佳实践</tag>
        <tag>Vue3</tag>
        <tag>工程化</tag>
      </tags>
  </entry>
  <entry>
    <title>v-if和v-for的优先级是什么？</title>
    <url>/2024/09/20/vue-if-for/</url>
    <content><![CDATA[
一、作用v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 true值的时候被渲染
v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组或者对象，而 item 则是被迭代的数组元素的别名
在 v-for 的时候，建议设置key值，并且保证每个key值是独一无二的，这便于diff算法进行优化
两者在用法上
&lt;Modal v-if=&quot;isShow&quot; /&gt;&lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;    &#123;&#123; item.label &#125;&#125;&lt;/li&gt;

二、优先级v-if与v-for都是vue模板系统中的指令
在vue模板编译的时候，会将指令系统转化成可执行的render函数
示例编写一个p标签，同时使用v-if与 v-for
&lt;div id=&quot;app&quot;&gt;    &lt;p v-if=&quot;isShow&quot; v-for=&quot;item in items&quot;&gt;        &#123;&#123; item.title &#125;&#125;    &lt;/p&gt;&lt;/div&gt;

创建vue实例，存放isShow与items数据
const app = new Vue(&#123;  el: &quot;#app&quot;,  data() &#123;    return &#123;      items: [        &#123; title: &quot;foo&quot; &#125;,        &#123; title: &quot;baz&quot; &#125;]    &#125;  &#125;,  computed: &#123;    isShow() &#123;      return this.items &amp;&amp; this.items.length &gt; 0    &#125;  &#125;&#125;)

模板指令的代码都会生成在render函数中，通过app.$options.render就能得到渲染函数
ƒ anonymous() &#123;  with (this) &#123; return     _c(&#x27;div&#x27;, &#123; attrs: &#123; &quot;id&quot;: &quot;app&quot; &#125; &#125;,     _l((items), function (item)     &#123; return (isShow) ? _c(&#x27;p&#x27;, [_v(&quot;\n&quot; + _s(item.title) + &quot;\n&quot;)]) : _e() &#125;), 0) &#125;&#125;

_l是vue的列表渲染函数，函数内部都会进行一次if判断
初步得到结论：v-for优先级是比v-if高
再将v-for与v-if置于不同标签
&lt;div id=&quot;app&quot;&gt;    &lt;template v-if=&quot;isShow&quot;&gt;        &lt;p v-for=&quot;item in items&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/p&gt;    &lt;/template&gt;&lt;/div&gt;

再输出下render函数
ƒ anonymous() &#123;  with(this)&#123;return     _c(&#x27;div&#x27;,&#123;attrs:&#123;&quot;id&quot;:&quot;app&quot;&#125;&#125;,    [(isShow)?[_v(&quot;\n&quot;),    _l((items),function(item)&#123;return _c(&#x27;p&#x27;,[_v(_s(item.title))])&#125;)]:_e()],2)&#125;&#125;

这时候我们可以看到，v-for与v-if作用在不同标签时候，是先进行判断，再进行列表的渲染
我们再在查看下vue源码
源码位置： \vue-dev\src\compiler\codegen\index.js
export function genElement (el: ASTElement, state: CodegenState): string &#123;  if (el.parent) &#123;    el.pre = el.pre || el.parent.pre  &#125;  if (el.staticRoot &amp;&amp; !el.staticProcessed) &#123;    return genStatic(el, state)  &#125; else if (el.once &amp;&amp; !el.onceProcessed) &#123;    return genOnce(el, state)  &#125; else if (el.for &amp;&amp; !el.forProcessed) &#123;    return genFor(el, state)  &#125; else if (el.if &amp;&amp; !el.ifProcessed) &#123;    return genIf(el, state)  &#125; else if (el.tag === &#x27;template&#x27; &amp;&amp; !el.slotTarget &amp;&amp; !state.pre) &#123;    return genChildren(el, state) || &#x27;void 0&#x27;  &#125; else if (el.tag === &#x27;slot&#x27;) &#123;    return genSlot(el, state)  &#125; else &#123;    // component or element    ...&#125;

在进行if判断的时候，v-for是比v-if先进行判断
最终结论：v-for优先级比v-if高
三、注意事项
永远不要把 v-if 和 v-for 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）
如果避免出现这种情况，则在外层嵌套template（页面渲染不生成dom节点），在这一层进行v-if判断，然后在内部进行v-for循环

&lt;template v-if=&quot;isShow&quot;&gt;    &lt;p v-for=&quot;item in items&quot;&gt;&lt;/template&gt;


如果条件出现在循环内部，可通过计算属性computed提前过滤掉那些不需要显示的项

computed: &#123;    items: function() &#123;      return this.list.filter(function (item) &#123;        return item.isShow      &#125;)    &#125;&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>说说你对keep-alive的理解是什么？</title>
    <url>/2024/09/01/vue-keepalive/</url>
    <content><![CDATA[
一、Keep-alive 是什么keep-alive是vue中的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM
keep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们
keep-alive可以设置以下props属性：

include - 字符串或正则表达式。只有名称匹配的组件会被缓存

exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存

max - 数字。最多可以缓存多少组件实例


关于keep-alive的基本用法：
&lt;keep-alive&gt;  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;

使用includes和exclude：
&lt;keep-alive include=&quot;a,b&quot;&gt;  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;&lt;keep-alive :include=&quot;/a|b/&quot;&gt;  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 数组 (使用 `v-bind`) --&gt;&lt;keep-alive :include=&quot;[&#x27;a&#x27;, &#x27;b&#x27;]&quot;&gt;  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;

匹配首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称 (父组件 components 选项的键值)，匿名组件不能被匹配
设置了 keep-alive 缓存的组件，会多出两个生命周期钩子（activated与deactivated）：

首次进入组件时：beforeRouteEnter &gt; beforeCreate &gt; created&gt; mounted &gt; activated &gt; … … &gt; beforeRouteLeave &gt; deactivated

再次进入组件时：beforeRouteEnter &gt;activated &gt; … … &gt; beforeRouteLeave &gt; deactivated


二、使用场景使用原则：当我们在某些场景下不需要让页面重新加载时我们可以使用keepalive
举个栗子:
当我们从首页–&gt;列表页–&gt;商详页–&gt;再返回，这时候列表页应该是需要keep-alive
从首页–&gt;列表页–&gt;商详页–&gt;返回到列表页(需要缓存)–&gt;返回到首页(需要缓存)–&gt;再次进入列表页(不需要缓存)，这时候可以按需来控制页面的keep-alive
在路由中设置keepAlive属性判断是否需要缓存
&#123;  path: &#x27;list&#x27;,  name: &#x27;itemList&#x27;, // 列表页  component (resolve) &#123;    require([&#x27;@/pages/item/list&#x27;], resolve) &#125;, meta: &#123;  keepAlive: true,  title: &#x27;列表页&#x27; &#125;&#125;

使用&lt;keep-alive&gt;
&lt;div id=&quot;app&quot; class=&#x27;wrapper&#x27;&gt;    &lt;keep-alive&gt;        &lt;!-- 需要缓存的视图组件 --&gt;         &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;     &lt;/keep-alive&gt;      &lt;!-- 不需要缓存的视图组件 --&gt;     &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;&lt;/div&gt;

三、原理分析keep-alive是vue中内置的一个组件
源码位置：src&#x2F;core&#x2F;components&#x2F;keep-alive.js
export default &#123;  name: &#x27;keep-alive&#x27;,  abstract: true,  props: &#123;    include: [String, RegExp, Array],    exclude: [String, RegExp, Array],    max: [String, Number]  &#125;,  created () &#123;    this.cache = Object.create(null)    this.keys = []  &#125;,  destroyed () &#123;    for (const key in this.cache) &#123;      pruneCacheEntry(this.cache, key, this.keys)    &#125;  &#125;,  mounted () &#123;    this.$watch(&#x27;include&#x27;, val =&gt; &#123;      pruneCache(this, name =&gt; matches(val, name))    &#125;)    this.$watch(&#x27;exclude&#x27;, val =&gt; &#123;      pruneCache(this, name =&gt; !matches(val, name))    &#125;)  &#125;,  render() &#123;    /* 获取默认插槽中的第一个组件节点 */    const slot = this.$slots.default    const vnode = getFirstComponentChild(slot)    /* 获取该组件节点的componentOptions */    const componentOptions = vnode &amp;&amp; vnode.componentOptions    if (componentOptions) &#123;      /* 获取该组件节点的名称，优先获取组件的name字段，如果name不存在则获取组件的tag */      const name = getComponentName(componentOptions)      const &#123; include, exclude &#125; = this      /* 如果name不在inlcude中或者存在于exlude中则表示不缓存，直接返回vnode */      if (        (include &amp;&amp; (!name || !matches(include, name))) ||        // excluded        (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))      ) &#123;        return vnode      &#125;      const &#123; cache, keys &#125; = this      /* 获取组件的key值 */      const key = vnode.key == null        // same constructor may get registered as different local components        // so cid alone is not enough (#3269)        ? componentOptions.Ctor.cid + (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : &#x27;&#x27;)        : vnode.key     /*  拿到key值后去this.cache对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存 */      if (cache[key]) &#123;        vnode.componentInstance = cache[key].componentInstance        // make current key freshest        remove(keys, key)        keys.push(key)      &#125;        /* 如果没有命中缓存，则将其设置进缓存 */        else &#123;        cache[key] = vnode        keys.push(key)        // prune oldest entry        /* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */        if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123;          pruneCacheEntry(cache, keys[0], keys, this._vnode)        &#125;      &#125;      vnode.data.keepAlive = true    &#125;    return vnode || (slot &amp;&amp; slot[0])  &#125;&#125;

可以看到该组件没有template，而是用了render，在组件渲染的时候会自动执行render函数
this.cache是一个对象，用来存储需要缓存的组件，它将以如下形式存储：
this.cache = &#123;    &#x27;key1&#x27;:&#x27;组件1&#x27;,    &#x27;key2&#x27;:&#x27;组件2&#x27;,    // ...&#125;

在组件销毁的时候执行pruneCacheEntry函数
function pruneCacheEntry (  cache: VNodeCache,  key: string,  keys: Array&lt;string&gt;,  current?: VNode) &#123;  const cached = cache[key]  /* 判断当前没有处于被渲染状态的组件，将其销毁*/  if (cached &amp;&amp; (!current || cached.tag !== current.tag)) &#123;    cached.componentInstance.$destroy()  &#125;  cache[key] = null  remove(keys, key)&#125;

在mounted钩子函数中观测 include 和 exclude 的变化，如下：
mounted () &#123;    this.$watch(&#x27;include&#x27;, val =&gt; &#123;        pruneCache(this, name =&gt; matches(val, name))    &#125;)    this.$watch(&#x27;exclude&#x27;, val =&gt; &#123;        pruneCache(this, name =&gt; !matches(val, name))    &#125;)&#125;

如果include 或exclude 发生了变化，即表示定义需要缓存的组件的规则或者不需要缓存的组件的规则发生了变化，那么就执行pruneCache函数，函数如下：
function pruneCache (keepAliveInstance, filter) &#123;  const &#123; cache, keys, _vnode &#125; = keepAliveInstance  for (const key in cache) &#123;    const cachedNode = cache[key]    if (cachedNode) &#123;      const name = getComponentName(cachedNode.componentOptions)      if (name &amp;&amp; !filter(name)) &#123;        pruneCacheEntry(cache, key, keys, _vnode)      &#125;    &#125;  &#125;&#125;

在该函数内对this.cache对象进行遍历，取出每一项的name值，用其与新的缓存规则进行匹配，如果匹配不上，则表示在新的缓存规则下该组件已经不需要被缓存，则调用pruneCacheEntry函数将其从this.cache对象剔除即可
关于keep-alive的最强大缓存功能是在render函数中实现
首先获取组件的key值：
const key = vnode.key == null? componentOptions.Ctor.cid + (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : &#x27;&#x27;): vnode.key

拿到key值后去this.cache对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存，如下：
/* 如果命中缓存，则直接从缓存中拿 vnode 的组件实例 */if (cache[key]) &#123;    vnode.componentInstance = cache[key].componentInstance    /* 调整该组件key的顺序，将其从原来的地方删掉并重新放在最后一个 */    remove(keys, key)    keys.push(key)&#125; 

直接从缓存中拿 vnode 的组件实例，此时重新调整该组件key的顺序，将其从原来的地方删掉并重新放在this.keys中最后一个
this.cache对象中没有该key值的情况，如下：
/* 如果没有命中缓存，则将其设置进缓存 */else &#123;    cache[key] = vnode    keys.push(key)    /* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */    if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123;        pruneCacheEntry(cache, keys[0], keys, this._vnode)    &#125;&#125;

表明该组件还没有被缓存过，则以该组件的key为键，组件vnode为值，将其存入this.cache中，并且把key存入this.keys中
此时再判断this.keys中缓存组件的数量是否超过了设置的最大缓存数量值this.max，如果超过了，则把第一个缓存组件删掉
四、思考题：缓存后如何获取数据解决方案可以有以下两种：

beforeRouteEnter

actived


beforeRouteEnter每次组件渲染的时候，都会执行beforeRouteEnter
beforeRouteEnter(to, from, next)&#123;    next(vm=&gt;&#123;        console.log(vm)        // 每次进入路由执行        vm.getData()  // 获取数据    &#125;)&#125;,

actived在keep-alive缓存的组件被激活的时候，都会执行actived钩子
activated()&#123;   this.getData() // 获取数据&#125;,

注意：服务器端渲染期间avtived不被调用
参考文献
https://www.cnblogs.com/dhui/p/13589401.html
https://www.cnblogs.com/wangjiachen666/p/11497200.html
https://vue3js.cn/docs/zh

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>你知道vue中key的原理吗？说说你对它的理解</title>
    <url>/2024/08/26/vue-key/</url>
    <content><![CDATA[
一、Key是什么开始之前，我们先还原两个实际工作场景

当我们在使用v-for时，需要给单元加上key

&lt;ul&gt;    &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;...&lt;/li&gt;&lt;/ul&gt;

用+new Date()生成的时间戳作为key，手动强制触发重新渲染&lt;Comp :key=&quot;+new Date()&quot; /&gt;

那么这背后的逻辑是什么，key的作用又是什么？
一句话来讲

key是给每一个vnode的唯一id，也是diff的一种优化策略，可以根据key，更准确， 更快的找到对应的vnode节点

场景背后的逻辑当我们在使用v-for时，需要给单元加上key

如果不用key，Vue会采用就地复地原则：最小化element的移动，并且会尝试尽最大程度在同适当的地方对相同类型的element，做patch或者reuse。

如果使用了key，Vue会根据keys的顺序记录element，曾经拥有了key的element如果不再出现的话，会被直接remove或者destoryed


用+new Date()生成的时间戳作为key，手动强制触发重新渲染

当拥有新值的rerender作为key时，拥有了新key的Comp出现了，那么旧key Comp会被移除，新key Comp触发渲染

二、设置key与不设置key区别举个例子：
创建一个实例，2秒后往items数组插入数据
&lt;body&gt;  &lt;div id=&quot;demo&quot;&gt;    &lt;p v-for=&quot;item in items&quot; :key=&quot;item&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/p&gt;  &lt;/div&gt;  &lt;script src=&quot;../../dist/vue.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    // 创建实例    const app = new Vue(&#123;      el: &#x27;#demo&#x27;,      data: &#123; items: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;] &#125;,      mounted () &#123;        setTimeout(() =&gt; &#123;           this.items.splice(2, 0, &#x27;f&#x27;)  //        &#125;, 2000);     &#125;,   &#125;);  &lt;/script&gt;&lt;/body&gt;

在不使用key的情况，vue会进行这样的操作：
 
分析下整体流程：

比较A，A，相同类型的节点，进行patch，但数据相同，不发生dom操作
比较B，B，相同类型的节点，进行patch，但数据相同，不发生dom操作
比较C，F，相同类型的节点，进行patch，数据不同，发生dom操作
比较D，C，相同类型的节点，进行patch，数据不同，发生dom操作
比较E，D，相同类型的节点，进行patch，数据不同，发生dom操作
循环结束，将E插入到DOM中

一共发生了3次更新，1次插入操作
在使用key的情况：vue会进行这样的操作：

比较A，A，相同类型的节点，进行patch，但数据相同，不发生dom操作
比较B，B，相同类型的节点，进行patch，但数据相同，不发生dom操作
比较C，F，不相同类型的节点
比较E、E，相同类型的节点，进行patch，但数据相同，不发生dom操作


比较D、D，相同类型的节点，进行patch，但数据相同，不发生dom操作
比较C、C，相同类型的节点，进行patch，但数据相同，不发生dom操作
循环结束，将F插入到C之前

一共发生了0次更新，1次插入操作
通过上面两个小例子，可见设置key能够大大减少对页面的DOM操作，提高了diff效率
设置key值一定能提高diff效率吗？其实不然，文档中也明确表示

当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素

这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出
建议尽可能在使用 v-for 时提供 key，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升
三、原理分析源码位置：core&#x2F;vdom&#x2F;patch.js
这里判断是否为同一个key，首先判断的是key值是否相等如果没有设置key，那么key为undefined，这时候undefined是恒等于undefined
function sameVnode (a, b) &#123;    return (        a.key === b.key &amp;&amp; (            (                a.tag === b.tag &amp;&amp;                a.isComment === b.isComment &amp;&amp;                isDef(a.data) === isDef(b.data) &amp;&amp;                sameInputType(a, b)            ) || (                isTrue(a.isAsyncPlaceholder) &amp;&amp;                a.asyncFactory === b.asyncFactory &amp;&amp;                isUndef(b.asyncFactory.error)            )        )    )&#125;

updateChildren方法中会对新旧vnode进行diff，然后将比对出的结果用来更新真实的DOM
function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;    ...    while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;        if (isUndef(oldStartVnode)) &#123;            ...        &#125; else if (isUndef(oldEndVnode)) &#123;            ...        &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123;            ...        &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123;            ...        &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right            ...        &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left            ...        &#125; else &#123;            if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)            idxInOld = isDef(newStartVnode.key)                ? oldKeyToIdx[newStartVnode.key]                : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)            if (isUndef(idxInOld)) &#123; // New element                createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)            &#125; else &#123;                vnodeToMove = oldCh[idxInOld]                if (sameVnode(vnodeToMove, newStartVnode)) &#123;                    patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)                    oldCh[idxInOld] = undefined                    canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)                &#125; else &#123;                    // same key but different element. treat as new element                    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)                &#125;            &#125;            newStartVnode = newCh[++newStartIdx]        &#125;    &#125;    ...&#125;


参考文献
https://juejin.cn/post/6844903826693029895
https://juejin.cn/post/6844903985397104648
https://vue3js.cn/docs/zh

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>请描述下你对vue生命周期的理解？在created和mounted这两个生命周期中请求数据有什么区别呢？</title>
    <url>/2024/08/24/vue-lifecycle/</url>
    <content><![CDATA[
一、生命周期是什么生命周期（Life Cycle）的概念应用很广泛，特别是在政治、经济、环境、技术、社会等诸多领域经常出现，其基本涵义可以通俗地理解为“从摇篮到坟墓”（Cradle-to-Grave）的整个过程在Vue中实例从创建到销毁的过程就是生命周期，即指从创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程我们可以把组件比喻成工厂里面的一条流水线，每个工人（生命周期）站在各自的岗位，当任务流转到工人身边的时候，工人就开始工作PS：在Vue生命周期钩子会自动绑定 this 上下文到实例中，因此你可以访问数据，对 property 和方法进行运算这意味着你不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())
二、生命周期有哪些Vue生命周期总共可以分为8个阶段：创建前后, 载入前后,更新前后,销毁前销毁后，以及一些特殊场景的生命周期



生命周期
描述



beforeCreate
组件实例被创建之初


created
组件实例已经完全创建


beforeMount
组件挂载之前


mounted
组件挂载到实例上去之后


beforeUpdate
组件数据发生变化，更新之前


updated
组件数据更新之后


beforeDestroy
组件实例销毁之前


destroyed
组件实例销毁之后


activated
keep-alive 缓存的组件激活时


deactivated
keep-alive 缓存的组件停用时调用


errorCaptured
捕获一个来自子孙组件的错误时被调用


三、生命周期整体流程Vue生命周期流程图
 
具体分析beforeCreate -&gt; created

初始化vue实例，进行数据观测

created

完成数据观测，属性与方法的运算，watch、event事件回调的配置
可调用methods中的方法，访问和修改data数据触发响应式渲染dom，可通过computed和watch完成数据计算
此时vm.$el 并没有被创建

created -&gt; beforeMount

判断是否存在el选项，若不存在则停止编译，直到调用vm.$mount(el)才会继续编译
优先级：render &gt; template &gt; outerHTML
vm.el获取到的是挂载DOM的

beforeMount

在此阶段可获取到vm.el
此阶段vm.el虽已完成DOM初始化，但并未挂载在el选项上

beforeMount -&gt; mounted

此阶段vm.el完成挂载，vm.$el生成的DOM替换了el选项所对应的DOM

mounted

vm.el已完成DOM的挂载与渲染，此刻打印vm.$el，发现之前的挂载点及内容已被替换成新的DOM

beforeUpdate

更新的数据必须是被渲染在模板上的（el、template、render之一）
此时view层还未更新
若在beforeUpdate中再次修改数据，不会再次触发更新方法

updated

完成view层的更新
若在updated中再次修改数据，会再次触发更新方法（beforeUpdate、updated）

beforeDestroy

实例被销毁前调用，此时实例属性与方法仍可访问

destroyed

完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器
并不能清除DOM，仅仅销毁实例

使用场景分析



生命周期
描述



beforeCreate
执行时组件实例还未创建，通常用于插件开发中执行一些初始化任务


created
组件初始化完毕，各种数据可以使用，常用于异步数据获取


beforeMount
未执行渲染、更新，dom未创建


mounted
初始化结束，dom已创建，可用于获取访问数据和dom元素


beforeUpdate
更新前，可用于获取更新前各种状态


updated
更新后，所有状态已是最新


beforeDestroy
销毁前，可用于一些定时器或订阅的取消


destroyed
组件已销毁，作用同上


四、题外话：数据请求在created和mouted的区别created是在组件实例一旦创建完成的时候立刻调用，这时候页面dom节点并未生成；mounted是在页面dom节点渲染完毕之后就立刻执行的。触发时机上created是比mounted要更早的，两者的相同点：都能拿到实例对象的属性和方法。讨论这个问题本质就是触发的时机，放在mounted中的请求有可能导致页面闪动（因为此时页面dom结构已经生成），但如果在页面加载前完成请求，则不会出现此情况。建议对页面内容的改动放在created生命周期当中。
参考文献
https://juejin.cn/post/6844903811094413320
https://baike.baidu.com/
http://cn.vuejs.org/

面试官VUE系列总进度：4／33
面试官：说说你对vue的理解?  
面试官：说说你对SPA（单页应用）的理解?
面试官：说说你对双向绑定的理解?  

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>说说你对vue的mixin的理解，有什么应用场景？</title>
    <url>/2024/08/04/vue-mixin/</url>
    <content><![CDATA[
一、mixin是什么Mixin是面向对象程序设计语言中的类，提供了方法的实现。其他类可以访问mixin类的方法而不必成为其子类
Mixin类通常作为功能模块使用，在需要该功能时“混入”，有利于代码复用又避免了多继承的复杂
Vue中的mixin先来看一下官方定义

mixin（混入），提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。

本质其实就是一个js对象，它可以包含我们组件中任意功能选项，如data、components、methods 、created、computed等等
我们只要将共用的功能以对象的方式传入 mixins选项中，当组件使用 mixins对象时所有mixins对象的选项都将被混入该组件本身的选项中来
在Vue中我们可以局部混入跟全局混入
局部混入定义一个mixin对象，有组件options的data、methods属性
var myMixin = &#123;  created: function () &#123;    this.hello()  &#125;,  methods: &#123;    hello: function () &#123;      console.log(&#x27;hello from mixin!&#x27;)    &#125;  &#125;&#125;

组件通过mixins属性调用mixin对象
Vue.component(&#x27;componentA&#x27;,&#123;  mixins: [myMixin]&#125;)

该组件在使用的时候，混合了mixin里面的方法，在自动执行created生命钩子，执行hello方法
全局混入通过Vue.mixin()进行全局的混入
Vue.mixin(&#123;  created: function () &#123;      console.log(&quot;全局混入&quot;)    &#125;&#125;)

使用全局混入需要特别注意，因为它会影响到每一个组件实例（包括第三方组件）
PS：全局混入常用于插件的编写
注意事项：当组件存在与mixin对象相同的选项的时候，进行递归合并的时候组件的选项会覆盖mixin的选项
但是如果相同选项为生命周期钩子的时候，会合并成一个数组，先执行mixin的钩子，再执行组件的钩子
二、使用场景在日常的开发中，我们经常会遇到在不同的组件中经常会需要用到一些相同或者相似的代码，这些代码的功能相对独立
这时，可以通过Vue的mixin功能将相同或者相似的代码提出来
举个例子
定义一个modal弹窗组件，内部通过isShowing来控制显示
const Modal = &#123;  template: &#x27;#modal&#x27;,  data() &#123;    return &#123;      isShowing: false    &#125;  &#125;,  methods: &#123;    toggleShow() &#123;      this.isShowing = !this.isShowing;    &#125;  &#125;&#125;

定义一个tooltip提示框，内部通过isShowing来控制显示
const Tooltip = &#123;  template: &#x27;#tooltip&#x27;,  data() &#123;    return &#123;      isShowing: false    &#125;  &#125;,  methods: &#123;    toggleShow() &#123;      this.isShowing = !this.isShowing;    &#125;  &#125;&#125;

通过观察上面两个组件，发现两者的逻辑是相同，代码控制显示也是相同的，这时候mixin就派上用场了
首先抽出共同代码，编写一个mixin
const toggle = &#123;  data() &#123;    return &#123;      isShowing: false    &#125;  &#125;,  methods: &#123;    toggleShow() &#123;      this.isShowing = !this.isShowing;    &#125;  &#125;&#125;

两个组件在使用上，只需要引入mixin
const Modal = &#123;  template: &#x27;#modal&#x27;,  mixins: [toggle]&#125;; const Tooltip = &#123;  template: &#x27;#tooltip&#x27;,  mixins: [toggle]&#125;

通过上面小小的例子，让我们知道了Mixin对于封装一些可复用的功能如此有趣、方便、实用
三、源码分析首先从Vue.mixin入手
源码位置：&#x2F;src&#x2F;core&#x2F;global-api&#x2F;mixin.js
export function initMixin (Vue: GlobalAPI) &#123;  Vue.mixin = function (mixin: Object) &#123;    this.options = mergeOptions(this.options, mixin)    return this  &#125;&#125;

主要是调用merOptions方法
源码位置：&#x2F;src&#x2F;core&#x2F;util&#x2F;options.js
export function mergeOptions (  parent: Object,  child: Object,  vm?: Component): Object &#123;if (child.mixins) &#123; // 判断有没有mixin 也就是mixin里面挂mixin的情况 有的话递归进行合并    for (let i = 0, l = child.mixins.length; i &lt; l; i++) &#123;    parent = mergeOptions(parent, child.mixins[i], vm)    &#125;&#125;  const options = &#123;&#125;   let key  for (key in parent) &#123;    mergeField(key) // 先遍历parent的key 调对应的strats[XXX]方法进行合并  &#125;  for (key in child) &#123;    if (!hasOwn(parent, key)) &#123; // 如果parent已经处理过某个key 就不处理了      mergeField(key) // 处理child中的key 也就parent中没有处理过的key    &#125;  &#125;  function mergeField (key) &#123;    const strat = strats[key] || defaultStrat    options[key] = strat(parent[key], child[key], vm, key) // 根据不同类型的options调用strats中不同的方法进行合并  &#125;  return options&#125;
从上面的源码，我们得到以下几点：

优先递归处理 mixins
先遍历合并parent 中的key，调用mergeField方法进行合并，然后保存在变量options
再遍历 child，合并补上 parent 中没有的key，调用mergeField方法进行合并，保存在变量options
通过 mergeField 函数进行了合并

下面是关于Vue的几种类型的合并策略

替换型
合并型
队列型
叠加型

替换型替换型合并有props、methods、inject、computed
strats.props =strats.methods =strats.inject =strats.computed = function (  parentVal: ?Object,  childVal: ?Object,  vm?: Component,  key: string): ?Object &#123;  if (!parentVal) return childVal // 如果parentVal没有值，直接返回childVal  const ret = Object.create(null) // 创建一个第三方对象 ret  extend(ret, parentVal) // extend方法实际是把parentVal的属性复制到ret中  if (childVal) extend(ret, childVal) // 把childVal的属性复制到ret中  return ret&#125;strats.provide = mergeDataOrFn

同名的props、methods、inject、computed会被后来者代替
合并型和并型合并有：data
strats.data = function(parentVal, childVal, vm) &#123;        return mergeDataOrFn(        parentVal, childVal, vm    )&#125;;function mergeDataOrFn(parentVal, childVal, vm) &#123;        return function mergedInstanceDataFn() &#123;                var childData = childVal.call(vm, vm) // 执行data挂的函数得到对象        var parentData = parentVal.call(vm, vm)                if (childData) &#123;                        return mergeData(childData, parentData) // 将2个对象进行合并                                         &#125; else &#123;                        return parentData // 如果没有childData 直接返回parentData        &#125;    &#125;&#125;function mergeData(to, from) &#123;        if (!from) return to        var key, toVal, fromVal;        var keys = Object.keys(from);       for (var i = 0; i &lt; keys.length; i++) &#123;        key = keys[i];        toVal = to[key];        fromVal = from[key];            // 如果不存在这个属性，就重新设置        if (!to.hasOwnProperty(key)) &#123;            set(to, key, fromVal);        &#125;              // 存在相同属性，合并对象        else if (typeof toVal ==&quot;object&quot; &amp;&amp; typeof fromVal ==&quot;object&quot;) &#123;            mergeData(toVal, fromVal);        &#125;    &#125;        return to&#125;

mergeData函数遍历了要合并的 data 的所有属性，然后根据不同情况进行合并：

当目标 data 对象不包含当前属性时，调用 set 方法进行合并（set方法其实就是一些合并重新赋值的方法）
当目标 data 对象包含当前属性并且当前值为纯对象时，递归合并当前对象值，这样做是为了防止对象存在新增属性

队列性队列性合并有：全部生命周期和watch
function mergeHook (  parentVal: ?Array&lt;Function&gt;,  childVal: ?Function | ?Array&lt;Function&gt;): ?Array&lt;Function&gt; &#123;  return childVal    ? parentVal      ? parentVal.concat(childVal)      : Array.isArray(childVal)        ? childVal        : [childVal]    : parentVal&#125;LIFECYCLE_HOOKS.forEach(hook =&gt; &#123;  strats[hook] = mergeHook&#125;)// watchstrats.watch = function (  parentVal,  childVal,  vm,  key) &#123;  // work around Firefox&#x27;s Object.prototype.watch...  if (parentVal === nativeWatch) &#123; parentVal = undefined; &#125;  if (childVal === nativeWatch) &#123; childVal = undefined; &#125;  /* istanbul ignore if */  if (!childVal) &#123; return Object.create(parentVal || null) &#125;  &#123;    assertObjectType(key, childVal, vm);  &#125;  if (!parentVal) &#123; return childVal &#125;  var ret = &#123;&#125;;  extend(ret, parentVal);  for (var key$1 in childVal) &#123;    var parent = ret[key$1];    var child = childVal[key$1];    if (parent &amp;&amp; !Array.isArray(parent)) &#123;      parent = [parent];    &#125;    ret[key$1] = parent      ? parent.concat(child)      : Array.isArray(child) ? child : [child];  &#125;  return ret&#125;;

生命周期钩子和watch被合并为一个数组，然后正序遍历一次执行
叠加型叠加型合并有：component、directives、filters
strats.components=strats.directives=strats.filters = function mergeAssets(    parentVal, childVal, vm, key) &#123;        var res = Object.create(parentVal || null);        if (childVal) &#123;         for (var key in childVal) &#123;            res[key] = childVal[key];        &#125;       &#125;     return res&#125;

叠加型主要是通过原型链进行层层的叠加
小结：
替换型策略有props、methods、inject、computed，就是将新的同名参数替代旧的参数
合并型策略是data, 通过set方法进行合并和重新赋值
队列型策略有生命周期函数和watch，原理是将函数存入一个数组，然后正序遍历依次执行
叠加型有component、directives、filters，通过原型链进行层层的叠加

参考文献
https://zhuanlan.zhihu.com/p/31018570
https://juejin.cn/post/6844904015495446536#heading-1
https://juejin.cn/post/6844903846775357453
https://vue3js.cn/docs/zh

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中的$nextTick有什么作用？</title>
    <url>/2024/07/09/vue-nexttick/</url>
    <content><![CDATA[
一、NextTick是什么官方对其的定义

在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM

什么意思呢？
我们可以理解成，Vue 在更新 DOM 时是异步执行的。当数据发生变化，Vue将开启一个异步更新队列，视图需要等队列中所有数据变化完成之后，再统一进行更新
举例一下
Html结构
&lt;div id=&quot;app&quot;&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt;

构建一个vue实例
const vm = new Vue(&#123;  el: &#x27;#app&#x27;,  data: &#123;    message: &#x27;原始值&#x27;  &#125;&#125;)

修改message
this.message = &#x27;修改后的值1&#x27;this.message = &#x27;修改后的值2&#x27;this.message = &#x27;修改后的值3&#x27;

这时候想获取页面最新的DOM节点，却发现获取到的是旧值
console.log(vm.$el.textContent) // 原始值

这是因为message数据在发现变化的时候，vue并不会立刻去更新Dom，而是将修改数据的操作放在了一个异步操作队列中
如果我们一直修改相同数据，异步操作队列还会进行去重
等待同一事件循环中的所有数据变化完成之后，会将队列中的事件拿来进行处理，进行DOM的更新
为什么要有nexttick举个例子
&#123;&#123;num&#125;&#125;for(let i=0; i&lt;100000; i++)&#123;    num = i&#125;
如果没有 nextTick 更新机制，那么 num 每次更新值都会触发视图更新(上面这段代码也就是会更新10万次视图)，有了nextTick机制，只需要更新一次，所以nextTick本质是一种优化策略
二、使用场景如果想要在修改数据后立刻得到更新后的DOM结构，可以使用Vue.nextTick()
第一个参数为：回调函数（可以获取最近的DOM结构）
第二个参数为：执行函数上下文
// 修改数据vm.message = &#x27;修改后的值&#x27;// DOM 还没有更新console.log(vm.$el.textContent) // 原始的值Vue.nextTick(function () &#123;  // DOM 更新了  console.log(vm.$el.textContent) // 修改后的值&#125;)

组件内使用 vm.$nextTick() 实例方法只需要通过this.$nextTick()，并且回调函数中的 this 将自动绑定到当前的 Vue 实例上
this.message = &#x27;修改后的值&#x27;console.log(this.$el.textContent) // =&gt; &#x27;原始的值&#x27;this.$nextTick(function () &#123;    console.log(this.$el.textContent) // =&gt; &#x27;修改后的值&#x27;&#125;)

$nextTick() 会返回一个 Promise 对象，可以是用async/await完成相同作用的事情
this.message = &#x27;修改后的值&#x27;console.log(this.$el.textContent) // =&gt; &#x27;原始的值&#x27;await this.$nextTick()console.log(this.$el.textContent) // =&gt; &#x27;修改后的值&#x27;

三、实现原理源码位置：/src/core/util/next-tick.js
callbacks也就是异步操作队列
callbacks新增回调函数后又执行了timerFunc函数，pending是用来标识同一个时间只能执行一次
export function nextTick(cb?: Function, ctx?: Object) &#123;  let _resolve;  // cb 回调函数会经统一处理压入 callbacks 数组  callbacks.push(() =&gt; &#123;    if (cb) &#123;      // 给 cb 回调函数执行加上了 try-catch 错误处理      try &#123;        cb.call(ctx);      &#125; catch (e) &#123;        handleError(e, ctx, &#x27;nextTick&#x27;);      &#125;    &#125; else if (_resolve) &#123;      _resolve(ctx);    &#125;  &#125;);  // 执行异步延迟函数 timerFunc  if (!pending) &#123;    pending = true;    timerFunc();  &#125;  // 当 nextTick 没有传入函数参数的时候，返回一个 Promise 化的调用  if (!cb &amp;&amp; typeof Promise !== &#x27;undefined&#x27;) &#123;    return new Promise(resolve =&gt; &#123;      _resolve = resolve;    &#125;);  &#125;&#125;

timerFunc函数定义，这里是根据当前环境支持什么方法则确定调用哪个，分别有：
Promise.then、MutationObserver、setImmediate、setTimeout
通过上面任意一种方法，进行降级操作
export let isUsingMicroTask = falseif (typeof Promise !== &#x27;undefined&#x27; &amp;&amp; isNative(Promise)) &#123;  //判断1：是否原生支持Promise  const p = Promise.resolve()  timerFunc = () =&gt; &#123;    p.then(flushCallbacks)    if (isIOS) setTimeout(noop)  &#125;  isUsingMicroTask = true&#125; else if (!isIE &amp;&amp; typeof MutationObserver !== &#x27;undefined&#x27; &amp;&amp; (  isNative(MutationObserver) ||  MutationObserver.toString() === &#x27;[object MutationObserverConstructor]&#x27;)) &#123;  //判断2：是否原生支持MutationObserver  let counter = 1  const observer = new MutationObserver(flushCallbacks)  const textNode = document.createTextNode(String(counter))  observer.observe(textNode, &#123;    characterData: true  &#125;)  timerFunc = () =&gt; &#123;    counter = (counter + 1) % 2    textNode.data = String(counter)  &#125;  isUsingMicroTask = true&#125; else if (typeof setImmediate !== &#x27;undefined&#x27; &amp;&amp; isNative(setImmediate)) &#123;  //判断3：是否原生支持setImmediate  timerFunc = () =&gt; &#123;    setImmediate(flushCallbacks)  &#125;&#125; else &#123;  //判断4：上面都不行，直接用setTimeout  timerFunc = () =&gt; &#123;    setTimeout(flushCallbacks, 0)  &#125;&#125;

无论是微任务还是宏任务，都会放到flushCallbacks使用
这里将callbacks里面的函数复制一份，同时callbacks置空
依次执行callbacks里面的函数
function flushCallbacks () &#123;  pending = false  const copies = callbacks.slice(0)  callbacks.length = 0  for (let i = 0; i &lt; copies.length; i++) &#123;    copies[i]()  &#125;&#125;

小结：

把回调函数放入callbacks等待执行
将执行函数放到微任务或者宏任务中
事件循环到了微任务或者宏任务，执行函数依次执行callbacks中的回调

参考文献
https://juejin.cn/post/6844904147804749832

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.observable你有了解过吗？说说看</title>
    <url>/2024/07/07/vue-observable/</url>
    <content><![CDATA[  
一、Observable 是什么Observable 翻译过来我们可以理解成可观察的
我们先来看一下其在Vue中的定义

Vue.observable，让一个对象变成响应式数据。Vue 内部会用它来处理 data 函数返回的对象

返回的对象可以直接用于渲染函数和计算属性内，并且会在发生变更时触发相应的更新。也可以作为最小化的跨组件状态存储器
Vue.observable(&#123; count : 1&#125;)

其作用等同于
new vue(&#123; count : 1&#125;)

在 Vue 2.x 中，被传入的对象会直接被 Vue.observable 变更，它和被返回的对象是同一个对象
在 Vue 3.x 中，则会返回一个可响应的代理，而对源对象直接进行变更仍然是不可响应的
二、使用场景在非父子组件通信时，可以使用通常的bus或者使用vuex，但是实现的功能不是太复杂，而使用上面两个又有点繁琐。这时，observable就是一个很好的选择
创建一个js文件
// 引入vueimport Vue from &#x27;vue// 创建state对象，使用observable让state对象可响应export let state = Vue.observable(&#123;  name: &#x27;张三&#x27;,  &#x27;age&#x27;: 38&#125;)// 创建对应的方法export let mutations = &#123;  changeName(name) &#123;    state.name = name  &#125;,  setAge(age) &#123;    state.age = age  &#125;&#125;

在.vue文件中直接使用即可
&lt;template&gt;  &lt;div&gt;    姓名：&#123;&#123; name &#125;&#125;    年龄：&#123;&#123; age &#125;&#125;    &lt;button @click=&quot;changeName(&#x27;李四&#x27;)&quot;&gt;改变姓名&lt;/button&gt;    &lt;button @click=&quot;setAge(18)&quot;&gt;改变年龄&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;import &#123; state, mutations &#125; from &#x27;@/storeexport default &#123;  // 在计算属性中拿到值  computed: &#123;    name() &#123;      return state.name    &#125;,    age() &#123;      return state.age    &#125;  &#125;,  // 调用mutations里面的方法，更新数据  methods: &#123;    changeName: mutations.changeName,    setAge: mutations.setAge  &#125;&#125;

三、原理分析源码位置：src\core\observer\index.js
export function observe (value: any, asRootData: ?boolean): Observer | void &#123;  if (!isObject(value) || value instanceof VNode) &#123;    return  &#125;  let ob: Observer | void  // 判断是否存在__ob__响应式属性  if (hasOwn(value, &#x27;__ob__&#x27;) &amp;&amp; value.__ob__ instanceof Observer) &#123;    ob = value.__ob__  &#125; else if (    shouldObserve &amp;&amp;    !isServerRendering() &amp;&amp;    (Array.isArray(value) || isPlainObject(value)) &amp;&amp;    Object.isExtensible(value) &amp;&amp;    !value._isVue  ) &#123;    // 实例化Observer响应式对象    ob = new Observer(value)  &#125;  if (asRootData &amp;&amp; ob) &#123;    ob.vmCount++  &#125;  return ob&#125;

Observer类
export class Observer &#123;    value: any;    dep: Dep;    vmCount: number; // number of vms that have this object as root $data    constructor (value: any) &#123;        this.value = value        this.dep = new Dep()        this.vmCount = 0        def(value, &#x27;__ob__&#x27;, this)        if (Array.isArray(value)) &#123;            if (hasProto) &#123;                protoAugment(value, arrayMethods)            &#125; else &#123;                copyAugment(value, arrayMethods, arrayKeys)            &#125;            this.observeArray(value)        &#125; else &#123;            // 实例化对象是一个对象，进入walk方法            this.walk(value)        &#125;&#125;

walk函数
walk (obj: Object) &#123;    const keys = Object.keys(obj)    // 遍历key，通过defineReactive创建响应式对象    for (let i = 0; i &lt; keys.length; i++) &#123;        defineReactive(obj, keys[i])    &#125;&#125;

defineReactive方法
export function defineReactive (  obj: Object,  key: string,  val: any,  customSetter?: ?Function,  shallow?: boolean) &#123;  const dep = new Dep()  const property = Object.getOwnPropertyDescriptor(obj, key)  if (property &amp;&amp; property.configurable === false) &#123;    return  &#125;  // cater for pre-defined getter/setters  const getter = property &amp;&amp; property.get  const setter = property &amp;&amp; property.set  if ((!getter || setter) &amp;&amp; arguments.length === 2) &#123;    val = obj[key]  &#125;  let childOb = !shallow &amp;&amp; observe(val)  // 接下来调用Object.defineProperty()给对象定义响应式属性  Object.defineProperty(obj, key, &#123;    enumerable: true,    configurable: true,    get: function reactiveGetter () &#123;      const value = getter ? getter.call(obj) : val      if (Dep.target) &#123;        dep.depend()        if (childOb) &#123;          childOb.dep.depend()          if (Array.isArray(value)) &#123;            dependArray(value)          &#125;        &#125;      &#125;      return value    &#125;,    set: function reactiveSetter (newVal) &#123;      const value = getter ? getter.call(obj) : val      /* eslint-disable no-self-compare */      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;        return      &#125;      /* eslint-enable no-self-compare */      if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; customSetter) &#123;        customSetter()      &#125;      // #7981: for accessor properties without setter      if (getter &amp;&amp; !setter) return      if (setter) &#123;        setter.call(obj, newVal)      &#125; else &#123;        val = newVal      &#125;      childOb = !shallow &amp;&amp; observe(newVal)      // 对观察者watchers进行通知,state就成了全局响应式对象      dep.notify()    &#125;  &#125;)&#125;



参考文献
https://blog.csdn.net/qq_32682301/article/details/105419673
https://wbbyouzi.com/archives/343

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？</title>
    <url>/2024/07/05/vue-permission/</url>
    <content><![CDATA[
一、是什么权限是对特定资源的访问许可，所谓权限控制，也就是确保用户只能访问到被分配的资源
而前端权限归根结底是请求的发起权，请求的发起可能有下面两种形式触发

页面加载触发
页面上的按钮点击触发

总的来说，所有的请求发起都触发自前端路由或视图
所以我们可以从这两方面入手，对触发权限的源头进行控制，最终要实现的目标是：

路由方面，用户登录后只能看到自己有权访问的导航菜单，也只能访问自己有权访问的路由地址，否则将跳转 4xx 提示页

视图方面，用户只能看到自己有权浏览的内容和有权操作的控件

最后再加上请求控制作为最后一道防线，路由可能配置失误，按钮可能忘了加权限，这种时候请求控制可以用来兜底，越权请求将在前端被拦截


二、如何做前端权限控制可以分为四个方面：

接口权限
按钮权限
菜单权限
路由权限

接口权限接口权限目前一般采用jwt的形式来验证，没有通过的话一般返回401，跳转到登录页面重新进行登录
登录完拿到token，将token存起来，通过axios请求拦截器进行拦截，每次请求的时候头部携带token
axios.interceptors.request.use(config =&gt; &#123;    config.headers[&#x27;token&#x27;] = cookie.get(&#x27;token&#x27;)    return config&#125;)axios.interceptors.response.use(res=&gt;&#123;&#125;,&#123;response&#125;=&gt;&#123;    if (response.data.code === 40099 || response.data.code === 40098) &#123; //token过期或者错误        router.push(&#x27;/login&#x27;)    &#125;&#125;)



路由权限控制方案一
初始化即挂载全部路由，并且在路由上标记相应的权限信息，每次路由跳转前做校验
const routerMap = [  &#123;    path: &#x27;/permission&#x27;,    component: Layout,    redirect: &#x27;/permission/index&#x27;,    alwaysShow: true, // will always show the root menu    meta: &#123;      title: &#x27;permission&#x27;,      icon: &#x27;lock&#x27;,      roles: [&#x27;admin&#x27;, &#x27;editor&#x27;] // you can set roles in root nav    &#125;,    children: [&#123;      path: &#x27;page&#x27;,      component: () =&gt; import(&#x27;@/views/permission/page&#x27;),      name: &#x27;pagePermission&#x27;,      meta: &#123;        title: &#x27;pagePermission&#x27;,        roles: [&#x27;admin&#x27;] // or you can only set roles in sub nav      &#125;    &#125;, &#123;      path: &#x27;directive&#x27;,      component: () =&gt; import(&#x27;@/views/permission/directive&#x27;),      name: &#x27;directivePermission&#x27;,      meta: &#123;        title: &#x27;directivePermission&#x27;        // if do not set roles, means: this page does not require permission      &#125;    &#125;]  &#125;]

这种方式存在以下四种缺点：

加载所有的路由，如果路由很多，而用户并不是所有的路由都有权限访问，对性能会有影响。

全局路由守卫里，每次路由跳转都要做权限判断。

菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译

菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识


方案二
初始化的时候先挂载不需要权限控制的路由，比如登录页，404等错误页。如果用户通过URL进行强制访问，则会直接进入404，相当于从源头上做了控制
登录后，获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用addRoutes添加路由
import router from &#x27;./router&#x27;import store from &#x27;./store&#x27;import &#123; Message &#125; from &#x27;element-ui&#x27;import NProgress from &#x27;nprogress&#x27; // progress barimport &#x27;nprogress/nprogress.css&#x27;// progress bar styleimport &#123; getToken &#125; from &#x27;@/utils/auth&#x27; // getToken from cookieNProgress.configure(&#123; showSpinner: false &#125;)// NProgress Configuration// permission judge functionfunction hasPermission(roles, permissionRoles) &#123;  if (roles.indexOf(&#x27;admin&#x27;) &gt;= 0) return true // admin permission passed directly  if (!permissionRoles) return true  return roles.some(role =&gt; permissionRoles.indexOf(role) &gt;= 0)&#125;const whiteList = [&#x27;/login&#x27;, &#x27;/authredirect&#x27;]// no redirect whitelistrouter.beforeEach((to, from, next) =&gt; &#123;  NProgress.start() // start progress bar  if (getToken()) &#123; // determine if there has token    /* has token*/    if (to.path === &#x27;/login&#x27;) &#123;      next(&#123; path: &#x27;/&#x27; &#125;)      NProgress.done() // if current page is dashboard will not trigger	afterEach hook, so manually handle it    &#125; else &#123;      if (store.getters.roles.length === 0) &#123; // 判断当前用户是否已拉取完user_info信息        store.dispatch(&#x27;GetUserInfo&#x27;).then(res =&gt; &#123; // 拉取user_info          const roles = res.data.roles // note: roles must be a array! such as: [&#x27;editor&#x27;,&#x27;develop&#x27;]          store.dispatch(&#x27;GenerateRoutes&#x27;, &#123; roles &#125;).then(() =&gt; &#123; // 根据roles权限生成可访问的路由表            router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表            next(&#123; ...to, replace: true &#125;) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record          &#125;)        &#125;).catch((err) =&gt; &#123;          store.dispatch(&#x27;FedLogOut&#x27;).then(() =&gt; &#123;            Message.error(err || &#x27;Verification failed, please login again&#x27;)            next(&#123; path: &#x27;/&#x27; &#125;)          &#125;)        &#125;)      &#125; else &#123;        // 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓        if (hasPermission(store.getters.roles, to.meta.roles)) &#123;          next()//        &#125; else &#123;          next(&#123; path: &#x27;/401&#x27;, replace: true, query: &#123; noGoBack: true &#125;&#125;)        &#125;        // 可删 ↑      &#125;    &#125;  &#125; else &#123;    /* has no token*/    if (whiteList.indexOf(to.path) !== -1) &#123; // 在免登录白名单，直接进入      next()    &#125; else &#123;      next(&#x27;/login&#x27;) // 否则全部重定向到登录页      NProgress.done() // if current page is login will not trigger afterEach hook, so manually handle it    &#125;  &#125;&#125;)router.afterEach(() =&gt; &#123;  NProgress.done() // finish progress bar&#125;)

按需挂载，路由就需要知道用户的路由权限，也就是在用户登录进来的时候就要知道当前用户拥有哪些路由权限
这种方式也存在了以下的缺点：

全局路由守卫里，每次路由跳转都要做判断
菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译
菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识

菜单权限菜单权限可以理解成将页面与理由进行解耦
方案一菜单与路由分离，菜单由后端返回
前端定义路由信息
&#123;    name: &quot;login&quot;,    path: &quot;/login&quot;,    component: () =&gt; import(&quot;@/pages/Login.vue&quot;)&#125;

name字段都不为空，需要根据此字段与后端返回菜单做关联，后端返回的菜单信息中必须要有name对应的字段，并且做唯一性校验
全局路由守卫里做判断
function hasPermission(router, accessMenu) &#123;  if (whiteList.indexOf(router.path) !== -1) &#123;    return true;  &#125;  let menu = Util.getMenuByName(router.name, accessMenu);  if (menu.name) &#123;    return true;  &#125;  return false;&#125;Router.beforeEach(async (to, from, next) =&gt; &#123;  if (getToken()) &#123;    let userInfo = store.state.user.userInfo;    if (!userInfo.name) &#123;      try &#123;        await store.dispatch(&quot;GetUserInfo&quot;)        await store.dispatch(&#x27;updateAccessMenu&#x27;)        if (to.path === &#x27;/login&#x27;) &#123;          next(&#123; name: &#x27;home_index&#x27; &#125;)        &#125; else &#123;          //Util.toDefaultPage([...routers], to.name, router, next);          next(&#123; ...to, replace: true &#125;)//菜单权限更新完成,重新进一次当前路由        &#125;      &#125;        catch (e) &#123;        if (whiteList.indexOf(to.path) !== -1) &#123; // 在免登录白名单，直接进入          next()        &#125; else &#123;          next(&#x27;/login&#x27;)        &#125;      &#125;    &#125; else &#123;      if (to.path === &#x27;/login&#x27;) &#123;        next(&#123; name: &#x27;home_index&#x27; &#125;)      &#125; else &#123;        if (hasPermission(to, store.getters.accessMenu)) &#123;          Util.toDefaultPage(store.getters.accessMenu,to, routes, next);        &#125; else &#123;          next(&#123; path: &#x27;/403&#x27;,replace:true &#125;)        &#125;      &#125;    &#125;  &#125; else &#123;    if (whiteList.indexOf(to.path) !== -1) &#123; // 在免登录白名单，直接进入      next()    &#125; else &#123;      next(&#x27;/login&#x27;)    &#125;  &#125;  let menu = Util.getMenuByName(to.name, store.getters.accessMenu);  Util.title(menu.title);&#125;);Router.afterEach((to) =&gt; &#123;  window.scrollTo(0, 0);&#125;);

每次路由跳转的时候都要判断权限，这里的判断也很简单，因为菜单的name与路由的name是一一对应的，而后端返回的菜单就已经是经过权限过滤的
如果根据路由name找不到对应的菜单，就表示用户有没权限访问
如果路由很多，可以在应用初始化的时候，只挂载不需要权限控制的路由。取得后端返回的菜单后，根据菜单与路由的对应关系，筛选出可访问的路由，通过addRoutes动态挂载
这种方式的缺点：

菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，如果菜单配置的不对会导致应用不能正常使用
全局路由守卫里，每次路由跳转都要做判断

方案二菜单和路由都由后端返回
前端统一定义路由组件
const Home = () =&gt; import(&quot;../pages/Home.vue&quot;);const UserInfo = () =&gt; import(&quot;../pages/UserInfo.vue&quot;);export default &#123;    home: Home,    userInfo: UserInfo&#125;;

后端路由组件返回以下格式
[    &#123;        name: &quot;home&quot;,        path: &quot;/&quot;,        component: &quot;home&quot;    &#125;,    &#123;        name: &quot;home&quot;,        path: &quot;/userinfo&quot;,        component: &quot;userInfo&quot;    &#125;]

在将后端返回路由通过addRoutes动态挂载之间，需要将数据处理一下，将component字段换为真正的组件
如果有嵌套路由，后端功能设计的时候，要注意添加相应的字段，前端拿到数据也要做相应的处理
这种方法也会存在缺点：

全局路由守卫里，每次路由跳转都要做判断
前后端的配合要求更高

按钮权限方案一按钮权限也可以用v-if判断
但是如果页面过多，每个页面页面都要获取用户权限role和路由表里的meta.btnPermissions，然后再做判断
这种方式就不展开举例了
方案二通过自定义指令进行按钮权限的判断
首先配置路由
&#123;    path: &#x27;/permission&#x27;,    component: Layout,    name: &#x27;权限测试&#x27;,    meta: &#123;        btnPermissions: [&#x27;admin&#x27;, &#x27;supper&#x27;, &#x27;normal&#x27;]    &#125;,    //页面需要的权限    children: [&#123;        path: &#x27;supper&#x27;,        component: _import(&#x27;system/supper&#x27;),        name: &#x27;权限测试页&#x27;,        meta: &#123;            btnPermissions: [&#x27;admin&#x27;, &#x27;supper&#x27;]        &#125; //页面需要的权限    &#125;,    &#123;        path: &#x27;normal&#x27;,        component: _import(&#x27;system/normal&#x27;),        name: &#x27;权限测试页&#x27;,        meta: &#123;            btnPermissions: [&#x27;admin&#x27;]        &#125; //页面需要的权限    &#125;]&#125;

自定义权限鉴定指令
import Vue from &#x27;vue&#x27;/**权限指令**/const has = Vue.directive(&#x27;has&#x27;, &#123;    bind: function (el, binding, vnode) &#123;        // 获取页面按钮权限        let btnPermissionsArr = [];        if(binding.value)&#123;            // 如果指令传值，获取指令参数，根据指令参数和当前登录人按钮权限做比较。            btnPermissionsArr = Array.of(binding.value);        &#125;else&#123;            // 否则获取路由中的参数，根据路由的btnPermissionsArr和当前登录人按钮权限做比较。            btnPermissionsArr = vnode.context.$route.meta.btnPermissions;        &#125;        if (!Vue.prototype.$_has(btnPermissionsArr)) &#123;            el.parentNode.removeChild(el);        &#125;    &#125;&#125;);// 权限检查方法Vue.prototype.$_has = function (value) &#123;    let isExist = false;    // 获取用户按钮权限    let btnPermissionsStr = sessionStorage.getItem(&quot;btnPermissions&quot;);    if (btnPermissionsStr == undefined || btnPermissionsStr == null) &#123;        return false;    &#125;    if (value.indexOf(btnPermissionsStr) &gt; -1) &#123;        isExist = true;    &#125;    return isExist;&#125;;export &#123;has&#125;

在使用的按钮中只需要引用v-has指令
&lt;el-button @click=&#x27;editClick&#x27; type=&quot;primary&quot; v-has&gt;编辑&lt;/el-button&gt;



小结关于权限如何选择哪种合适的方案，可以根据自己项目的方案项目，如考虑路由与菜单是否分离
权限需要前后端结合，前端尽可能的去控制，更多的需要后台判断
参考文献
https://mp.weixin.qq.com/s/b-D2eH1mLwL_FkaZwjueSw
https://segmentfault.com/a/1190000020887109
https://juejin.cn/post/6844903648057622536#heading-6

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue常用的修饰符有哪些有什么应用场景</title>
    <url>/2024/07/29/vue-modifier/</url>
    <content><![CDATA[
一、修饰符是什么在程序世界里，修饰符是用于限定类型以及类型成员的声明的一种符号
在Vue中，修饰符处理了许多DOM事件的细节，让我们不再需要花大量的时间去处理这些烦恼的事情，而能有更多的精力专注于程序的逻辑处理
vue中修饰符分为以下五种：

表单修饰符
事件修饰符
鼠标按键修饰符
键值修饰符
v-bind修饰符

二、修饰符的作用表单修饰符在我们填写表单的时候用得最多的是input标签，指令用得最多的是v-model
关于表单的修饰符有如下：

lazy
trim
number

lazy在我们填完信息，光标离开标签的时候，才会将值赋予给value，也就是在change事件之后再进行信息同步
&lt;input type=&quot;text&quot; v-model.lazy=&quot;value&quot;&gt;&lt;p&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt;

trim自动过滤用户输入的首空格字符，而中间的空格不会过滤
&lt;input type=&quot;text&quot; v-model.trim=&quot;value&quot;&gt;

number自动将用户的输入值转为数值类型，但如果这个值无法被parseFloat解析，则会返回原来的值
&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;

事件修饰符事件修饰符是对事件捕获以及目标进行了处理，有如下修饰符：

stop
prevent
self
once
capture
passive
native

stop阻止了事件冒泡，相当于调用了event.stopPropagation方法
&lt;div @click=&quot;shout(2)&quot;&gt;  &lt;button @click.stop=&quot;shout(1)&quot;&gt;ok&lt;/button&gt;&lt;/div&gt;//只输出1

prevent阻止了事件的默认行为，相当于调用了event.preventDefault方法
&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;

self只当在 event.target 是当前元素自身时触发处理函数
&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;


使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击

once绑定了事件以后只能触发一次，第二次就不会触发
&lt;button @click.once=&quot;shout(1)&quot;&gt;ok&lt;/button&gt;

capture使事件触发从包含这个元素的顶层开始往下触发
&lt;div @click.capture=&quot;shout(1)&quot;&gt;    obj1&lt;div @click.capture=&quot;shout(2)&quot;&gt;    obj2&lt;div @click=&quot;shout(3)&quot;&gt;    obj3&lt;div @click=&quot;shout(4)&quot;&gt;    obj4&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;// 输出结构: 1 2 4 3 

passive在移动端，当我们在监听元素滚动事件的时候，会一直触发onscroll事件会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给onscroll事件整了一个.lazy修饰符
&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;&lt;!-- 而不会等待 `onScroll` 完成  --&gt;&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;&lt;div v-on:scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;


不要把 .passive 和 .prevent 一起使用,因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。
passive 会告诉浏览器你不想阻止事件的默认行为

native让组件变成像html内置标签那样监听根元素的原生事件，否则组件上使用 v-on 只会监听自定义事件
&lt;my-component v-on:click.native=&quot;doSomething&quot;&gt;&lt;/my-component&gt;


使用.native修饰符来操作普通HTML标签是会令事件失效的

鼠标按钮修饰符鼠标按钮修饰符针对的就是左键、右键、中键点击，有如下：

left 左键点击
right 右键点击
middle 中键点击

&lt;button @click.left=&quot;shout(1)&quot;&gt;ok&lt;/button&gt;&lt;button @click.right=&quot;shout(1)&quot;&gt;ok&lt;/button&gt;&lt;button @click.middle=&quot;shout(1)&quot;&gt;ok&lt;/button&gt;

键盘修饰符键盘修饰符是用来修饰键盘事件（onkeyup，onkeydown）的，有如下：
keyCode存在很多，但vue为我们提供了别名，分为以下两种：

普通键（enter、tab、delete、space、esc、up…）
系统修饰键（ctrl、alt、meta、shift…）

// 只有按键为keyCode的时候才触发&lt;input type=&quot;text&quot; @keyup.keyCode=&quot;shout()&quot;&gt;

还可以通过以下方式自定义一些全局的键盘码别名
Vue.config.keyCodes.f2 = 113

v-bind修饰符v-bind修饰符主要是为属性进行操作，用来分别有如下：

async
prop
camel

async能对props进行一个双向绑定
//父组件&lt;comp :myMessage.sync=&quot;bar&quot;&gt;&lt;/comp&gt; //子组件this.$emit(&#x27;update:myMessage&#x27;,params);

以上这种方法相当于以下的简写
//父亲组件&lt;comp :myMessage=&quot;bar&quot; @update:myMessage=&quot;func&quot;&gt;&lt;/comp&gt;func(e)&#123; this.bar = e;&#125;//子组件jsfunc2()&#123;  this.$emit(&#x27;update:myMessage&#x27;,params);&#125;

使用async需要注意以下两点：

使用sync的时候，子组件传递的事件名格式必须为update:value，其中value必须与子组件中props中声明的名称完全一致

注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用

将 v-bind.sync 用在一个字面量的对象上，例如 v-bind.sync=”&#123; title: doc.title &#125;”，是无法正常工作的


props设置自定义标签属性，避免暴露数据，防止污染HTML结构
&lt;input id=&quot;uid&quot; title=&quot;title1&quot; value=&quot;1&quot; :index.prop=&quot;index&quot;&gt;

camel将命名变为驼峰命名法，如将 view-Box属性名转换为 viewBox
&lt;svg :viewBox=&quot;viewBox&quot;&gt;&lt;/svg&gt;

三、应用场景根据每一个修饰符的功能，我们可以得到以下修饰符的应用场景：

.stop：阻止事件冒泡
.native：绑定原生事件
.once：事件只执行一次
.self ：将事件绑定在自身身上，相当于阻止事件冒泡
.prevent：阻止默认事件
.caption：用于事件捕获
.once：只触发一次
.keyCode：监听特定键盘按下
.right：右键

参考文献
https://segmentfault.com/a/1190000016786254
https://vue3js.cn/docs/zh

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中provide和inject的实现原理</title>
    <url>/2024/03/21/vue-provide-inject/</url>
    <content><![CDATA[Vue中provide&#x2F;inject的实现原理1. 什么是provide&#x2F;inject？provide&#x2F;inject 是 Vue 提供的一种依赖注入机制，用于解决多层组件嵌套时的数据传递问题。它允许一个祖先组件向其所有子孙组件传递数据，而不必通过每层组件手动传递 props。
2. 基本使用示例// 父组件提供数据export default &#123;  provide() &#123;    return &#123;      message: &#x27;Hello&#x27;,      userInfo: this.userInfo    &#125;  &#125;,  data() &#123;    return &#123;      userInfo: &#123;        name: &#x27;John&#x27;      &#125;    &#125;  &#125;&#125;// 子孙组件注入数据export default &#123;  inject: [&#x27;message&#x27;, &#x27;userInfo&#x27;]&#125;

3. 实现原理解析3.1 初始化流程
组件初始化时，会按照如下顺序处理：

首先初始化 inject
然后初始化 data&#x2F;props
最后初始化 provide


provide 的处理：
// 简化的源码实现function initProvide(vm) &#123;  const provide = vm.$options.provide  if (provide) &#123;    vm._provided = typeof provide === &#x27;function&#x27;      ? provide.call(vm)      : provide  &#125;&#125;

inject 的处理：
function initInjections(vm) &#123;  const result = resolveInject(vm.$options.inject, vm)  if (result) &#123;    Object.keys(result).forEach(key =&gt; &#123;      defineReactive(vm, key, result[key])    &#125;)  &#125;&#125;

3.2 查找过程inject 的核心是向上查找的过程：

从当前组件开始，通过 $parent 属性向上遍历
检查每个父组件的 _provided 对象
如果找到对应的值则停止查找
如果到根组件还未找到，则使用默认值（如果有的话）

function resolveInject(inject, vm) &#123;  if (inject) &#123;    const result = Object.create(null)    const keys = Object.keys(inject)        for (let i = 0; i &lt; keys.length; i++) &#123;      const key = keys[i]      const provideKey = inject[key].from || key      let source = vm            while (source) &#123;        if (source._provided &amp;&amp; provideKey in source._provided) &#123;          result[key] = source._provided[provideKey]          break        &#125;        source = source.$parent      &#125;    &#125;    return result  &#125;&#125;

4. 响应式原理
provide&#x2F;inject 本身不是响应式的
如果要实现响应式，有两种方式：
提供一个响应式对象的属性
使用 computed



export default &#123;  provide() &#123;    return &#123;      // 方式1：提供响应式对象      userInfo: this.userInfo,            // 方式2：使用computed      message: computed(() =&gt; this.message)    &#125;  &#125;&#125;

5. 使用场景与注意事项5.1 适用场景
组件库开发
主题系统
全局状态管理
插件系统

5.2 注意事项
数据来源不明确

provide&#x2F;inject 使数据的来源不太明显
可能导致组件的耦合性增加


响应式问题

需要特别注意响应式的处理
建议使用响应式对象或computed


命名冲突

多个祖先组件提供同名属性时可能产生冲突
建议使用Symbol作为key



6. 总结provide&#x2F;inject 是Vue中一个强大的依赖注入系统：

实现原理基于组件的父子关系链
通过向上遍历查找注入的数据
需要特别关注响应式处理
适合用于组件库或插件开发

合理使用可以简化组件通信，但要注意避免滥用导致的维护困难。

这篇文档从概念、使用、原理、响应式处理等多个角度详细介绍了 Vue 中 provide/inject 的实现原理。包含了源码分析和实际应用建议，希望对你有帮助。

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>原理解析</tag>
      </tags>
  </entry>
  <entry>
    <title>说说你对slot的理解？slot使用场景有哪些？</title>
    <url>/2024/06/29/vue-slot/</url>
    <content><![CDATA[ 
一、slot是什么在HTML中 slot 元素 ，作为 Web Components 技术套件的一部分，是Web组件内的一个占位符
该占位符可以在后期使用自己的标记语言填充
举个栗子
&lt;template id=&quot;element-details-template&quot;&gt;  &lt;slot name=&quot;element-name&quot;&gt;Slot template&lt;/slot&gt;&lt;/template&gt;&lt;element-details&gt;  &lt;span slot=&quot;element-name&quot;&gt;1&lt;/span&gt;&lt;/element-details&gt;&lt;element-details&gt;  &lt;span slot=&quot;element-name&quot;&gt;2&lt;/span&gt;&lt;/element-details&gt;
template不会展示到页面中，需要用先获取它的引用，然后添加到DOM中，
customElements.define(&#x27;element-details&#x27;,  class extends HTMLElement &#123;    constructor() &#123;      super();      const template = document        .getElementById(&#x27;element-details-template&#x27;)        .content;      const shadowRoot = this.attachShadow(&#123;mode: &#x27;open&#x27;&#125;)        .appendChild(template.cloneNode(true));  &#125;&#125;)

在Vue中的概念也是如此
Slot 艺名插槽，花名“占坑”，我们可以理解为solt在组件模板中占好了位置，当使用该组件标签时候，组件标签里面的内容就会自动填坑（替换组件模板中slot位置），作为承载分发内容的出口
可以将其类比为插卡式的FC游戏机，游戏机暴露卡槽（插槽）让用户插入不同的游戏磁条（自定义内容）
放张图感受一下
二、使用场景通过插槽可以让用户可以拓展组件，去更好地复用组件和对其做定制化处理
如果父组件在使用到一个复用组件的时候，获取这个组件在不同的地方有少量的更改，如果去重写组件是一件不明智的事情
通过slot插槽向组件内部指定位置传递内容，完成这个复用组件在不同场景的应用
比如布局组件、表格列、下拉选、弹框显示内容等
三、分类slot可以分来以下三种：

默认插槽
具名插槽
作用域插槽

默认插槽子组件用&lt;slot&gt;标签来确定渲染的位置，标签里面可以放DOM结构，当父组件使用的时候没有往插槽传入内容，标签内DOM结构就会显示在页面
父组件在使用的时候，直接在子组件的标签内写入内容即可
子组件Child.vue
&lt;template&gt;    &lt;slot&gt;      &lt;p&gt;插槽后备的内容&lt;/p&gt;    &lt;/slot&gt;&lt;/template&gt;

父组件
&lt;Child&gt;  &lt;div&gt;默认插槽&lt;/div&gt;  &lt;/Child&gt;



具名插槽子组件用name属性来表示插槽的名字，不传为默认插槽
父组件中在使用时在默认插槽的基础上加上slot属性，值为子组件插槽name属性值
子组件Child.vue
&lt;template&gt;    &lt;slot&gt;插槽后备的内容&lt;/slot&gt;  &lt;slot name=&quot;content&quot;&gt;插槽后备的内容&lt;/slot&gt;&lt;/template&gt;

父组件
&lt;child&gt;    &lt;template v-slot:default&gt;具名插槽&lt;/template&gt;    &lt;!-- 具名插槽⽤插槽名做参数 --&gt;    &lt;template v-slot:content&gt;内容...&lt;/template&gt;&lt;/child&gt;



作用域插槽子组件在作用域上绑定属性来将子组件的信息传给父组件使用，这些属性会被挂在父组件v-slot接受的对象上
父组件中在使用时通过v-slot:（简写：#）获取子组件的信息，在内容中使用
子组件Child.vue
&lt;template&gt;   &lt;slot name=&quot;footer&quot; testProps=&quot;子组件的值&quot;&gt;          &lt;h3&gt;没传footer插槽&lt;/h3&gt;    &lt;/slot&gt;&lt;/template&gt;

父组件
&lt;child&gt;     &lt;!-- 把v-slot的值指定为作⽤域上下⽂对象 --&gt;    &lt;template v-slot:default=&quot;slotProps&quot;&gt;      来⾃⼦组件数据：&#123;&#123;slotProps.testProps&#125;&#125;    &lt;/template&gt;    &lt;template #default=&quot;slotProps&quot;&gt;      来⾃⼦组件数据：&#123;&#123;slotProps.testProps&#125;&#125;    &lt;/template&gt;&lt;/child&gt;



小结：
v-slot属性只能在&lt;template&gt;上使用，但在只有默认插槽时可以在组件标签上使用
默认插槽名为default，可以省略default直接写v-slot
缩写为#时不能不写参数，写成#default
可以通过解构获取v-slot=&#123;user&#125;，还可以重命名v-slot=&quot;&#123;user: newName&#125;&quot;和定义默认值v-slot=&quot;&#123;user = &#39;默认值&#39;&#125;&quot;

四、原理分析slot本质上是返回VNode的函数，一般情况下，Vue中的组件要渲染到页面上需要经过template -&gt; render function -&gt; VNode -&gt; DOM 过程，这里看看slot如何实现：
编写一个buttonCounter组件，使用匿名插槽
Vue.component(&#x27;button-counter&#x27;, &#123;  template: &#x27;&lt;div&gt; &lt;slot&gt;我是默认内容&lt;/slot&gt;&lt;/div&gt;&#x27;&#125;)

使用该组件
new Vue(&#123;    el: &#x27;#app&#x27;,    template: &#x27;&lt;button-counter&gt;&lt;span&gt;我是slot传入内容&lt;/span&gt;&lt;/button-counter&gt;&#x27;,    components:&#123;buttonCounter&#125;&#125;)

获取buttonCounter组件渲染函数
(function anonymous() &#123;with(this)&#123;return _c(&#x27;div&#x27;,[_t(&quot;default&quot;,[_v(&quot;我是默认内容&quot;)])],2)&#125;&#125;)

_v表示穿件普通文本节点，_t表示渲染插槽的函数
渲染插槽函数renderSlot（做了简化）
function renderSlot (  name,  fallback,  props,  bindObject) &#123;  // 得到渲染插槽内容的函数      var scopedSlotFn = this.$scopedSlots[name];  var nodes;  // 如果存在插槽渲染函数，则执行插槽渲染函数，生成nodes节点返回  // 否则使用默认值  nodes = scopedSlotFn(props) || fallback;  return nodes;&#125;

name属性表示定义插槽的名字，默认值为default，fallback表示子组件中的slot节点的默认值
关于this.$scopredSlots是什么，我们可以先看看vm.slot
function initRender (vm) &#123;  ...  vm.$slots = resolveSlots(options._renderChildren, renderContext);  ...&#125;

resolveSlots函数会对children节点做归类和过滤处理，返回slots
function resolveSlots (    children,    context  ) &#123;    if (!children || !children.length) &#123;      return &#123;&#125;    &#125;    var slots = &#123;&#125;;    for (var i = 0, l = children.length; i &lt; l; i++) &#123;      var child = children[i];      var data = child.data;      // remove slot attribute if the node is resolved as a Vue slot node      if (data &amp;&amp; data.attrs &amp;&amp; data.attrs.slot) &#123;        delete data.attrs.slot;      &#125;      // named slots should only be respected if the vnode was rendered in the      // same context.      if ((child.context === context || child.fnContext === context) &amp;&amp;        data &amp;&amp; data.slot != null      ) &#123;        // 如果slot存在(slot=&quot;header&quot;) 则拿对应的值作为key        var name = data.slot;        var slot = (slots[name] || (slots[name] = []));        // 如果是tempalte元素 则把template的children添加进数组中，这也就是为什么你写的template标签并不会渲染成另一个标签到页面        if (child.tag === &#x27;template&#x27;) &#123;          slot.push.apply(slot, child.children || []);        &#125; else &#123;          slot.push(child);        &#125;      &#125; else &#123;        // 如果没有就默认是default        (slots.default || (slots.default = [])).push(child);      &#125;    &#125;    // ignore slots that contains only whitespace    for (var name$1 in slots) &#123;      if (slots[name$1].every(isWhitespace)) &#123;        delete slots[name$1];      &#125;    &#125;    return slots&#125;

_render渲染函数通过normalizeScopedSlots得到vm.$scopedSlots
vm.$scopedSlots = normalizeScopedSlots(  _parentVnode.data.scopedSlots,  vm.$slots,  vm.$scopedSlots);

作用域插槽中父组件能够得到子组件的值是因为在renderSlot的时候执行会传入props，也就是上述_t第三个参数，父组件则能够得到子组件传递过来的值
参考文献
https://juejin.cn/post/6844903817746628615#heading-4
https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots
https://vue3js.cn/docs/zh
https://segmentfault.com/a/1190000019492734?utm_source=tag-newest

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>v-show和v-if有什么区别？使用场景分别是什么？</title>
    <url>/2024/07/01/vue-show-if/</url>
    <content><![CDATA[
一、v-show与v-if的共同点我们都知道在 vue 中 v-show  与 v-if 的作用效果是相同的(不含v-else)，都能控制元素在页面是否显示
在用法上也是相同的
&lt;Model v-show=&quot;isShow&quot; /&gt;&lt;Model v-if=&quot;isShow&quot; /&gt;


当表达式为true的时候，都会占据页面的位置
当表达式都为false时，都不会占据页面位置

二、v-show与v-if的区别
控制手段不同
编译过程不同
编译条件不同

控制手段：v-show隐藏则是为该元素添加css--display:none，dom元素依旧还在。v-if显示隐藏是将dom元素整个添加或删除
编译过程：v-if切换有一个局部编译&#x2F;卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换
编译条件：v-if是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染

v-show 由false变为true的时候不会触发组件的生命周期

v-if由false变为true的时候，触发组件的beforeCreate、create、beforeMount、mounted钩子，由true变为false的时候触发组件的beforeDestory、destoryed方法


性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；
三、v-show与v-if原理分析具体解析流程这里不展开讲，大致流程如下

将模板template转为ast结构的JS对象
用ast得到的JS对象拼装render和staticRenderFns函数
render和staticRenderFns函数被调用后生成虚拟VNODE节点，该节点包含创建DOM节点所需信息
vm.patch函数通过虚拟DOM算法利用VNODE节点创建真实DOM节点

v-show原理不管初始条件是什么，元素总是会被渲染
我们看一下在vue中是如何实现的
代码很好理解，有transition就执行transition，没有就直接设置display属性
// https://github.com/vuejs/vue-next/blob/3cd30c5245da0733f9eb6f29d220f39c46518162/packages/runtime-dom/src/directives/vShow.tsexport const vShow: ObjectDirective&lt;VShowElement&gt; = &#123;  beforeMount(el, &#123; value &#125;, &#123; transition &#125;) &#123;    el._vod = el.style.display === &#x27;none&#x27; ? &#x27;&#x27; : el.style.display    if (transition &amp;&amp; value) &#123;      transition.beforeEnter(el)    &#125; else &#123;      setDisplay(el, value)    &#125;  &#125;,  mounted(el, &#123; value &#125;, &#123; transition &#125;) &#123;    if (transition &amp;&amp; value) &#123;      transition.enter(el)    &#125;  &#125;,  updated(el, &#123; value, oldValue &#125;, &#123; transition &#125;) &#123;    // ...  &#125;,  beforeUnmount(el, &#123; value &#125;) &#123;    setDisplay(el, value)  &#125;&#125;

v-if原理v-if在实现上比v-show要复杂的多，因为还有else else-if 等条件需要处理，这里我们也只摘抄源码中处理 v-if 的一小部分
返回一个node节点，render函数通过表达式的值来决定是否生成DOM
// https://github.com/vuejs/vue-next/blob/cdc9f336fd/packages/compiler-core/src/transforms/vIf.tsexport const transformIf = createStructuralDirectiveTransform(  /^(if|else|else-if)$/,  (node, dir, context) =&gt; &#123;    return processIf(node, dir, context, (ifNode, branch, isRoot) =&gt; &#123;      // ...      return () =&gt; &#123;        if (isRoot) &#123;          ifNode.codegenNode = createCodegenNodeForBranch(            branch,            key,            context          ) as IfConditionalExpression        &#125; else &#123;          // attach this branch&#x27;s codegen node to the v-if root.          const parentCondition = getParentCondition(ifNode.codegenNode!)          parentCondition.alternate = createCodegenNodeForBranch(            branch,            key + ifNode.branches.length - 1,            context          )        &#125;      &#125;    &#125;)  &#125;)

四、v-show与v-if的使用场景v-if 与 v-show 都能控制dom元素在页面的显示
v-if 相比 v-show 开销更大的（直接操作dom节点增加与删除） 
如果需要非常频繁地切换，则使用 v-show 较好
如果在运行时条件很少改变，则使用 v-if 较好
参考文献
https://www.jianshu.com/p/7af8554d8f08
https://juejin.cn/post/6897948855904501768
https://vue3js/docs/zh

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢</title>
    <url>/2024/06/28/vue-spa/</url>
    <content><![CDATA[
一、什么是SPASPA（single-page application），翻译过来就是单页应用SPA是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，这种方法避免了页面之间切换打断用户体验在单页应用中，所有必要的代码（HTML、JavaScript和CSS）都通过单个页面的加载而检索，或者根据需要（通常是为响应用户操作）动态装载适当的资源并添加到页面页面在任何时间点都不会重新加载，也不会将控制转移到其他页面举个例子来讲就是一个杯子，早上装的牛奶，中午装的是开水，晚上装的是茶，我们发现，变的始终是杯子里的内容，而杯子始终是那个杯子结构如下图
 
我们熟知的JS框架如react,vue,angular,ember都属于SPA
二、SPA和MPA的区别上面大家已经对单页面有所了解了，下面来讲讲多页应用MPA（MultiPage-page application），翻译过来就是多页应用在MPA中，每个页面都是一个主页面，都是独立的当我们在访问另一个页面的时候，都需要重新加载html、css、js文件，公共文件则根据需求按需加载如下图
 
单页应用与多页应用的区别



单页面应用（SPA）
多页面应用（MPA）



组成
一个主页面和多个页面片段
多个主页面


刷新方式
局部刷新
整页刷新


url模式
哈希模式
历史模式


SEO搜索引擎优化
难实现，可使用SSR方式改善
容易实现


数据传递
容易
通过url、cookie、localStorage等传递


页面切换
速度快，用户体验良好
切换加载资源，速度慢，用户体验差


维护成本
相对容易
相对复杂


单页应用优缺点优点：

具有桌面应用的即时性、网站的可移植性和可访问性
用户体验好、快，内容的改变不需要重新加载整个页面
良好的前后端分离，分工更明确

缺点：

不利于搜索引擎的抓取
首次渲染速度相对较慢


三、实现一个SPA原理
监听地址栏中hash变化驱动界面变化
用pushsate记录浏览器的历史，驱动界面发送变化

 
实现hash 模式核心通过监听url中的hash来进行路由跳转
// 定义 Router  class Router &#123;      constructor () &#123;          this.routes = &#123;&#125;; // 存放路由path及callback          this.currentUrl = &#x27;&#x27;;                    // 监听路由change调用相对应的路由回调          window.addEventListener(&#x27;load&#x27;, this.refresh, false);          window.addEventListener(&#x27;hashchange&#x27;, this.refresh, false);      &#125;            route(path, callback)&#123;          this.routes[path] = callback;      &#125;            push(path) &#123;          this.routes[path] &amp;&amp; this.routes[path]()      &#125;  &#125;    // 使用 router  window.miniRouter = new Router();  miniRouter.route(&#x27;/&#x27;, () =&gt; console.log(&#x27;page1&#x27;))  miniRouter.route(&#x27;/page2&#x27;, () =&gt; console.log(&#x27;page2&#x27;))    miniRouter.push(&#x27;/&#x27;) // page1  miniRouter.push(&#x27;/page2&#x27;) // page2  

history模式history 模式核心借用 HTML5 history api，api 提供了丰富的 router 相关属性先了解一个几个相关的api

history.pushState 浏览器历史纪录添加记录
history.replaceState修改浏览器历史纪录中当前纪录
history.popState 当 history 发生变化时触发

// 定义 Router  class Router &#123;      constructor () &#123;          this.routes = &#123;&#125;;          this.listerPopState()      &#125;            init(path) &#123;          history.replaceState(&#123;path: path&#125;, null, path);          this.routes[path] &amp;&amp; this.routes[path]();      &#125;            route(path, callback)&#123;          this.routes[path] = callback;      &#125;            push(path) &#123;          history.pushState(&#123;path: path&#125;, null, path);          this.routes[path] &amp;&amp; this.routes[path]();      &#125;            listerPopState () &#123;          window.addEventListener(&#x27;popstate&#x27; , e =&gt; &#123;              const path = e.state &amp;&amp; e.state.path;              this.routers[path] &amp;&amp; this.routers[path]()          &#125;)      &#125;  &#125;    // 使用 Router    window.miniRouter = new Router();  miniRouter.route(&#x27;/&#x27;, ()=&gt; console.log(&#x27;page1&#x27;))  miniRouter.route(&#x27;/page2&#x27;, ()=&gt; console.log(&#x27;page2&#x27;))    // 跳转  miniRouter.push(&#x27;/page2&#x27;)  // page2  

四、题外话：如何给SPA做SEO下面给出基于Vue的SPA如何实现SEO的三种方式

SSR服务端渲染

将组件或页面通过服务器生成html，再返回给浏览器，如nuxt.js

静态化

目前主流的静态化主要有两种：（1）一种是通过程序将动态页面抓取并保存为静态页面，这样的页面的实际存在于服务器的硬盘中（2）另外一种是通过WEB服务器的 URL Rewrite的方式，它的原理是通过web服务器内部模块按一定规则将外部的URL请求转化为内部的文件地址，一句话来说就是把外部请求的静态地址转化为实际的动态页面地址，而静态页面实际是不存在的。这两种方法都达到了实现URL静态化的效果

使用Phantomjs针对爬虫处理

原理是通过Nginx配置，判断访问来源是否为爬虫，如果是则搜索引擎的爬虫请求会转发到一个node server，再通过PhantomJS来解析完整的HTML，返回给爬虫。下面是大致流程图
 
参考文献
https://segmentfault.com/a/1190000019623624
https://juejin.cn/post/6844903512107663368
https://www.cnblogs.com/constantince/p/5586851.html

 
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>SSR解决了什么问题？有做过SSR吗？你是怎么做的？</title>
    <url>/2024/06/26/vue-ssr/</url>
    <content><![CDATA[
一、是什么Server-Side Rendering 我们称其为SSR，意为服务端渲染
指由服务侧完成页面的 HTML 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程
先来看看Web3个阶段的发展史：

传统服务端渲染SSR
单页面应用SPA
服务端渲染SSR

传统web开发网页内容在服务端渲染完成，⼀次性传输到浏览器

打开页面查看源码，浏览器拿到的是全部的dom结构
单页应用SPA单页应用优秀的用户体验，使其逐渐成为主流，页面内容由JS渲染出来，这种方式称为客户端渲染

打开页面查看源码，浏览器拿到的仅有宿主元素#app，并没有内容
服务端渲染SSRSSR解决方案，后端渲染出完整的首屏的dom结构返回，前端拿到的内容包括首屏及完整spa结构，应用激活后依然按照spa方式运行

看完前端发展，我们再看看Vue官方对SSR的解释：

Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序
服务器渲染的 Vue.js 应用程序也可以被认为是”同构”或”通用”，因为应用程序的大部分代码都可以在服务器和客户端上运行

我们从上门解释得到以下结论：

Vue SSR是一个在SPA上进行改良的服务端渲染
通过Vue SSR渲染的页面，需要在客户端激活才能实现交互
Vue SSR将包含两部分：服务端渲染的首屏，包含交互的SPA

二、解决了什么SSR主要解决了以下两种问题：

seo：搜索引擎优先爬取页面HTML结构，使用ssr时，服务端已经生成了和业务想关联的HTML，有利于seo
首屏呈现渲染：用户无需等待页面所有js加载完成就可以看到页面视图（压力来到了服务器，所以需要权衡哪些用服务端渲染，哪些交给客户端）

但是使用SSR同样存在以下的缺点：

复杂度：整个项目的复杂度

库的支持性，代码兼容

性能问题

每个请求都是n个实例的创建，不然会污染，消耗会变得很大

缓存 node serve 、 nginx判断当前用户有没有过期，如果没过期的话就缓存，用刚刚的结果。

降级：监控cpu、内存占用过多，就spa，返回单个的壳



服务器负载变大，相对于前后端分离服务器只需要提供静态资源来说，服务器负载更大，所以要慎重使用


所以在我们选择是否使用SSR前，我们需要慎重问问自己这些问题：

需要SEO的页面是否只是少数几个，这些是否可以使用预渲染（Prerender SPA Plugin）实现
首屏的请求响应逻辑是否复杂，数据返回是否大量且缓慢

三、如何实现对于同构开发，我们依然使用webpack打包，我们要解决两个问题：服务端首屏渲染和客户端激活
这里需要生成一个服务器bundle文件用于服务端首屏渲染和一个客户端bundle文件用于客户端激活
 
代码结构 除了两个不同入口之外，其他结构和之前vue应用完全相同
src├── router├────── index.js # 路由声明├── store├────── index.js # 全局状态├── main.js # ⽤于创建vue实例├── entry-client.js # 客户端⼊⼝，⽤于静态内容“激活”└── entry-server.js # 服务端⼊⼝，⽤于⾸屏内容渲染

路由配置
import Vue from &quot;vue&quot;;import Router from &quot;vue-router&quot;;Vue.use(Router);//导出⼯⼚函数export function createRouter() &#123;    return new Router(&#123;        mode: &#x27;history&#x27;,        routes: [            // 客户端没有编译器，这⾥要写成渲染函数            &#123; path: &quot;/&quot;, component: &#123; render: h =&gt; h(&#x27;div&#x27;, &#x27;index page&#x27;) &#125; &#125;,            &#123; path: &quot;/detail&quot;, component: &#123; render: h =&gt; h(&#x27;div&#x27;, &#x27;detail page&#x27;) &#125; &#125;        ]    &#125;);&#125;

主文件main.js
跟之前不同，主文件是负责创建vue实例的工厂，每次请求均会有独立的vue实例创建
import Vue from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import &#123; createRouter &#125; from &quot;./router&quot;;// 导出Vue实例⼯⼚函数，为每次请求创建独⽴实例// 上下⽂⽤于给vue实例传递参数export function createApp(context) &#123;    const router = createRouter();    const app = new Vue(&#123;        router,        context,        render: h =&gt; h(App)    &#125;);    return &#123; app, router &#125;;&#125;

编写服务端入口src/entry-server.js
它的任务是创建Vue实例并根据传入url指定首屏
import &#123; createApp &#125; from &quot;./main&quot;;// 返回⼀个函数，接收请求上下⽂，返回创建的vue实例export default context =&gt; &#123;    // 这⾥返回⼀个Promise，确保路由或组件准备就绪    return new Promise((resolve, reject) =&gt; &#123;        const &#123; app, router &#125; = createApp(context);        // 跳转到⾸屏的地址        router.push(context.url);        // 路由就绪，返回结果        router.onReady(() =&gt; &#123;            resolve(app);        &#125;, reject);    &#125;);&#125;;

编写客户端入口entry-client.js
客户端入口只需创建vue实例并执行挂载，这⼀步称为激活
import &#123; createApp &#125; from &quot;./main&quot;;// 创建vue、router实例const &#123; app, router &#125; = createApp();// 路由就绪，执⾏挂载router.onReady(() =&gt; &#123;    app.$mount(&quot;#app&quot;);&#125;);

对webpack进行配置
安装依赖
npm install webpack-node-externals lodash.merge -D

对vue.config.js进行配置
// 两个插件分别负责打包客户端和服务端const VueSSRServerPlugin = require(&quot;vue-server-renderer/server-plugin&quot;);const VueSSRClientPlugin = require(&quot;vue-server-renderer/client-plugin&quot;);const nodeExternals = require(&quot;webpack-node-externals&quot;);const merge = require(&quot;lodash.merge&quot;);// 根据传⼊环境变量决定⼊⼝⽂件和相应配置项const TARGET_NODE = process.env.WEBPACK_TARGET === &quot;node&quot;;const target = TARGET_NODE ? &quot;server&quot; : &quot;client&quot;;module.exports = &#123;    css: &#123;        extract: false    &#125;,    outputDir: &#x27;./dist/&#x27;+target,    configureWebpack: () =&gt; (&#123;        // 将 entry 指向应⽤程序的 server / client ⽂件        entry: `./src/entry-$&#123;target&#125;.js`,        // 对 bundle renderer 提供 source map ⽀持        devtool: &#x27;source-map&#x27;,        // target设置为node使webpack以Node适⽤的⽅式处理动态导⼊，        // 并且还会在编译Vue组件时告知`vue-loader`输出⾯向服务器代码。        target: TARGET_NODE ? &quot;node&quot; : &quot;web&quot;,        // 是否模拟node全局变量        node: TARGET_NODE ? undefined : false,        output: &#123;            // 此处使⽤Node⻛格导出模块            libraryTarget: TARGET_NODE ? &quot;commonjs2&quot; : undefined        &#125;,        // https://webpack.js.org/configuration/externals/#function        // https://github.com/liady/webpack-node-externals        // 外置化应⽤程序依赖模块。可以使服务器构建速度更快，并⽣成较⼩的打包⽂件。        externals: TARGET_NODE        ? nodeExternals(&#123;            // 不要外置化webpack需要处理的依赖模块。            // 可以在这⾥添加更多的⽂件类型。例如，未处理 *.vue 原始⽂件，            // 还应该将修改`global`（例如polyfill）的依赖模块列⼊⽩名单            whitelist: [/\.css$/]        &#125;)        : undefined,        optimization: &#123;            splitChunks: undefined        &#125;,        // 这是将服务器的整个输出构建为单个 JSON ⽂件的插件。        // 服务端默认⽂件名为 `vue-ssr-server-bundle.json`        // 客户端默认⽂件名为 `vue-ssr-client-manifest.json`。        plugins: [TARGET_NODE ? new VueSSRServerPlugin() : new                  VueSSRClientPlugin()]    &#125;),    chainWebpack: config =&gt; &#123;        // cli4项⽬添加        if (TARGET_NODE) &#123;            config.optimization.delete(&#x27;splitChunks&#x27;)        &#125;        config.module            .rule(&quot;vue&quot;)            .use(&quot;vue-loader&quot;)            .tap(options =&gt; &#123;            merge(options, &#123;                optimizeSSR: false            &#125;);        &#125;);    &#125;&#125;;

对脚本进行配置，安装依赖
npm i cross-env -D

定义创建脚本package.json
&quot;scripts&quot;: &#123; &quot;build:client&quot;: &quot;vue-cli-service build&quot;, &quot;build:server&quot;: &quot;cross-env WEBPACK_TARGET=node vue-cli-service build&quot;, &quot;build&quot;: &quot;npm run build:server &amp;&amp; npm run build:client&quot;&#125;


执行打包：npm run build

最后修改宿主文件/public/index.html
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;        &lt;title&gt;Document&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--vue-ssr-outlet--&gt;    &lt;/body&gt;&lt;/html&gt;


   是服务端渲染入口位置，注意不能为了好看而在前后加空格

安装vuex
npm install -S vuex

创建vuex工厂函数
import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)export function createStore () &#123;    return new Vuex.Store(&#123;        state: &#123;            count:108        &#125;,        mutations: &#123;            add(state)&#123;                state.count += 1;            &#125;        &#125;    &#125;)&#125;

在main.js文件中挂载store
import &#123; createStore &#125; from &#x27;./store&#x27;export function createApp (context) &#123;    // 创建实例    const store = createStore()    const app = new Vue(&#123;        store, // 挂载        render: h =&gt; h(App)    &#125;)    return &#123; app, router, store &#125;&#125;

服务器端渲染的是应用程序的”快照”，如果应用依赖于⼀些异步数据，那么在开始渲染之前，需要先预取和解析好这些数据
在store进行一步数据获取
export function createStore() &#123;    return new Vuex.Store(&#123;        mutations: &#123;            // 加⼀个初始化            init(state, count) &#123;                state.count = count;            &#125;,        &#125;,        actions: &#123;            // 加⼀个异步请求count的action            getCount(&#123; commit &#125;) &#123;                return new Promise(resolve =&gt; &#123;                    setTimeout(() =&gt; &#123;                        commit(&quot;init&quot;, Math.random() * 100);                        resolve();                    &#125;, 1000);                &#125;);            &#125;,        &#125;,    &#125;);&#125;

组件中的数据预取逻辑
export default &#123;    asyncData(&#123; store, route &#125;) &#123; // 约定预取逻辑编写在预取钩⼦asyncData中        // 触发 action 后，返回 Promise 以便确定请求结果        return store.dispatch(&quot;getCount&quot;);    &#125;&#125;;

服务端数据预取，entry-server.js
import &#123; createApp &#125; from &quot;./app&quot;;export default context =&gt; &#123;    return new Promise((resolve, reject) =&gt; &#123;        // 拿出store和router实例        const &#123; app, router, store &#125; = createApp(context);        router.push(context.url);        router.onReady(() =&gt; &#123;            // 获取匹配的路由组件数组            const matchedComponents = router.getMatchedComponents();            // 若⽆匹配则抛出异常            if (!matchedComponents.length) &#123;                return reject(&#123; code: 404 &#125;);            &#125;            // 对所有匹配的路由组件调⽤可能存在的`asyncData()`            Promise.all(                matchedComponents.map(Component =&gt; &#123;                    if (Component.asyncData) &#123;                        return Component.asyncData(&#123;                            store,                            route: router.currentRoute,                        &#125;);                    &#125;                &#125;),            )                .then(() =&gt; &#123;                // 所有预取钩⼦ resolve 后，                // store 已经填充⼊渲染应⽤所需状态                // 将状态附加到上下⽂，且 `template` 选项⽤于 renderer 时，                // 状态将⾃动序列化为 `window.__INITIAL_STATE__`，并注⼊ HTML                context.state = store.state;                resolve(app);            &#125;)                .catch(reject);        &#125;, reject);    &#125;);&#125;;

客户端在挂载到应用程序之前，store 就应该获取到状态，entry-client.js
// 导出storeconst &#123; app, router, store &#125; = createApp();// 当使⽤ template 时，context.state 将作为 window.__INITIAL_STATE__ 状态⾃动嵌⼊到最终的 HTML // 在客户端挂载到应⽤程序之前，store 就应该获取到状态：if (window.__INITIAL_STATE__) &#123;    store.replaceState(window.__INITIAL_STATE__);&#125;

客户端数据预取处理，main.js
Vue.mixin(&#123;    beforeMount() &#123;        const &#123; asyncData &#125; = this.$options;        if (asyncData) &#123;            // 将获取数据操作分配给 promise            // 以便在组件中，我们可以在数据准备就绪后            // 通过运⾏ `this.dataPromise.then(...)` 来执⾏其他任务            this.dataPromise = asyncData(&#123;                store: this.$store,                route: this.$route,            &#125;);        &#125;    &#125;,&#125;);

修改服务器启动文件
// 获取⽂件路径const resolve = dir =&gt; require(&#x27;path&#x27;).resolve(__dirname, dir)// 第 1 步：开放dist/client⽬录，关闭默认下载index⻚的选项，不然到不了后⾯路由app.use(express.static(resolve(&#x27;../dist/client&#x27;), &#123;index: false&#125;))// 第 2 步：获得⼀个createBundleRendererconst &#123; createBundleRenderer &#125; = require(&quot;vue-server-renderer&quot;);// 第 3 步：服务端打包⽂件地址const bundle = resolve(&quot;../dist/server/vue-ssr-server-bundle.json&quot;);// 第 4 步：创建渲染器const renderer = createBundleRenderer(bundle, &#123;    runInNewContext: false, // https://ssr.vuejs.org/zh/api/#runinnewcontext    template: require(&#x27;fs&#x27;).readFileSync(resolve(&quot;../public/index.html&quot;), &quot;utf8&quot;), // 宿主⽂件    clientManifest: require(resolve(&quot;../dist/client/vue-ssr-clientmanifest.json&quot;)) // 客户端清单&#125;);app.get(&#x27;*&#x27;, async (req,res)=&gt;&#123;    // 设置url和title两个重要参数    const context = &#123;        title:&#x27;ssr test&#x27;,        url:req.url    &#125;    const html = await renderer.renderToString(context);    res.send(html)&#125;)



小结
使用ssr不存在单例模式，每次用户请求都会创建一个新的vue实例
实现ssr需要实现服务端首屏渲染和客户端激活
服务端异步获取数据asyncData可以分为首屏异步获取和切换组件获取
首屏异步获取数据，在服务端预渲染的时候就应该已经完成
切换组件通过mixin混入，在beforeMount钩子完成数据获取



参考文献
https://juejin.cn/post/6896007907050487816
https://vue3js.cn/docs/zh

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是虚拟DOM？如何实现一个虚拟DOM？说说你的思路</title>
    <url>/2024/06/20/vue-vnode/</url>
    <content><![CDATA[ 
一、什么是虚拟DOM虚拟 DOM （Virtual DOM ）这个概念相信大家都不陌生，从 React 到 Vue ，虚拟 DOM 为这两个框架都带来了跨平台的能力（React-Native 和 Weex）
实际上它只是一层对真实DOM的抽象，以JavaScript 对象 (VNode 节点) 作为基础的树，用对象的属性来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上
在Javascript对象中，虚拟DOM 表现为一个 Object 对象。并且最少包含标签名 (tag)、属性 (attrs) 和子元素对象 (children) 三个属性，不同框架对这三个属性的名命可能会有差别
创建虚拟DOM就是为了更好将虚拟的节点渲染到页面视图中，所以虚拟DOM对象的节点与真实DOM的属性一一照应
在vue中同样使用到了虚拟DOM技术
定义真实DOM
&lt;div id=&quot;app&quot;&gt;    &lt;p class=&quot;p&quot;&gt;节点内容&lt;/p&gt;    &lt;h3&gt;&#123;&#123; foo &#125;&#125;&lt;/h3&gt;&lt;/div&gt;

实例化vue
const app = new Vue(&#123;    el:&quot;#app&quot;,    data:&#123;        foo:&quot;foo&quot;    &#125;&#125;)

观察render的render，我们能得到虚拟DOM
(function anonymous() &#123;	with(this)&#123;return _c(&#x27;div&#x27;,&#123;attrs:&#123;&quot;id&quot;:&quot;app&quot;&#125;&#125;,[_c(&#x27;p&#x27;,&#123;staticClass:&quot;p&quot;&#125;,					  [_v(&quot;节点内容&quot;)]),_v(&quot; &quot;),_c(&#x27;h3&#x27;,[_v(_s(foo))])])&#125;&#125;)

通过VNode，vue可以对这颗抽象树进行创建节点,删除节点以及修改节点的操作， 经过diff算法得出一些需要修改的最小单位,再更新视图，减少了dom操作，提高了性能
二、为什么需要虚拟DOMDOM是很慢的，其元素非常庞大，页面的性能问题，大部分都是由DOM操作引起的
真实的DOM节点，哪怕一个最简单的div也包含着很多属性，可以打印出来直观感受一下： 
由此可见，操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验
举个例子：
你用传统的原生api或jQuery去操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程
当你在一次操作时，需要更新10个DOM节点，浏览器没这么智能，收到第一个更新DOM请求后，并不知道后续还有9次更新操作，因此会马上执行流程，最终执行10次流程
而通过VNode，同样更新10个DOM节点，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地的一个js对象中，最终将这个js对象一次性attach到DOM树上，避免大量的无谓计算

很多人认为虚拟 DOM 最大的优势是 diff 算法，减少 JavaScript 操作真实 DOM 的带来的性能消耗。虽然这一个虚拟 DOM 带来的一个优势，但并不是全部。虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种GUI

三、如何实现虚拟DOM首先可以看看vue中VNode的结构
源码位置：src&#x2F;core&#x2F;vdom&#x2F;vnode.js
export default class VNode &#123;  tag: string | void;  data: VNodeData | void;  children: ?Array&lt;VNode&gt;;  text: string | void;  elm: Node | void;  ns: string | void;  context: Component | void; // rendered in this component&#x27;s scope  functionalContext: Component | void; // only for functional component root nodes  key: string | number | void;  componentOptions: VNodeComponentOptions | void;  componentInstance: Component | void; // component instance  parent: VNode | void; // component placeholder node  raw: boolean; // contains raw HTML? (server only)  isStatic: boolean; // hoisted static node  isRootInsert: boolean; // necessary for enter transition check  isComment: boolean; // empty comment placeholder?  isCloned: boolean; // is a cloned node?  isOnce: boolean; // is a v-once node?  constructor (    tag?: string,    data?: VNodeData,    children?: ?Array&lt;VNode&gt;,    text?: string,    elm?: Node,    context?: Component,    componentOptions?: VNodeComponentOptions  ) &#123;    /*当前节点的标签名*/    this.tag = tag    /*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/    this.data = data    /*当前节点的子节点，是一个数组*/    this.children = children    /*当前节点的文本*/    this.text = text    /*当前虚拟节点对应的真实dom节点*/    this.elm = elm    /*当前节点的名字空间*/    this.ns = undefined    /*编译作用域*/    this.context = context    /*函数化组件作用域*/    this.functionalContext = undefined    /*节点的key属性，被当作节点的标志，用以优化*/    this.key = data &amp;&amp; data.key    /*组件的option选项*/    this.componentOptions = componentOptions    /*当前节点对应的组件的实例*/    this.componentInstance = undefined    /*当前节点的父节点*/    this.parent = undefined    /*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/    this.raw = false    /*静态节点标志*/    this.isStatic = false    /*是否作为跟节点插入*/    this.isRootInsert = true    /*是否为注释节点*/    this.isComment = false    /*是否为克隆节点*/    this.isCloned = false    /*是否有v-once指令*/    this.isOnce = false  &#125;  // DEPRECATED: alias for componentInstance for backwards compat.  /* istanbul ignore next https://github.com/answershuto/learnVue*/  get child (): Component | void &#123;    return this.componentInstance  &#125;&#125;

这里对VNode进行稍微的说明：

所有对象的 context 选项都指向了 Vue 实例
elm 属性则指向了其相对应的真实 DOM 节点

vue是通过createElement生成VNode
源码位置：src&#x2F;core&#x2F;vdom&#x2F;create-element.js
export function createElement (  context: Component,  tag: any,  data: any,  children: any,  normalizationType: any,  alwaysNormalize: boolean): VNode | Array&lt;VNode&gt; &#123;  if (Array.isArray(data) || isPrimitive(data)) &#123;    normalizationType = children    children = data    data = undefined  &#125;  if (isTrue(alwaysNormalize)) &#123;    normalizationType = ALWAYS_NORMALIZE  &#125;  return _createElement(context, tag, data, children, normalizationType)&#125;

上面可以看到createElement 方法实际上是对 _createElement 方法的封装，对参数的传入进行了判断
export function _createElement(    context: Component,    tag?: string | Class&lt;Component&gt; | Function | Object,    data?: VNodeData,    children?: any,    normalizationType?: number): VNode | Array&lt;VNode&gt; &#123;    if (isDef(data) &amp;&amp; isDef((data: any).__ob__)) &#123;        process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(            `Avoid using observed data object as vnode data: $&#123;JSON.stringify(data)&#125;\n` +            &#x27;Always create fresh vnode data objects in each render!&#x27;,            context`        )        return createEmptyVNode()    &#125;    // object syntax in v-bind    if (isDef(data) &amp;&amp; isDef(data.is)) &#123;        tag = data.is    &#125;    if (!tag) &#123;        // in case of component :is set to falsy value        return createEmptyVNode()    &#125;    ...     // support single function children as default scoped slot    if (Array.isArray(children) &amp;&amp;        typeof children[0] === &#x27;function&#x27;    ) &#123;        data = data || &#123;&#125;        data.scopedSlots = &#123; default: children[0] &#125;        children.length = 0    &#125;    if (normalizationType === ALWAYS_NORMALIZE) &#123;        children = normalizeChildren(children)    &#125; else if ( === SIMPLE_NORMALIZE) &#123;        children = simpleNormalizeChildren(children)    &#125;	// 创建VNode    ...&#125;

可以看到_createElement接收5个参数：

context 表示 VNode 的上下文环境，是 Component 类型

tag 表示标签，它可以是一个字符串，也可以是一个 Component

data 表示 VNode 的数据，它是一个 VNodeData 类型

children 表示当前 VNode 的子节点，它是任意类型的

normalizationType 表示子节点规范的类型，类型不同规范的方法也就不一样，主要是参考 render 函数是编译生成的还是用户手写的


根据normalizationType 的类型，children会有不同的定义
if (normalizationType === ALWAYS_NORMALIZE) &#123;    children = normalizeChildren(children)&#125; else if ( === SIMPLE_NORMALIZE) &#123;    children = simpleNormalizeChildren(children)&#125;

simpleNormalizeChildren方法调用场景是 render 函数是编译生成的
normalizeChildren方法调用场景分为下面两种：

render 函数是用户手写的
编译 slot、v-for 的时候会产生嵌套数组

无论是simpleNormalizeChildren还是normalizeChildren都是对children进行规范（使children 变成了一个类型为 VNode 的 Array），这里就不展开说了
规范化children的源码位置在：src&#x2F;core&#x2F;vdom&#x2F;helpers&#x2F;normalzie-children.js
在规范化children后，就去创建VNode
let vnode, ns// 对tag进行判断if (typeof tag === &#x27;string&#x27;) &#123;  let Ctor  ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag)  if (config.isReservedTag(tag)) &#123;    // 如果是内置的节点，则直接创建一个普通VNode    vnode = new VNode(      config.parsePlatformTagName(tag), data, children,      undefined, undefined, context    )  &#125; else if (isDef(Ctor = resolveAsset(context.$options, &#x27;components&#x27;, tag))) &#123;    // component    // 如果是component类型，则会通过createComponent创建VNode节点    vnode = createComponent(Ctor, data, context, children, tag)  &#125; else &#123;    vnode = new VNode(      tag, data, children,      undefined, undefined, context    )  &#125;&#125; else &#123;  // direct component options / constructor  vnode = createComponent(tag, data, context, children)&#125;

createComponent同样是创建VNode
源码位置：src&#x2F;core&#x2F;vdom&#x2F;create-component.js
export function createComponent (  Ctor: Class&lt;Component&gt; | Function | Object | void,  data: ?VNodeData,  context: Component,  children: ?Array&lt;VNode&gt;,  tag?: string): VNode | Array&lt;VNode&gt; | void &#123;  if (isUndef(Ctor)) &#123;    return  &#125; // 构建子类构造函数   const baseCtor = context.$options._base  // plain options object: turn it into a constructor  if (isObject(Ctor)) &#123;    Ctor = baseCtor.extend(Ctor)  &#125;  // if at this stage it&#x27;s not a constructor or an async component factory,  // reject.  if (typeof Ctor !== &#x27;function&#x27;) &#123;    if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;      warn(`Invalid Component definition: $&#123;String(Ctor)&#125;`, context)    &#125;    return  &#125;  // async component  let asyncFactory  if (isUndef(Ctor.cid)) &#123;    asyncFactory = Ctor    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context)    if (Ctor === undefined) &#123;      return createAsyncPlaceholder(        asyncFactory,        data,        context,        children,        tag      )    &#125;  &#125;  data = data || &#123;&#125;  // resolve constructor options in case global mixins are applied after  // component constructor creation  resolveConstructorOptions(Ctor)  // transform component v-model data into props &amp; events  if (isDef(data.model)) &#123;    transformModel(Ctor.options, data)  &#125;  // extract props  const propsData = extractPropsFromVNodeData(data, Ctor, tag)  // functional component  if (isTrue(Ctor.options.functional)) &#123;    return createFunctionalComponent(Ctor, propsData, data, context, children)  &#125;  // extract listeners, since these needs to be treated as  // child component listeners instead of DOM listeners  const listeners = data.on  // replace with listeners with .native modifier  // so it gets processed during parent component patch.  data.on = data.nativeOn  if (isTrue(Ctor.options.abstract)) &#123;    const slot = data.slot    data = &#123;&#125;    if (slot) &#123;      data.slot = slot    &#125;  &#125;  // 安装组件钩子函数，把钩子函数合并到data.hook中  installComponentHooks(data)  //实例化一个VNode返回。组件的VNode是没有children的  const name = Ctor.options.name || tag  const vnode = new VNode(    `vue-component-$&#123;Ctor.cid&#125;$&#123;name ? `-$&#123;name&#125;` : &#x27;&#x27;&#125;`,    data, undefined, undefined, undefined, context,    &#123; Ctor, propsData, listeners, tag, children &#125;,    asyncFactory  )  if (__WEEX__ &amp;&amp; isRecyclableComponent(vnode)) &#123;    return renderRecyclableComponentTemplate(vnode)  &#125;  return vnode&#125;

稍微提下createComponent生成VNode的三个关键流程：

构造子类构造函数Ctor 
installComponentHooks安装组件钩子函数
实例化 vnode

小结createElement 创建 VNode 的过程，每个 VNode 有 children，children 每个元素也是一个VNode，这样就形成了一个虚拟树结构，用于描述真实的DOM树结构
参考文献
https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/create-element.html#children-%E7%9A%84%E8%A7%84%E8%8C%83%E5%8C%96
https://juejin.cn/post/6876711874050818061

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？</title>
    <url>/2024/06/24/vue-structure/</url>
    <content><![CDATA[
一、为什么要划分使用vue构建项目，项目结构清晰会提高开发效率，熟悉项目的各种配置同样会让开发效率更高
在划分项目结构的时候，需要遵循一些基本的原则：

文件夹和文件夹内部文件的语义一致性
单一入口&#x2F;出口
就近原则，紧耦合的文件应该放到一起，且应以相对路径引用
公共的文件应该以绝对路径的方式从根目录引用
/src 外的文件不应该被引入

文件夹和文件夹内部文件的语义一致性我们的目录结构都会有一个文件夹是按照路由模块来划分的，如pages文件夹，这个文件夹里面应该包含我们项目所有的路由模块，并且仅应该包含路由模块，而不应该有别的其他的非路由模块的文件夹
这样做的好处在于一眼就从 pages文件夹看出这个项目的路由有哪些
单一入口&#x2F;出口举个例子，在pages文件夹里面存在一个seller文件夹，这时候seller 文件夹应该作为一个独立的模块由外部引入，并且 seller/index.js 应该作为外部引入 seller 模块的唯一入口
// 错误用法import sellerReducer from &#x27;src/pages/seller/reducer&#x27;// 正确用法import &#123; reducer as sellerReducer &#125; from &#x27;src/pages/seller&#x27;

这样做的好处在于，无论你的模块文件夹内部有多乱，外部引用的时候，都是从一个入口文件引入，这样就很好的实现了隔离，如果后续有重构需求，你就会发现这种方式的优点
就近原则，紧耦合的文件应该放到一起，且应以相对路径引用使用相对路径可以保证模块内部的独立性
// 正确用法import styles from &#x27;./index.module.scss&#x27;// 错误用法import styles from &#x27;src/pages/seller/index.module.scss&#x27;

举个例子
假设我们现在的 seller 目录是在 src/pages/seller，如果我们后续发生了路由变更，需要加一个层级，变成 src/pages/user/seller。
如果我们采用第一种相对路径的方式，那就可以直接将整个文件夹拖过去就好，seller 文件夹内部不需要做任何变更。
但是如果我们采用第二种绝对路径的方式，移动文件夹的同时，还需要对每个 import 的路径做修改
公共的文件应该以绝对路径的方式从根目录引用公共指的是多个路由模块共用，如一些公共的组件，我们可以放在src/components下
在使用到的页面中，采用绝对路径的形式引用
// 错误用法import Input from &#x27;../../components/input&#x27;// 正确用法import Input from &#x27;src/components/input&#x27;

同样的，如果我们需要对文件夹结构进行调整。将 /src/components/input 变成 /src/components/new/input，如果使用绝对路径，只需要全局搜索替换
再加上绝对路径有全局的语义，相对路径有独立模块的语义
&#x2F;src 外的文件不应该被引入vue-cli脚手架已经帮我们做了相关的约束了，正常我们的前端项目都会有个src文件夹，里面放着所有的项目需要的资源，js, css, png, svg 等等。src 外会放一些项目配置，依赖，环境等文件
这样的好处是方便划分项目代码文件和配置文件
二、目录结构单页面目录结构
project│  .browserslistrc│  .env.production│  .eslintrc.js│  .gitignore│  babel.config.js│  package-lock.json│  package.json│  README.md│  vue.config.js│  yarn-error.log│  yarn.lock│├─public│      favicon.ico│      index.html│|-- src    |-- components        |-- input            |-- index.js            |-- index.module.scss    |-- pages        |-- seller            |-- components                |-- input                    |-- index.js                    |-- index.module.scss            |-- reducer.js            |-- saga.js            |-- index.js            |-- index.module.scss        |-- buyer            |-- index.js        |-- index.js

多页面目录结构
my-vue-test:.│  .browserslistrc│  .env.production│  .eslintrc.js│  .gitignore│  babel.config.js│  package-lock.json│  package.json│  README.md│  vue.config.js│  yarn-error.log│  yarn.lock│├─public│      favicon.ico│      index.html│└─src    ├─apis //接口文件根据页面或实例模块化    │      index.js    │      login.js    │    ├─components //全局公共组件    │  └─header    │          index.less    │          index.vue    │    ├─config //配置（环境变量配置不同passid等）    │      env.js    │      index.js    │    ├─contant //常量    │      index.js    │    ├─images //图片    │      logo.png    │    ├─pages //多页面vue项目，不同的实例    │  ├─index //主实例    │  │  │  index.js    │  │  │  index.vue    │  │  │  main.js    │  │  │  router.js    │  │  │  store.js    │  │  │    │  │  ├─components //业务组件    │  │  └─pages //此实例中的各个路由    │  │      ├─amenu    │  │      │      index.vue    │  │      │    │  │      └─bmenu    │  │              index.vue    │  │    │  └─login //另一个实例    │          index.js    │          index.vue    │          main.js    │    ├─scripts //包含各种常用配置，工具函数    │  │  map.js    │  │    │  └─utils    │          helper.js    │    ├─store //vuex仓库    │  │  index.js    │  │    │  ├─index    │  │      actions.js    │  │      getters.js    │  │      index.js    │  │      mutation-types.js    │  │      mutations.js    │  │      state.js    │  │    │  └─user    │          actions.js    │          getters.js    │          index.js    │          mutation-types.js    │          mutations.js    │          state.js    │    └─styles //样式统一配置        │  components.less        │        ├─animation        │      index.less        │      slide.less        │        ├─base        │      index.less        │      style.less        │      var.less        │      widget.less        │        └─common                index.less                reset.less                style.less                transition.less



小结项目的目录结构很重要，因为目录结构能体现很多东西，怎么规划目录结构可能每个人有自己的理解，但是按照一定的规范去进行目录的设计，能让项目整个架构看起来更为简洁，更加易用
参考文献
https://juejin.cn/post/6844904129186234381#heading-0

https://zhuanlan.zhihu.com/p/89693668


]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 组件之间的通信方式有哪些？</title>
    <url>/2024/06/12/vue-vue-components-communication/</url>
    <content><![CDATA[一、组件通信的概念组件通信是指组件与组件之间数据传递和交互的方式。在 Vue 中，组件之间的通信是非常重要的概念，因为一个应用往往由多个组件构成，它们之间需要相互配合才能完成特定的功能。
二、通信方式1. props &#x2F; $emit父组件通过 props 向子组件传递数据，子组件通过 $emit 向父组件发送事件
&lt;!-- 父组件 --&gt;&lt;template&gt;  &lt;child :msg=&quot;message&quot; @changeMsg=&quot;handleChange&quot;/&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      message: &#x27;Hello&#x27;    &#125;  &#125;,  methods: &#123;    handleChange(val) &#123;      this.message = val    &#125;  &#125;&#125;&lt;/script&gt;&lt;!-- 子组件 --&gt;&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;handleClick&quot;&gt;修改&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: [&#x27;msg&#x27;],  methods: &#123;    handleClick() &#123;      this.$emit(&#x27;changeMsg&#x27;, &#x27;World&#x27;)    &#125;  &#125;&#125;&lt;/script&gt;

2. $refs &#x2F; $parent &#x2F; $children通过 ref 获取子组件实例，直接调用子组件的方法或访问数据
&lt;!-- 父组件 --&gt;&lt;template&gt;  &lt;child ref=&quot;childComp&quot;/&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  mounted() &#123;    // 访问子组件的数据和方法    this.$refs.childComp.someMethod()  &#125;&#125;&lt;/script&gt;

3. EventBus通过一个空的 Vue 实例作为中央事件总线，实现任意组件间的通信
// eventBus.jsimport Vue from &#x27;vue&#x27;export const EventBus = new Vue()// 组件 AEventBus.$emit(&#x27;custom-event&#x27;, data)// 组件 BEventBus.$on(&#x27;custom-event&#x27;, data =&gt; &#123;  console.log(data)&#125;)

4. Vuex状态管理模式，集中式存储管理应用的所有组件的状态
// store.jsimport Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123;  state: &#123;    count: 0  &#125;,  mutations: &#123;    increment(state) &#123;      state.count++    &#125;  &#125;&#125;)// 组件中使用this.$store.state.countthis.$store.commit(&#x27;increment&#x27;)

三、各种通信方式的使用场景
props &#x2F; $emit

适用于父子组件通信
简单且清晰的数据流向


$refs &#x2F; $parent &#x2F; $children

适用于父子组件通信
需要直接操作子组件时使用


EventBus

适用于任意组件间通信
项目较小时使用
数据流混乱时不易维护


Vuex

适用于复杂的数据管理
大型项目推荐使用
需要共享的状态较多时



四、注意事项
避免过度使用全局事件总线
合理使用 Vuex，不是所有状态都需要放在 Vuex 中
优先考虑 props &#x2F; $emit 这种最简单的通信方式
组件通信遵循单向数据流原则

参考文献
Vue.js 官方文档 - 组件基础
Vuex 官方文档

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
        <tag>组件通信</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 生命周期的理解？</title>
    <url>/2024/06/10/vue-vue-lifecycle/</url>
    <content><![CDATA[一、什么是生命周期生命周期（Life Cycle）是指 Vue 组件从创建到销毁的整个过程，也就是组件的生命历程。
在这个过程中，Vue 提供了一系列的生命周期钩子函数，让我们能在特定的阶段执行自己的代码。
二、生命周期有哪些Vue 2.x 的生命周期钩子主要包含：
1. 创建阶段
beforeCreate：实例创建前，此时数据观测和事件配置都未初始化
created：实例创建后，此时已完成数据观测，但尚未挂载到 DOM

2. 挂载阶段
beforeMount：DOM 挂载前，此时模板已编译，但还未挂载到页面
mounted：DOM 挂载后，此时组件已经渲染到页面上

3. 更新阶段
beforeUpdate：数据更新时，DOM 更新之前调用
updated：数据更新后，DOM 更新完成后调用

4. 销毁阶段
beforeDestroy：实例销毁前调用
destroyed：实例销毁后调用

三、生命周期的应用场景
created

发送 ajax 请求
初始化数据
注册全局事件


mounted

操作 DOM
初始化第三方插件
获取 DOM 节点信息


beforeDestroy

清除定时器
解绑全局事件
销毁第三方插件



四、注意事项
created 和 mounted 的区别

created 在组件实例创建完成后调用，此时还未挂载到 DOM
mounted 在组件挂载到 DOM 后调用，可以操作 DOM


不要在生命周期函数中使用箭头函数

箭头函数绑定了父级作用域的上下文，this 将不会按照期望指向 Vue 实例


destroyed 钩子中，实例的所有指令都被解绑，所有事件监听器被移除，所有子实例也都被销毁


五、示例代码export default &#123;  beforeCreate() &#123;    console.log(&#x27;实例创建前&#x27;)  &#125;,  created() &#123;    console.log(&#x27;实例创建后&#x27;)    this.getData() // 发送请求获取数据  &#125;,  mounted() &#123;    console.log(&#x27;DOM 挂载后&#x27;)    this.initPlugin() // 初始化插件  &#125;,  beforeDestroy() &#123;    console.log(&#x27;实例销毁前&#x27;)    clearInterval(this.timer) // 清除定时器  &#125;&#125;

参考文献
Vue.js 官方文档 - 生命周期钩子
Vue.js 技术揭秘

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>有使用过vue吗？说说你对vue的理解</title>
    <url>/2024/05/10/vue-vue/</url>
    <content><![CDATA[
一、从历史说起Web是World Wide Web的简称，中文译为万维网我们可以将它规划成如下的几个时代来进行理解

石器时代
文明时代
工业革命时代
百花齐放时代

石器时代石器时代指的就是我们的静态网页，可以欣赏一下1997的Apple官网
 
最早的网页是没有数据库的，可以理解成就是一张可以在网络上浏览的报纸，直到CGI技术的出现通过 CGI Perl 运行一小段代码与数据库或文件系统进行交互，如当时的Google（1998年）
 
文明时代ASP，JSP大家应该都不会太陌生，最早出现于 2005 年左右，先后出现了微软的 ASP 和 Java Server Pages [JSP] 等技术,取代了 CGI ，增强了 WEB 与服务端的交互的安全性，类似于下面这样，其实就是Java + HTML
&#96;&lt;%@ page language&#x3D;”java” contentType&#x3D;”text&#x2F;html; charset&#x3D;utf-8”    pageEncoding&#x3D;”utf-8”%&gt;  
  
  
    
  JSP demo  
  
  
    
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>性能优化</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 项目的性能优化方案有哪些？</title>
    <url>/2024/05/10/vue-vue-performance/</url>
    <content><![CDATA[一、代码层面优化1. 数据层面1.1 合理使用 v-show 和 v-if// 频繁切换用 v-show&lt;template&gt;  &lt;div v-show=&quot;isShow&quot;&gt;频繁切换的内容&lt;/div&gt;&lt;/template&gt;// 条件渲染用 v-if&lt;template&gt;  &lt;div v-if=&quot;isAdmin&quot;&gt;管理员菜单&lt;/div&gt;&lt;/template&gt;

1.2 使用 computed 代替 methodsexport default &#123;  // 不推荐  methods: &#123;    getFullName() &#123;      return this.firstName + &#x27; &#x27; + this.lastName;    &#125;  &#125;,    // 推荐  computed: &#123;    fullName() &#123;      return this.firstName + &#x27; &#x27; + this.lastName;    &#125;  &#125;&#125;

1.3 避免重复数据export default &#123;  data() &#123;    return &#123;      // 不推荐      list: [],      filterList: [], // 通过 list 过滤得到            // 推荐：使用计算属性      list: []    &#125;  &#125;,  computed: &#123;    filterList() &#123;      return this.list.filter(item =&gt; item.visible);    &#125;  &#125;&#125;

2. 组件优化2.1 路由懒加载// router/index.jsconst routes = [  &#123;    path: &#x27;/user&#x27;,    name: &#x27;user&#x27;,    // 使用动态导入    component: () =&gt; import(&#x27;@/views/user/index.vue&#x27;)  &#125;]

2.2 组件按需加载// 不推荐import &#123; Button, Select, Table &#125; from &#x27;element-plus&#x27;// 推荐import Button from &#x27;element-plus/lib/button&#x27;import Select from &#x27;element-plus/lib/select&#x27;

2.3 keep-alive 缓存组件&lt;template&gt;  &lt;keep-alive :include=&quot;[&#x27;UserList&#x27;, &#x27;UserInfo&#x27;]&quot;&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/keep-alive&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;App&#x27;,  data() &#123;    return &#123;      // 需要缓存的组件名      cacheComponents: [&#x27;UserList&#x27;, &#x27;UserInfo&#x27;]    &#125;  &#125;&#125;&lt;/script&gt;

3. 渲染优化3.1 使用 v-once 处理静态内容&lt;template&gt;  &lt;!-- 静态内容只渲染一次 --&gt;  &lt;div v-once&gt;    &lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt;    &lt;p&gt;&#123;&#123; description &#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;

3.2 使用 v-memo 缓存模板&lt;template&gt;  &lt;div v-memo=&quot;[item.id, item.updated]&quot;&gt;    &lt;h3&gt;&#123;&#123; item.title &#125;&#125;&lt;/h3&gt;    &lt;p&gt;&#123;&#123; item.content &#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;

3.3 长列表优化&lt;template&gt;  &lt;recycle-scroller    class=&quot;scroller&quot;    :items=&quot;items&quot;    :item-size=&quot;32&quot;  &gt;    &lt;template #default=&quot;&#123; item &#125;&quot;&gt;      &lt;div class=&quot;user-item&quot;&gt;        &#123;&#123; item.name &#125;&#125;      &lt;/div&gt;    &lt;/template&gt;  &lt;/recycle-scroller&gt;&lt;/template&gt;&lt;script&gt;import &#123; RecycleScroller &#125; from &#x27;vue-virtual-scroller&#x27;import &#x27;vue-virtual-scroller/dist/vue-virtual-scroller.css&#x27;export default &#123;  components: &#123;    RecycleScroller  &#125;,  data() &#123;    return &#123;      items: Array.from(&#123; length: 10000 &#125;).map((_, i) =&gt; (&#123;        id: i,        name: `User $&#123;i&#125;`      &#125;))    &#125;  &#125;&#125;&lt;/script&gt;

二、打包优化1. 代码分割// vue.config.jsmodule.exports = &#123;  configureWebpack: &#123;    optimization: &#123;      splitChunks: &#123;        chunks: &#x27;all&#x27;,        cacheGroups: &#123;          vendor: &#123;            name: &#x27;chunk-vendors&#x27;,            test: /[\\/]node_modules[\\/]/,            priority: -10,            chunks: &#x27;initial&#x27;          &#125;,          common: &#123;            name: &#x27;chunk-common&#x27;,            minChunks: 2,            priority: -20,            chunks: &#x27;initial&#x27;,            reuseExistingChunk: true          &#125;        &#125;      &#125;    &#125;  &#125;&#125;

2. 压缩资源// vue.config.jsconst CompressionPlugin = require(&#x27;compression-webpack-plugin&#x27;)module.exports = &#123;  configureWebpack: &#123;    plugins: [      new CompressionPlugin(&#123;        test: /\.(js|css|html)$/,        threshold: 10240, // 10KB        deleteOriginalAssets: false      &#125;)    ]  &#125;&#125;

3. CDN 优化// vue.config.jsmodule.exports = &#123;  chainWebpack: config =&gt; &#123;    config.externals(&#123;      &#x27;vue&#x27;: &#x27;Vue&#x27;,      &#x27;vue-router&#x27;: &#x27;VueRouter&#x27;,      &#x27;vuex&#x27;: &#x27;Vuex&#x27;,      &#x27;axios&#x27;: &#x27;axios&#x27;    &#125;)  &#125;&#125;// public/index.html&lt;head&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@3.2.31&quot;&gt;&lt;/script&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue-router@4.0.14&quot;&gt;&lt;/script&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vuex@4.0.2&quot;&gt;&lt;/script&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios@0.26.1&quot;&gt;&lt;/script&gt;&lt;/head&gt;

三、运行时优化1. 事件处理&lt;template&gt;  &lt;!-- 不推荐 --&gt;  &lt;div @scroll=&quot;handleScroll&quot;&gt;    &lt;!-- 内容 --&gt;  &lt;/div&gt;    &lt;!-- 推荐：使用节流 --&gt;  &lt;div @scroll=&quot;throttleScroll&quot;&gt;    &lt;!-- 内容 --&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; throttle &#125; from &#x27;lodash-es&#x27;export default &#123;  created() &#123;    this.throttleScroll = throttle(this.handleScroll, 200)  &#125;,  methods: &#123;    handleScroll(e) &#123;      // 处理滚动事件    &#125;  &#125;,  beforeDestroy() &#123;    // 清除节流函数    this.throttleScroll.cancel()  &#125;&#125;&lt;/script&gt;

2. 大数据渲染&lt;template&gt;  &lt;div class=&quot;list&quot;&gt;    &lt;div v-for=&quot;chunk in chunks&quot; :key=&quot;chunk[0].id&quot;&gt;      &lt;div v-for=&quot;item in chunk&quot; :key=&quot;item.id&quot;&gt;        &#123;&#123; item.name &#125;&#125;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      list: [],      chunkSize: 100    &#125;  &#125;,  computed: &#123;    chunks() &#123;      const chunks = []      for (let i = 0; i &lt; this.list.length; i += this.chunkSize) &#123;        chunks.push(this.list.slice(i, i + this.chunkSize))      &#125;      return chunks    &#125;  &#125;,  methods: &#123;    async loadData() &#123;      const data = await fetchLargeData()      // 使用 nextTick 分批渲染      this.$nextTick(() =&gt; &#123;        this.list = data      &#125;)    &#125;  &#125;&#125;&lt;/script&gt;

3. 内存优化export default &#123;  data() &#123;    return &#123;      timer: null,      observers: &#123;        scroll: null,        intersection: null,        resize: null,        mutation: null      &#125;,      domRefs: &#123;        listContainer: null,        lazyImages: []      &#125;    &#125;  &#125;,  mounted() &#123;    // 1. 初始化 DOM 引用    this.domRefs.listContainer = this.$refs.listContainer    this.domRefs.lazyImages = this.$refs.lazyImages    // 2. 创建交叉观察者 - 用于图片懒加载    this.observers.intersection = new IntersectionObserver(      (entries) =&gt; &#123;        entries.forEach(entry =&gt; &#123;          if (entry.isIntersecting) &#123;            const img = entry.target            img.src = img.dataset.src            // 图片加载后取消观察            this.observers.intersection.unobserve(img)          &#125;        &#125;)      &#125;,      &#123;        root: this.domRefs.listContainer,        rootMargin: &#x27;50px&#x27;,        threshold: 0.1      &#125;    )    // 3. 创建滚动观察者 - 用于无限滚动    this.observers.scroll = new IntersectionObserver(      (entries) =&gt; &#123;        const trigger = entries[0]        if (trigger.isIntersecting) &#123;          this.loadMoreData()        &#125;      &#125;,      &#123;        root: null,        rootMargin: &#x27;100px&#x27;,        threshold: 0      &#125;    )    // 4. 创建 ResizeObserver - 用于响应容器大小变化    this.observers.resize = new ResizeObserver(      this.throttle((entries) =&gt; &#123;        const containerSize = entries[0].contentRect        this.handleContainerResize(containerSize)      &#125;, 200)    )    // 5. 创建 MutationObserver - 监听 DOM 变化    this.observers.mutation = new MutationObserver(      this.debounce((mutations) =&gt; &#123;        this.handleDomChanges(mutations)      &#125;, 200)    )    // 启动观察    this.startObserving()  &#125;,  methods: &#123;    // 开始所有观察    startObserving() &#123;      // 1. 观察懒加载图片      this.domRefs.lazyImages.forEach(img =&gt; &#123;        this.observers.intersection.observe(img)      &#125;)      // 2. 观察滚动触发器      const trigger = this.$refs.scrollTrigger      if (trigger) &#123;        this.observers.scroll.observe(trigger)      &#125;      // 3. 观察容器大小      if (this.domRefs.listContainer) &#123;        this.observers.resize.observe(this.domRefs.listContainer)      &#125;      // 4. 观察 DOM 变化      this.observers.mutation.observe(this.domRefs.listContainer, &#123;        childList: true,        subtree: true,        attributes: true,        characterData: true      &#125;)    &#125;,    // 处理容器大小变化    handleContainerResize(size) &#123;      // 根据新的容器大小调整布局      this.updateLayout(size)    &#125;,    // 处理 DOM 变化    handleDomChanges(mutations) &#123;      // 处理 DOM 变化，例如更新虚拟滚动的计算      this.updateVirtualScroll()    &#125;,    // 加载更多数据    async loadMoreData() &#123;      try &#123;        const newData = await this.fetchData()        this.list.push(...newData)      &#125; catch (error) &#123;        console.error(&#x27;Failed to load more data:&#x27;, error)      &#125;    &#125;,    // 节流函数    throttle(fn, delay) &#123;      let timer = null      return function(...args) &#123;        if (timer) return        timer = setTimeout(() =&gt; &#123;          fn.apply(this, args)          timer = null        &#125;, delay)      &#125;    &#125;,    // 防抖函数    debounce(fn, delay) &#123;      let timer = null      return function(...args) &#123;        if (timer) clearTimeout(timer)        timer = setTimeout(() =&gt; &#123;          fn.apply(this, args)        &#125;, delay)      &#125;    &#125;  &#125;,  beforeDestroy() &#123;    // 清除定时器    if (this.timer) &#123;      clearInterval(this.timer)      this.timer = null    &#125;        // 断开所有观察者    Object.values(this.observers).forEach(observer =&gt; &#123;      if (observer) &#123;        observer.disconnect()        observer = null      &#125;    &#125;)  &#125;&#125;

四、实践建议1. 开发阶段
使用开发者工具的 Performance 面板分析性能
使用 Vue DevTools 检查组件渲染情况
编写高质量的代码，遵循最佳实践

2. 构建阶段
合理配置 webpack 优化项
分析并优化打包体积
使用动态导入和按需加载

3. 部署阶段
使用 CDN 加速资源加载
开启 Gzip 压缩
配置合理的缓存策略

参考文献
Vue.js 性能优化指南
Vue CLI 配置指南
webpack 优化指南
浏览器性能优化

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>性能优化</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex的实现原理解析</title>
    <url>/2024/03/21/vue-vuex-principle/</url>
    <content><![CDATA[Vuex的实现原理解析1. Vuex 是什么？Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。
2. 核心概念Vuex 的核心由以下几个部分组成：

State：状态数据
Getter：计算属性
Mutation：同步修改状态
Action：异步操作
Module：模块化管理

3. 实现原理3.1 插件安装机制let Vue // 用于存储Vue构造函数export function install(_Vue) &#123;  // 防止重复安装  if (Vue &amp;&amp; _Vue === Vue) &#123;    return  &#125;  Vue = _Vue    // 全局混入，将 store 注入到所有组件  Vue.mixin(&#123;    beforeCreate() &#123;      const options = this.$options      if (options.store) &#123;        // 根组件        this.$store = options.store      &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123;        // 子组件从父组件继承        this.$store = options.parent.$store      &#125;    &#125;  &#125;)&#125;

3.2 Store 类的实现class Store &#123;  constructor(options = &#123;&#125;) &#123;    // 初始化 state    this._state = new Vue(&#123;      data: &#123;        state: options.state      &#125;    &#125;)        // 初始化 getters    this.getters = &#123;&#125;    const store = this    const computed = &#123;&#125;        Object.keys(options.getters || &#123;&#125;).forEach(key =&gt; &#123;      const fn = options.getters[key]      // 转换为 computed 属性      computed[key] = function() &#123;        return fn(store.state)      &#125;      // 为 getters 定义只读属性      Object.defineProperty(store.getters, key, &#123;        get: () =&gt; store._vm[key]      &#125;)    &#125;)        // 创建响应式的 computed    this._vm = new Vue(&#123;      computed    &#125;)        // 初始化 mutations    this._mutations = options.mutations || &#123;&#125;        // 初始化 actions    this._actions = options.actions || &#123;&#125;        // 绑定 commit 和 dispatch 的 this    const &#123; commit, dispatch &#125; = this    this.commit = function boundCommit(type, payload) &#123;      return commit.call(store, type, payload)    &#125;    this.dispatch = function boundDispatch(type, payload) &#123;      return dispatch.call(store, type, payload)    &#125;  &#125;    // 获取 state  get state() &#123;    return this._state.state  &#125;    // 提交 mutation  commit(type, payload) &#123;    const mutation = this._mutations[type]    if (!mutation) &#123;      console.error(`[vuex] unknown mutation type: $&#123;type&#125;`)      return    &#125;    mutation.call(this, this.state, payload)  &#125;    // 分发 action  dispatch(type, payload) &#123;    const action = this._actions[type]    if (!action) &#123;      console.error(`[vuex] unknown action type: $&#123;type&#125;`)      return    &#125;    return action.call(this, &#123;      state: this.state,      commit: this.commit,      dispatch: this.dispatch    &#125;, payload)  &#125;&#125;

3.3 响应式原理Vuex 的响应式是基于 Vue 的响应式系统实现的：

State 的响应式：
this._state = new Vue(&#123;  data: &#123;    state: options.state  &#125;&#125;)

Getter 的响应式：
this._vm = new Vue(&#123;  computed: &#123;    // 将 getter 转换为 computed 属性  &#125;&#125;)

4. 模块化实现4.1 Module 收集class ModuleCollection &#123;  constructor(rawRootModule) &#123;    this.register([], rawRootModule)  &#125;    register(path, rawModule) &#123;    const newModule = &#123;      _raw: rawModule,      _children: &#123;&#125;,      state: rawModule.state    &#125;        if (path.length === 0) &#123;      this.root = newModule    &#125; else &#123;      const parent = this.get(path.slice(0, -1))      parent._children[path[path.length - 1]] = newModule    &#125;        if (rawModule.modules) &#123;      Object.keys(rawModule.modules).forEach(key =&gt; &#123;        this.register(          path.concat(key),          rawModule.modules[key]        )      &#125;)    &#125;  &#125;&#125;

4.2 命名空间处理function installModule(store, rootState, path, module) &#123;  const namespace = store._modules.getNamespace(path)    // 注册 state  if (path.length &gt; 0) &#123;    const parentState = getNestedState(rootState, path.slice(0, -1))    Vue.set(parentState, path[path.length - 1], module.state)  &#125;    // 注册 mutations  module._raw.mutations &amp;&amp; Object.keys(module._raw.mutations).forEach(key =&gt; &#123;    const namespacedType = namespace + key    registerMutation(store, namespacedType, module._raw.mutations[key], path)  &#125;)    // 注册 actions  module._raw.actions &amp;&amp; Object.keys(module._raw.actions).forEach(key =&gt; &#123;    const namespacedType = namespace + key    registerAction(store, namespacedType, module._raw.actions[key], path)  &#125;)&#125;

5. 工作流程
初始化流程：

安装 Vuex 插件
创建 Store 实例
初始化模块
设置响应式状态


更新流程：

组件通过 dispatch 触发 action
action 执行异步操作
通过 commit 触发 mutation
mutation 修改 state
响应式系统通知组件更新



6. 总结Vuex 的核心实现原理包括：

利用 Vue 的插件机制和混入功能
基于 Vue 的响应式系统
模块化的状态管理
单向数据流的实现

理解 Vuex 的实现原理有助于我们更好地使用它，并在遇到问题时能够快速定位和解决。 
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>原理解析</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>你了解axios的原理吗？有看过它的源码吗？</title>
    <url>/2025/02/03/vue-axiosCode/</url>
    <content><![CDATA[
一、axios的使用关于axios的基本使用，上篇文章已经有所涉及，这里再稍微回顾下：
发送请求
import axios from &#x27;axios&#x27;;axios(config) // 直接传入配置axios(url[, config]) // 传入url和配置axios[method](url[, option]) // 直接调用请求方式方法，传入url和配置axios[method](url[, data[, option]]) // 直接调用请求方式方法，传入data、url和配置axios.request(option) // 调用 request 方法const axiosInstance = axios.create(config)// axiosInstance 也具有以上 axios 的能力axios.all([axiosInstance1, axiosInstance2]).then(axios.spread(response1, response2))// 调用 all 和传入 spread 回调



请求拦截器
axios.interceptors.request.use(function (config) &#123;    // 这里写发送请求前处理的代码    return config;&#125;, function (error) &#123;    // 这里写发送请求错误相关的代码    return Promise.reject(error);&#125;);



响应拦截器
axios.interceptors.response.use(function (response) &#123;    // 这里写得到响应数据后处理的代码    return response;&#125;, function (error) &#123;    // 这里写得到错误响应处理的代码    return Promise.reject(error);&#125;);



取消请求
// 方式一const CancelToken = axios.CancelToken;const source = CancelToken.source();axios.get(&#x27;xxxx&#x27;, &#123;  cancelToken: source.token&#125;)// 取消请求 (请求原因是可选的)source.cancel(&#x27;主动取消请求&#x27;);// 方式二const CancelToken = axios.CancelToken;let cancel;axios.get(&#x27;xxxx&#x27;, &#123;  cancelToken: new CancelToken(function executor(c) &#123;    cancel = c;  &#125;)&#125;);cancel(&#x27;主动取消请求&#x27;);





二、实现一个简易版axios构建一个Axios构造函数，核心代码为request
class Axios &#123;    constructor() &#123;    &#125;    request(config) &#123;        return new Promise(resolve =&gt; &#123;            const &#123;url = &#x27;&#x27;, method = &#x27;get&#x27;, data = &#123;&#125;&#125; = config;            // 发送ajax请求            const xhr = new XMLHttpRequest();            xhr.open(method, url, true);            xhr.onload = function() &#123;                console.log(xhr.responseText)                resolve(xhr.responseText);            &#125;            xhr.send(data);        &#125;)    &#125;&#125;

导出axios实例
// 最终导出axios的方法，即实例的request方法function CreateAxiosFn() &#123;    let axios = new Axios();    let req = axios.request.bind(axios);    return req;&#125;// 得到最后的全局变量axioslet axios = CreateAxiosFn();

上述就已经能够实现axios(&#123; &#125;)这种方式的请求
下面是来实现下axios.method()这种形式的请求
// 定义get,post...方法，挂在到Axios原型上const methodsArr = [&#x27;get&#x27;, &#x27;delete&#x27;, &#x27;head&#x27;, &#x27;options&#x27;, &#x27;put&#x27;, &#x27;patch&#x27;, &#x27;post&#x27;];methodsArr.forEach(met =&gt; &#123;    Axios.prototype[met] = function() &#123;        console.log(&#x27;执行&#x27;+met+&#x27;方法&#x27;);        // 处理单个方法        if ([&#x27;get&#x27;, &#x27;delete&#x27;, &#x27;head&#x27;, &#x27;options&#x27;].includes(met)) &#123; // 2个参数(url[, config])            return this.request(&#123;                method: met,                url: arguments[0],                ...arguments[1] || &#123;&#125;            &#125;)        &#125; else &#123; // 3个参数(url[,data[,config]])            return this.request(&#123;                method: met,                url: arguments[0],                data: arguments[1] || &#123;&#125;,                ...arguments[2] || &#123;&#125;            &#125;)        &#125;    &#125;&#125;)

将Axios.prototype上的方法搬运到request上
首先实现个工具类，实现将b方法混入到a，并且修改this指向
const utils = &#123;  extend(a,b, context) &#123;    for(let key in b) &#123;      if (b.hasOwnProperty(key)) &#123;        if (typeof b[key] === &#x27;function&#x27;) &#123;          a[key] = b[key].bind(context);        &#125; else &#123;          a[key] = b[key]        &#125;      &#125;          &#125;  &#125;&#125;

修改导出的方法
function CreateAxiosFn() &#123;  let axios = new Axios();    let req = axios.request.bind(axios);  // 增加代码  utils.extend(req, Axios.prototype, axios)    return req;&#125;



构建拦截器的构造函数
class InterceptorsManage &#123;  constructor() &#123;    this.handlers = [];  &#125;  use(fullfield, rejected) &#123;    this.handlers.push(&#123;      fullfield,      rejected    &#125;)  &#125;&#125;

实现axios.interceptors.response.use和axios.interceptors.request.use
class Axios &#123;    constructor() &#123;        // 新增代码        this.interceptors = &#123;            request: new InterceptorsManage,            response: new InterceptorsManage        &#125;    &#125;    request(config) &#123; 		...    &#125;&#125;

执行语句axios.interceptors.response.use和axios.interceptors.request.use的时候，实现获取axios实例上的interceptors对象，然后再获取response或request拦截器，再执行对应的拦截器的use方法
把Axios上的方法和属性搬到request过去
function CreateAxiosFn() &#123;  let axios = new Axios();    let req = axios.request.bind(axios);  // 混入方法， 处理axios的request方法，使之拥有get,post...方法  utils.extend(req, Axios.prototype, axios)  // 新增代码  utils.extend(req, axios)  return req;&#125;

现在request也有了interceptors对象，在发送请求的时候，会先获取request拦截器的handlers的方法来执行
首先将执行ajax的请求封装成一个方法
request(config) &#123;    this.sendAjax(config)&#125;sendAjax(config)&#123;    return new Promise(resolve =&gt; &#123;        const &#123;url = &#x27;&#x27;, method = &#x27;get&#x27;, data = &#123;&#125;&#125; = config;        // 发送ajax请求        console.log(config);        const xhr = new XMLHttpRequest();        xhr.open(method, url, true);        xhr.onload = function() &#123;            console.log(xhr.responseText)            resolve(xhr.responseText);        &#125;;        xhr.send(data);    &#125;)&#125;

获得handlers中的回调
request(config) &#123;    // 拦截器和请求组装队列    let chain = [this.sendAjax.bind(this), undefined] // 成对出现的，失败回调暂时不处理    // 请求拦截    this.interceptors.request.handlers.forEach(interceptor =&gt; &#123;        chain.unshift(interceptor.fullfield, interceptor.rejected)    &#125;)    // 响应拦截    this.interceptors.response.handlers.forEach(interceptor =&gt; &#123;        chain.push(interceptor.fullfield, interceptor.rejected)    &#125;)    // 执行队列，每次执行一对，并给promise赋最新的值    let promise = Promise.resolve(config);    while(chain.length &gt; 0) &#123;        promise = promise.then(chain.shift(), chain.shift())    &#125;    return promise;&#125;

chains大概是[&#39;fulfilled1&#39;,&#39;reject1&#39;,&#39;fulfilled2&#39;,&#39;reject2&#39;,&#39;this.sendAjax&#39;,&#39;undefined&#39;,&#39;fulfilled2&#39;,&#39;reject2&#39;,&#39;fulfilled1&#39;,&#39;reject1&#39;]这种形式
这样就能够成功实现一个简易版axios
三、源码分析首先看看目录结构
 
axios发送请求有很多实现的方法，实现入口文件为axios.js 
function createInstance(defaultConfig) &#123;  var context = new Axios(defaultConfig);  // instance指向了request方法，且上下文指向context，所以可以直接以 instance(option) 方式调用   // Axios.prototype.request 内对第一个参数的数据类型判断，使我们能够以 instance(url, option) 方式调用  var instance = bind(Axios.prototype.request, context);  // 把Axios.prototype上的方法扩展到instance对象上，  // 并指定上下文为context，这样执行Axios原型链上的方法时，this会指向context  utils.extend(instance, Axios.prototype, context);  // Copy context to instance  // 把context对象上的自身属性和方法扩展到instance上  // 注：因为extend内部使用的forEach方法对对象做for in 遍历时，只遍历对象本身的属性，而不会遍历原型链上的属性  // 这样，instance 就有了  defaults、interceptors 属性。  utils.extend(instance, context);  return instance;&#125;// Create the default instance to be exported 创建一个由默认配置生成的axios实例var axios = createInstance(defaults);// Factory for creating new instances 扩展axios.create工厂函数，内部也是 createInstanceaxios.create = function create(instanceConfig) &#123;  return createInstance(mergeConfig(axios.defaults, instanceConfig));&#125;;// Expose all/spreadaxios.all = function all(promises) &#123;  return Promise.all(promises);&#125;;axios.spread = function spread(callback) &#123;  return function wrap(arr) &#123;    return callback.apply(null, arr);  &#125;;&#125;;module.exports = axios;

主要核心是 Axios.prototype.request，各种请求方式的调用实现都是在 request 内部实现的， 简单看下 request 的逻辑
Axios.prototype.request = function request(config) &#123;  // Allow for axios(&#x27;example/url&#x27;[, config]) a la fetch API  // 判断 config 参数是否是 字符串，如果是则认为第一个参数是 URL，第二个参数是真正的config  if (typeof config === &#x27;string&#x27;) &#123;    config = arguments[1] || &#123;&#125;;    // 把 url 放置到 config 对象中，便于之后的 mergeConfig    config.url = arguments[0];  &#125; else &#123;    // 如果 config 参数是否是 字符串，则整体都当做config    config = config || &#123;&#125;;  &#125;  // 合并默认配置和传入的配置  config = mergeConfig(this.defaults, config);  // 设置请求方法  config.method = config.method ? config.method.toLowerCase() : &#x27;get&#x27;;  /*    something... 此部分会在后续拦截器单独讲述  */&#125;;// 在 Axios 原型上挂载 &#x27;delete&#x27;, &#x27;get&#x27;, &#x27;head&#x27;, &#x27;options&#x27; 且不传参的请求方法，实现内部也是 requestutils.forEach([&#x27;delete&#x27;, &#x27;get&#x27;, &#x27;head&#x27;, &#x27;options&#x27;], function forEachMethodNoData(method) &#123;  Axios.prototype[method] = function(url, config) &#123;    return this.request(utils.merge(config || &#123;&#125;, &#123;      method: method,      url: url    &#125;));  &#125;;&#125;);// 在 Axios 原型上挂载 &#x27;post&#x27;, &#x27;put&#x27;, &#x27;patch&#x27; 且传参的请求方法，实现内部同样也是 requestutils.forEach([&#x27;post&#x27;, &#x27;put&#x27;, &#x27;patch&#x27;], function forEachMethodWithData(method) &#123;  Axios.prototype[method] = function(url, data, config) &#123;    return this.request(utils.merge(config || &#123;&#125;, &#123;      method: method,      url: url,      data: data    &#125;));  &#125;;&#125;);

request入口参数为config，可以说config贯彻了axios的一生
axios 中的 config 主要分布在这几个地方：

默认配置 defaults.js
config.method默认为 get
调用 createInstance 方法创建 axios 实例，传入的config
直接或间接调用 request 方法，传入的 config

// axios.js// 创建一个由默认配置生成的axios实例var axios = createInstance(defaults);// 扩展axios.create工厂函数，内部也是 createInstanceaxios.create = function create(instanceConfig) &#123;  return createInstance(mergeConfig(axios.defaults, instanceConfig));&#125;;// Axios.js// 合并默认配置和传入的配置config = mergeConfig(this.defaults, config);// 设置请求方法config.method = config.method ? config.method.toLowerCase() : &#x27;get&#x27;;

从源码中，可以看到优先级：默认配置对象default &lt; method:get &lt; Axios的实例属性this.default &lt; request参数
下面重点看看request方法
Axios.prototype.request = function request(config) &#123;  /*    先是 mergeConfig ... 等，不再阐述  */  // Hook up interceptors middleware 创建拦截器链. dispatchRequest 是重中之重，后续重点  var chain = [dispatchRequest, undefined];  // push各个拦截器方法 注意：interceptor.fulfilled 或 interceptor.rejected 是可能为undefined  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) &#123;    // 请求拦截器逆序 注意此处的 forEach 是自定义的拦截器的forEach方法    chain.unshift(interceptor.fulfilled, interceptor.rejected);  &#125;);  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) &#123;    // 响应拦截器顺序 注意此处的 forEach 是自定义的拦截器的forEach方法    chain.push(interceptor.fulfilled, interceptor.rejected);  &#125;);  // 初始化一个promise对象，状态为resolved，接收到的参数为已经处理合并过的config对象  var promise = Promise.resolve(config);  // 循环拦截器的链  while (chain.length) &#123;    promise = promise.then(chain.shift(), chain.shift()); // 每一次向外弹出拦截器  &#125;  // 返回 promise  return promise;&#125;;

拦截器interceptors是在构建axios实例化的属性
function Axios(instanceConfig) &#123;  this.defaults = instanceConfig;  this.interceptors = &#123;    request: new InterceptorManager(), // 请求拦截    response: new InterceptorManager() // 响应拦截  &#125;;&#125;

InterceptorManager构造函数
// 拦截器的初始化 其实就是一组钩子函数function InterceptorManager() &#123;  this.handlers = [];&#125;// 调用拦截器实例的use时就是往钩子函数中push方法InterceptorManager.prototype.use = function use(fulfilled, rejected) &#123;  this.handlers.push(&#123;    fulfilled: fulfilled,    rejected: rejected  &#125;);  return this.handlers.length - 1;&#125;;// 拦截器是可以取消的，根据use的时候返回的ID，把某一个拦截器方法置为null// 不能用 splice 或者 slice 的原因是 删除之后 id 就会变化，导致之后的顺序或者是操作不可控InterceptorManager.prototype.eject = function eject(id) &#123;  if (this.handlers[id]) &#123;    this.handlers[id] = null;  &#125;&#125;;// 这就是在 Axios的request方法中 中循环拦截器的方法 forEach 循环执行钩子函数InterceptorManager.prototype.forEach = function forEach(fn) &#123;  utils.forEach(this.handlers, function forEachHandler(h) &#123;    if (h !== null) &#123;      fn(h);    &#125;  &#125;);&#125;

请求拦截器方法是被 unshift到拦截器中，响应拦截器是被push到拦截器中的。最终它们会拼接上一个叫dispatchRequest的方法被后续的 promise 顺序执行
var utils = require(&#x27;./../utils&#x27;);var transformData = require(&#x27;./transformData&#x27;);var isCancel = require(&#x27;../cancel/isCancel&#x27;);var defaults = require(&#x27;../defaults&#x27;);var isAbsoluteURL = require(&#x27;./../helpers/isAbsoluteURL&#x27;);var combineURLs = require(&#x27;./../helpers/combineURLs&#x27;);// 判断请求是否已被取消，如果已经被取消，抛出已取消function throwIfCancellationRequested(config) &#123;  if (config.cancelToken) &#123;    config.cancelToken.throwIfRequested();  &#125;&#125;module.exports = function dispatchRequest(config) &#123;  throwIfCancellationRequested(config);  // 如果包含baseUrl, 并且不是config.url绝对路径，组合baseUrl以及config.url  if (config.baseURL &amp;&amp; !isAbsoluteURL(config.url)) &#123;    // 组合baseURL与url形成完整的请求路径    config.url = combineURLs(config.baseURL, config.url);  &#125;  config.headers = config.headers || &#123;&#125;;  // 使用/lib/defaults.js中的transformRequest方法，对config.headers和config.data进行格式化  // 比如将headers中的Accept，Content-Type统一处理成大写  // 比如如果请求正文是一个Object会格式化为JSON字符串，并添加application/json;charset=utf-8的Content-Type  // 等一系列操作  config.data = transformData(    config.data,    config.headers,    config.transformRequest  );  // 合并不同配置的headers，config.headers的配置优先级更高  config.headers = utils.merge(    config.headers.common || &#123;&#125;,    config.headers[config.method] || &#123;&#125;,    config.headers || &#123;&#125;  );  // 删除headers中的method属性  utils.forEach(    [&#x27;delete&#x27;, &#x27;get&#x27;, &#x27;head&#x27;, &#x27;post&#x27;, &#x27;put&#x27;, &#x27;patch&#x27;, &#x27;common&#x27;],    function cleanHeaderConfig(method) &#123;      delete config.headers[method];    &#125;  );  // 如果config配置了adapter，使用config中配置adapter的替代默认的请求方法  var adapter = config.adapter || defaults.adapter;  // 使用adapter方法发起请求（adapter根据浏览器环境或者Node环境会有不同）  return adapter(config).then(    // 请求正确返回的回调    function onAdapterResolution(response) &#123;      // 判断是否以及取消了请求，如果取消了请求抛出以取消      throwIfCancellationRequested(config);      // 使用/lib/defaults.js中的transformResponse方法，对服务器返回的数据进行格式化      // 例如，使用JSON.parse对响应正文进行解析      response.data = transformData(        response.data,        response.headers,        config.transformResponse      );      return response;    &#125;,    // 请求失败的回调    function onAdapterRejection(reason) &#123;      if (!isCancel(reason)) &#123;        throwIfCancellationRequested(config);        if (reason &amp;&amp; reason.response) &#123;          reason.response.data = transformData(            reason.response.data,            reason.response.headers,            config.transformResponse          );        &#125;      &#125;      return Promise.reject(reason);    &#125;  );&#125;;

再来看看axios是如何实现取消请求的，实现文件在CancelToken.js
function CancelToken(executor) &#123;  if (typeof executor !== &#x27;function&#x27;) &#123;    throw new TypeError(&#x27;executor must be a function.&#x27;);  &#125;  // 在 CancelToken 上定义一个 pending 状态的 promise ，将 resolve 回调赋值给外部变量 resolvePromise  var resolvePromise;  this.promise = new Promise(function promiseExecutor(resolve) &#123;    resolvePromise = resolve;  &#125;);  var token = this;  // 立即执行 传入的 executor函数，将真实的 cancel 方法通过参数传递出去。  // 一旦调用就执行 resolvePromise 即前面的 promise 的 resolve，就更改promise的状态为 resolve。  // 那么xhr中定义的 CancelToken.promise.then方法就会执行, 从而xhr内部会取消请求  executor(function cancel(message) &#123;    // 判断请求是否已经取消过，避免多次执行    if (token.reason) &#123;      return;    &#125;    token.reason = new Cancel(message);    resolvePromise(token.reason);  &#125;);&#125;CancelToken.source = function source() &#123;  // source 方法就是返回了一个 CancelToken 实例，与直接使用 new CancelToken 是一样的操作  var cancel;  var token = new CancelToken(function executor(c) &#123;    cancel = c;  &#125;);  // 返回创建的 CancelToken 实例以及取消方法  return &#123;    token: token,    cancel: cancel  &#125;;&#125;;

实际上取消请求的操作是在 xhr.js 中也有响应的配合的
if (config.cancelToken) &#123;    config.cancelToken.promise.then(function onCanceled(cancel) &#123;        if (!request) &#123;            return;        &#125;        // 取消请求        request.abort();        reject(cancel);    &#125;);&#125;

巧妙的地方在 CancelToken中 executor 函数，通过resolve函数的传递与执行，控制promise的状态
小结 
参考文献
https://juejin.cn/post/6856706569263677447#heading-4
https://juejin.cn/post/6844903907500490766
https://github.com/axios/axios

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>你了解vue的diff算法吗？说说看</title>
    <url>/2024/11/17/vue-diff/</url>
    <content><![CDATA[
一、是什么diff 算法是一种通过同层的树节点进行比较的高效算法
其有两个特点：

比较只会在同层级进行, 不会跨层级比较
在diff比较的过程中，循环从两边向中间比较

diff 算法在很多场景下都有应用，在 vue 中，作用于虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较
二、比较方式diff整体策略为：深度优先，同层比较

比较只会在同层级进行, 不会跨层级比较




比较的过程中，循环从两边向中间收拢



下面举个vue通过diff算法更新的例子：
新旧VNode节点如下图所示：

第一次循环后，发现旧节点D与新节点D相同，直接复用旧节点D作为diff后的第一个真实节点，同时旧节点endIndex移动到C，新节点的 startIndex 移动到了 C

第二次循环后，同样是旧节点的末尾和新节点的开头(都是 C)相同，同理，diff 后创建了 C 的真实节点插入到第一次创建的 D 节点后面。同时旧节点的 endIndex 移动到了 B，新节点的 startIndex 移动到了 E

第三次循环中，发现E没有找到，这时候只能直接创建新的真实节点 E，插入到第二次创建的 C 节点之后。同时新节点的 startIndex 移动到了 A。旧节点的 startIndex 和 endIndex 都保持不动

第四次循环中，发现了新旧节点的开头(都是 A)相同，于是 diff 后创建了 A 的真实节点，插入到前一次创建的 E 节点后面。同时旧节点的 startIndex 移动到了 B，新节点的 startIndex 移动到了 B

第五次循环中，情形同第四次循环一样，因此 diff 后创建了 B 真实节点 插入到前一次创建的 A 节点后面。同时旧节点的 startIndex 移动到了 C，新节点的 startIndex 移动到了 F

新节点的 startIndex 已经大于 endIndex 了，需要创建 newStartIdx 和 newEndIdx 之间的所有节点，也就是节点F，直接创建 F 节点对应的真实节点放到 B 节点后面

三、原理分析当数据发生改变时，set方法会调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图
源码位置：src&#x2F;core&#x2F;vdom&#x2F;patch.js
function patch(oldVnode, vnode, hydrating, removeOnly) &#123;    if (isUndef(vnode)) &#123; // 没有新节点，直接执行destory钩子函数        if (isDef(oldVnode)) invokeDestroyHook(oldVnode)        return    &#125;    let isInitialPatch = false    const insertedVnodeQueue = []    if (isUndef(oldVnode)) &#123;        isInitialPatch = true        createElm(vnode, insertedVnodeQueue) // 没有旧节点，直接用新节点生成dom元素    &#125; else &#123;        const isRealElement = isDef(oldVnode.nodeType)        if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;            // 判断旧节点和新节点自身一样，一致执行patchVnode            patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)        &#125; else &#123;            // 否则直接销毁及旧节点，根据新节点生成dom元素            if (isRealElement) &#123;                if (oldVnode.nodeType === 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123;                    oldVnode.removeAttribute(SSR_ATTR)                    hydrating = true                &#125;                if (isTrue(hydrating)) &#123;                    if (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;                        invokeInsertHook(vnode, insertedVnodeQueue, true)                        return oldVnode                    &#125;                &#125;                oldVnode = emptyNodeAt(oldVnode)            &#125;            return vnode.elm        &#125;    &#125;&#125;

patch函数前两个参数位为oldVnode 和 Vnode ，分别代表新的节点和之前的旧节点，主要做了四个判断：

没有新节点，直接触发旧节点的destory钩子
没有旧节点，说明是页面刚开始初始化的时候，此时，根本不需要比较了，直接全是新建，所以只调用 createElm
旧节点和新节点自身一样，通过 sameVnode 判断节点是否一样，一样时，直接调用 patchVnode 去处理这两个节点
旧节点和新节点自身不一样，当两个节点不一样的时候，直接创建新节点，删除旧节点

下面主要讲的是patchVnode部分
function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) &#123;    // 如果新旧节点一致，什么都不做    if (oldVnode === vnode) &#123;      return    &#125;    // 让vnode.el引用到现在的真实dom，当el修改时，vnode.el会同步变化    const elm = vnode.elm = oldVnode.elm    // 异步占位符    if (isTrue(oldVnode.isAsyncPlaceholder)) &#123;      if (isDef(vnode.asyncFactory.resolved)) &#123;        hydrate(oldVnode.elm, vnode, insertedVnodeQueue)      &#125; else &#123;        vnode.isAsyncPlaceholder = true      &#125;      return    &#125;    // 如果新旧都是静态节点，并且具有相同的key    // 当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上    // 也不用再有其他操作    if (isTrue(vnode.isStatic) &amp;&amp;      isTrue(oldVnode.isStatic) &amp;&amp;      vnode.key === oldVnode.key &amp;&amp;      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))    ) &#123;      vnode.componentInstance = oldVnode.componentInstance      return    &#125;    let i    const data = vnode.data    if (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) &#123;      i(oldVnode, vnode)    &#125;    const oldCh = oldVnode.children    const ch = vnode.children    if (isDef(data) &amp;&amp; isPatchable(vnode)) &#123;      for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)      if (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode)    &#125;    // 如果vnode不是文本节点或者注释节点    if (isUndef(vnode.text)) &#123;      // 并且都有子节点      if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;        // 并且子节点不完全一致，则调用updateChildren        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)        // 如果只有新的vnode有子节点      &#125; else if (isDef(ch)) &#123;        if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &#x27;&#x27;)        // elm已经引用了老的dom节点，在老的dom节点上添加子节点        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)        // 如果新vnode没有子节点，而vnode有子节点，直接删除老的oldCh      &#125; else if (isDef(oldCh)) &#123;        removeVnodes(elm, oldCh, 0, oldCh.length - 1)        // 如果老节点是文本节点      &#125; else if (isDef(oldVnode.text)) &#123;        nodeOps.setTextContent(elm, &#x27;&#x27;)      &#125;      // 如果新vnode和老vnode是文本节点或注释节点      // 但是vnode.text != oldVnode.text时，只需要更新vnode.elm的文本内容就可以    &#125; else if (oldVnode.text !== vnode.text) &#123;      nodeOps.setTextContent(elm, vnode.text)    &#125;    if (isDef(data)) &#123;      if (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode)    &#125;  &#125;

patchVnode主要做了几个判断：

新节点是否是文本节点，如果是，则直接更新dom的文本内容为新节点的文本内容
新节点和旧节点如果都有子节点，则处理比较更新子节点
只有新节点有子节点，旧节点没有，那么不用比较了，所有节点都是全新的，所以直接全部新建就好了，新建是指创建出所有新DOM，并且添加进父节点
只有旧节点有子节点而新节点没有，说明更新后的页面，旧节点全部都不见了，那么要做的，就是把所有的旧节点删除，也就是直接把DOM 删除

子节点不完全一致，则调用updateChildren
function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;    let oldStartIdx = 0 // 旧头索引    let newStartIdx = 0 // 新头索引    let oldEndIdx = oldCh.length - 1 // 旧尾索引    let newEndIdx = newCh.length - 1 // 新尾索引    let oldStartVnode = oldCh[0] // oldVnode的第一个child    let oldEndVnode = oldCh[oldEndIdx] // oldVnode的最后一个child    let newStartVnode = newCh[0] // newVnode的第一个child    let newEndVnode = newCh[newEndIdx] // newVnode的最后一个child    let oldKeyToIdx, idxInOld, vnodeToMove, refElm    // removeOnly is a special flag used only by &lt;transition-group&gt;    // to ensure removed elements stay in correct relative positions    // during leaving transitions    const canMove = !removeOnly    // 如果oldStartVnode和oldEndVnode重合，并且新的也都重合了，证明diff完了，循环结束    while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;      // 如果oldVnode的第一个child不存在      if (isUndef(oldStartVnode)) &#123;        // oldStart索引右移        oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left      // 如果oldVnode的最后一个child不存在      &#125; else if (isUndef(oldEndVnode)) &#123;        // oldEnd索引左移        oldEndVnode = oldCh[--oldEndIdx]      // oldStartVnode和newStartVnode是同一个节点      &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123;        // patch oldStartVnode和newStartVnode， 索引左移，继续循环        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)        oldStartVnode = oldCh[++oldStartIdx]        newStartVnode = newCh[++newStartIdx]      // oldEndVnode和newEndVnode是同一个节点      &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123;        // patch oldEndVnode和newEndVnode，索引右移，继续循环        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)        oldEndVnode = oldCh[--oldEndIdx]        newEndVnode = newCh[--newEndIdx]      // oldStartVnode和newEndVnode是同一个节点      &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right        // patch oldStartVnode和newEndVnode        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)        // 如果removeOnly是false，则将oldStartVnode.eml移动到oldEndVnode.elm之后        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))        // oldStart索引右移，newEnd索引左移        oldStartVnode = oldCh[++oldStartIdx]        newEndVnode = newCh[--newEndIdx]      // 如果oldEndVnode和newStartVnode是同一个节点      &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left        // patch oldEndVnode和newStartVnode        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)        // 如果removeOnly是false，则将oldEndVnode.elm移动到oldStartVnode.elm之前        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)        // oldEnd索引左移，newStart索引右移        oldEndVnode = oldCh[--oldEndIdx]        newStartVnode = newCh[++newStartIdx]      // 如果都不匹配      &#125; else &#123;        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)        // 尝试在oldChildren中寻找和newStartVnode的具有相同的key的Vnode        idxInOld = isDef(newStartVnode.key)          ? oldKeyToIdx[newStartVnode.key]          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)        // 如果未找到，说明newStartVnode是一个新的节点        if (isUndef(idxInOld)) &#123; // New element          // 创建一个新Vnode          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)        // 如果找到了和newStartVnodej具有相同的key的Vnode，叫vnodeToMove        &#125; else &#123;          vnodeToMove = oldCh[idxInOld]          /* istanbul ignore if */          if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !vnodeToMove) &#123;            warn(              &#x27;It seems there are duplicate keys that is causing an update error. &#x27; +              &#x27;Make sure each v-for item has a unique key.&#x27;            )          &#125;          // 比较两个具有相同的key的新节点是否是同一个节点          //不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom。          if (sameVnode(vnodeToMove, newStartVnode)) &#123;            // patch vnodeToMove和newStartVnode            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)            // 清除            oldCh[idxInOld] = undefined            // 如果removeOnly是false，则将找到的和newStartVnodej具有相同的key的Vnode，叫vnodeToMove.elm            // 移动到oldStartVnode.elm之前            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)          // 如果key相同，但是节点不相同，则创建一个新的节点          &#125; else &#123;            // same key but different element. treat as new element            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)          &#125;        &#125;        // 右移        newStartVnode = newCh[++newStartIdx]      &#125;    &#125;

while循环主要处理了以下五种情景：

当新老 VNode 节点的 start 相同时，直接 patchVnode ，同时新老 VNode 节点的开始索引都加 1
当新老 VNode 节点的 end相同时，同样直接 patchVnode ，同时新老 VNode 节点的结束索引都减 1
当老 VNode 节点的 start 和新 VNode 节点的 end 相同时，这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldEndVnode 的后面，同时老 VNode 节点开始索引加 1，新 VNode 节点的结束索引减 1
当老 VNode 节点的 end 和新 VNode 节点的 start 相同时，这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldStartVnode 的前面，同时老 VNode 节点结束索引减 1，新 VNode 节点的开始索引加 1
如果都不满足以上四种情形，那说明没有相同的节点可以复用，则会分为以下两种情况：
从旧的 VNode 为 key 值，对应 index 序列为 value 值的哈希表中找到与 newStartVnode 一致 key 的旧的 VNode 节点，再进行patchVnode ，同时将这个真实 dom 移动到 oldStartVnode 对应的真实 dom 的前面
调用 createElm 创建一个新的 dom 节点放到当前 newStartIdx 的位置



小结
当数据发生改变时，订阅者watcher就会调用patch给真实的DOM打补丁
通过isSameVnode进行判断，相同则调用patchVnode方法
patchVnode做了以下操作：
找到对应的真实dom，称为el
如果都有都有文本节点且不相等，将el文本节点设置为Vnode的文本节点
如果oldVnode有子节点而VNode没有，则删除el子节点
如果oldVnode没有子节点而VNode有，则将VNode的子节点真实化后添加到el
如果两者都有子节点，则执行updateChildren函数比较子节点


updateChildren主要做了以下操作：
设置新旧VNode的头尾指针
新旧头尾指针进行比较，循环向中间靠拢，根据情况调用patchVnode进行patch重复流程、调用createElem创建一个新节点，从哈希表寻找 key一致的VNode 节点再分情况操作



参考文献
https://juejin.cn/post/6881907432541552648#heading-1
https://www.infoq.cn/article/udlcpkh4iqb0cr5wgy7f

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue实例挂载的过程</title>
    <url>/2024/07/19/vue-new-vue/</url>
    <content><![CDATA[
一、思考我们都听过知其然知其所以然这句话
那么不知道大家是否思考过new Vue()这个过程中究竟做了些什么？
过程中是如何完成数据的绑定，又是如何将数据渲染到视图的等等
一、分析首先找到vue的构造函数
源码位置：src\core\instance\index.js
function Vue (options) &#123;  if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp;    !(this instanceof Vue)  ) &#123;    warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;)  &#125;  this._init(options)&#125;

options是用户传递过来的配置项，如data、methods等常用的方法
vue构建函数调用_init方法，但我们发现本文件中并没有此方法，但仔细可以看到文件下方定定义了很多初始化方法
initMixin(Vue);     // 定义 _initstateMixin(Vue);    // 定义 $set $get $delete $watch 等eventsMixin(Vue);   // 定义事件  $on  $once $off $emitlifecycleMixin(Vue);// 定义 _update  $forceUpdate  $destroyrenderMixin(Vue);   // 定义 _render 返回虚拟dom

首先可以看initMixin方法，发现该方法在Vue原型上定义了_init方法
源码位置：src\core\instance\init.js
Vue.prototype._init = function (options?: Object) &#123;    const vm: Component = this    // a uid    vm._uid = uid++    let startTag, endTag    /* istanbul ignore if */    if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123;      startTag = `vue-perf-start:$&#123;vm._uid&#125;`      endTag = `vue-perf-end:$&#123;vm._uid&#125;`      mark(startTag)    &#125;    // a flag to avoid this being observed    vm._isVue = true    // merge options    // 合并属性，判断初始化的是否是组件，这里合并主要是 mixins 或 extends 的方法    if (options &amp;&amp; options._isComponent) &#123;      // optimize internal component instantiation      // since dynamic options merging is pretty slow, and none of the      // internal component options needs special treatment.      initInternalComponent(vm, options)    &#125; else &#123; // 合并vue属性      vm.$options = mergeOptions(        resolveConstructorOptions(vm.constructor),        options || &#123;&#125;,        vm      )    &#125;    /* istanbul ignore else */    if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;      // 初始化proxy拦截器      initProxy(vm)    &#125; else &#123;      vm._renderProxy = vm    &#125;    // expose real self    vm._self = vm    // 初始化组件生命周期标志位    initLifecycle(vm)    // 初始化组件事件侦听    initEvents(vm)    // 初始化渲染方法    initRender(vm)    callHook(vm, &#x27;beforeCreate&#x27;)    // 初始化依赖注入内容，在初始化data、props之前    initInjections(vm) // resolve injections before data/props    // 初始化props/data/method/watch/methods    initState(vm)    initProvide(vm) // resolve provide after data/props    callHook(vm, &#x27;created&#x27;)    /* istanbul ignore if */    if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123;      vm._name = formatComponentName(vm, false)      mark(endTag)      measure(`vue $&#123;vm._name&#125; init`, startTag, endTag)    &#125;    // 挂载元素    if (vm.$options.el) &#123;      vm.$mount(vm.$options.el)    &#125;  &#125;

仔细阅读上面的代码，我们得到以下结论：

在调用beforeCreate之前，数据初始化并未完成，像data、props这些属性无法访问到

到了created的时候，数据已经初始化完成，能够访问data、props这些属性，但这时候并未完成dom的挂载，因此无法访问到dom元素

挂载方法是调用vm.$mount方法


initState方法是完成props/data/method/watch/methods的初始化
源码位置：src\core\instance\state.js
export function initState (vm: Component) &#123;  // 初始化组件的watcher列表  vm._watchers = []  const opts = vm.$options  // 初始化props  if (opts.props) initProps(vm, opts.props)  // 初始化methods方法  if (opts.methods) initMethods(vm, opts.methods)  if (opts.data) &#123;    // 初始化data      initData(vm)  &#125; else &#123;    observe(vm._data = &#123;&#125;, true /* asRootData */)  &#125;  if (opts.computed) initComputed(vm, opts.computed)  if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;    initWatch(vm, opts.watch)  &#125;&#125;

我们和这里主要看初始化data的方法为initData，它与initState在同一文件上
function initData (vm: Component) &#123;  let data = vm.$options.data  // 获取到组件上的data  data = vm._data = typeof data === &#x27;function&#x27;    ? getData(data, vm)    : data || &#123;&#125;  if (!isPlainObject(data)) &#123;    data = &#123;&#125;    process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(      &#x27;data functions should return an object:\n&#x27; +      &#x27;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;,      vm    )  &#125;  // proxy data on instance  const keys = Object.keys(data)  const props = vm.$options.props  const methods = vm.$options.methods  let i = keys.length  while (i--) &#123;    const key = keys[i]    if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;      // 属性名不能与方法名重复      if (methods &amp;&amp; hasOwn(methods, key)) &#123;        warn(          `Method &quot;$&#123;key&#125;&quot; has already been defined as a data property.`,          vm        )      &#125;    &#125;    // 属性名不能与state名称重复    if (props &amp;&amp; hasOwn(props, key)) &#123;      process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(        `The data property &quot;$&#123;key&#125;&quot; is already declared as a prop. ` +        `Use prop default value instead.`,        vm      )    &#125; else if (!isReserved(key)) &#123; // 验证key值的合法性      // 将_data中的数据挂载到组件vm上,这样就可以通过this.xxx访问到组件上的数据      proxy(vm, `_data`, key)    &#125;  &#125;  // observe data  // 响应式监听data是数据的变化  observe(data, true /* asRootData */)&#125;

仔细阅读上面的代码，我们可以得到以下结论：

初始化顺序：props、methods、data

data定义的时候可选择函数形式或者对象形式（组件只能为函数形式）


关于数据响应式在这就不展开详细说明
上文提到挂载方法是调用vm.$mount方法
源码位置：
Vue.prototype.$mount = function (  el?: string | Element,  hydrating?: boolean): Component &#123;  // 获取或查询元素  el = el &amp;&amp; query(el)  /* istanbul ignore if */  // vue 不允许直接挂载到body或页面文档上  if (el === document.body || el === document.documentElement) &#123;    process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(      `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`    )    return this  &#125;  const options = this.$options  // resolve template/el and convert to render function  if (!options.render) &#123;    let template = options.template    // 存在template模板，解析vue模板文件    if (template) &#123;      if (typeof template === &#x27;string&#x27;) &#123;        if (template.charAt(0) === &#x27;#&#x27;) &#123;          template = idToTemplate(template)          /* istanbul ignore if */          if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !template) &#123;            warn(              `Template element not found or is empty: $&#123;options.template&#125;`,              this            )          &#125;        &#125;      &#125; else if (template.nodeType) &#123;        template = template.innerHTML      &#125; else &#123;        if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;          warn(&#x27;invalid template option:&#x27; + template, this)        &#125;        return this      &#125;    &#125; else if (el) &#123;      // 通过选择器获取元素内容      template = getOuterHTML(el)    &#125;    if (template) &#123;      /* istanbul ignore if */      if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123;        mark(&#x27;compile&#x27;)      &#125;      /**       *  1.将temmplate解析ast tree       *  2.将ast tree转换成render语法字符串       *  3.生成render方法       */      const &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;        outputSourceRange: process.env.NODE_ENV !== &#x27;production&#x27;,        shouldDecodeNewlines,        shouldDecodeNewlinesForHref,        delimiters: options.delimiters,        comments: options.comments      &#125;, this)      options.render = render      options.staticRenderFns = staticRenderFns      /* istanbul ignore if */      if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123;        mark(&#x27;compile end&#x27;)        measure(`vue $&#123;this._name&#125; compile`, &#x27;compile&#x27;, &#x27;compile end&#x27;)      &#125;    &#125;  &#125;  return mount.call(this, el, hydrating)&#125;

阅读上面代码，我们能得到以下结论：

不要将根元素放到body或者html上

可以在对象中定义template/render或者直接使用template、el表示元素选择器

最终都会解析成render函数，调用compileToFunctions，会将template解析成render函数


对template的解析步骤大致分为以下几步：

将html文档片段解析成ast描述符

将ast描述符解析成字符串

生成render函数


生成render函数，挂载到vm上后，会再次调用mount方法
源码位置：src\platforms\web\runtime\index.js
// public mount methodVue.prototype.$mount = function (  el?: string | Element,  hydrating?: boolean): Component &#123;  el = el &amp;&amp; inBrowser ? query(el) : undefined  // 渲染组件  return mountComponent(this, el, hydrating)&#125;

调用mountComponent渲染组件
export function mountComponent (  vm: Component,  el: ?Element,  hydrating?: boolean): Component &#123;  vm.$el = el  // 如果没有获取解析的render函数，则会抛出警告  // render是解析模板文件生成的  if (!vm.$options.render) &#123;    vm.$options.render = createEmptyVNode    if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;      /* istanbul ignore if */      if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== &#x27;#&#x27;) ||        vm.$options.el || el) &#123;        warn(          &#x27;You are using the runtime-only build of Vue where the template &#x27; +          &#x27;compiler is not available. Either pre-compile the templates into &#x27; +          &#x27;render functions, or use the compiler-included build.&#x27;,          vm        )      &#125; else &#123;        // 没有获取到vue的模板文件        warn(          &#x27;Failed to mount component: template or render function not defined.&#x27;,          vm        )      &#125;    &#125;  &#125;  // 执行beforeMount钩子  callHook(vm, &#x27;beforeMount&#x27;)  let updateComponent  /* istanbul ignore if */  if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123;    updateComponent = () =&gt; &#123;      const name = vm._name      const id = vm._uid      const startTag = `vue-perf-start:$&#123;id&#125;`      const endTag = `vue-perf-end:$&#123;id&#125;`      mark(startTag)      const vnode = vm._render()      mark(endTag)      measure(`vue $&#123;name&#125; render`, startTag, endTag)      mark(startTag)      vm._update(vnode, hydrating)      mark(endTag)      measure(`vue $&#123;name&#125; patch`, startTag, endTag)    &#125;  &#125; else &#123;    // 定义更新函数    updateComponent = () =&gt; &#123;      // 实际调⽤是在lifeCycleMixin中定义的_update和renderMixin中定义的_render      vm._update(vm._render(), hydrating)    &#125;  &#125;  // we set this to vm._watcher inside the watcher&#x27;s constructor  // since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child  // component&#x27;s mounted hook), which relies on vm._watcher being already defined  // 监听当前组件状态，当有数据变化时，更新组件  new Watcher(vm, updateComponent, noop, &#123;    before () &#123;      if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;        // 数据更新引发的组件更新        callHook(vm, &#x27;beforeUpdate&#x27;)      &#125;    &#125;  &#125;, true /* isRenderWatcher */)  hydrating = false  // manually mounted instance, call mounted on self  // mounted is called for render-created child components in its inserted hook  if (vm.$vnode == null) &#123;    vm._isMounted = true    callHook(vm, &#x27;mounted&#x27;)  &#125;  return vm&#125;

阅读上面代码，我们得到以下结论：

会触发beforeCreate钩子
定义updateComponent渲染页面视图的方法
监听组件数据，一旦发生变化，触发beforeUpdate生命钩子

updateComponent方法主要执行在vue初始化时声明的render，update方法
render的作用主要是生成vnode
源码位置：src\core\instance\render.js
// 定义vue 原型上的render方法Vue.prototype._render = function (): VNode &#123;    const vm: Component = this    // render函数来自于组件的option    const &#123; render, _parentVnode &#125; = vm.$options    if (_parentVnode) &#123;        vm.$scopedSlots = normalizeScopedSlots(            _parentVnode.data.scopedSlots,            vm.$slots,            vm.$scopedSlots        )    &#125;    // set parent vnode. this allows render functions to have access    // to the data on the placeholder node.    vm.$vnode = _parentVnode    // render self    let vnode    try &#123;        // There&#x27;s no need to maintain a stack because all render fns are called        // separately from one another. Nested component&#x27;s render fns are called        // when parent component is patched.        currentRenderingInstance = vm        // 调用render方法，自己的独特的render方法， 传入createElement参数，生成vNode        vnode = render.call(vm._renderProxy, vm.$createElement)    &#125; catch (e) &#123;        handleError(e, vm, `render`)        // return error render result,        // or previous vnode to prevent render error causing blank component        /* istanbul ignore else */        if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; vm.$options.renderError) &#123;            try &#123;                vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)            &#125; catch (e) &#123;                handleError(e, vm, `renderError`)                vnode = vm._vnode            &#125;        &#125; else &#123;            vnode = vm._vnode        &#125;    &#125; finally &#123;        currentRenderingInstance = null    &#125;    // if the returned array contains only a single node, allow it    if (Array.isArray(vnode) &amp;&amp; vnode.length === 1) &#123;        vnode = vnode[0]    &#125;    // return empty vnode in case the render function errored out    if (!(vnode instanceof VNode)) &#123;        if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; Array.isArray(vnode)) &#123;            warn(                &#x27;Multiple root nodes returned from render function. Render function &#x27; +                &#x27;should return a single root node.&#x27;,                vm            )        &#125;        vnode = createEmptyVNode()    &#125;    // set parent    vnode.parent = _parentVnode    return vnode&#125;

_update主要功能是调用patch，将vnode转换为真实DOM，并且更新到页面中
源码位置：src\core\instance\lifecycle.js
Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123;    const vm: Component = this    const prevEl = vm.$el    const prevVnode = vm._vnode    // 设置当前激活的作用域    const restoreActiveInstance = setActiveInstance(vm)    vm._vnode = vnode    // Vue.prototype.__patch__ is injected in entry points    // based on the rendering backend used.    if (!prevVnode) &#123;      // initial render      // 执行具体的挂载逻辑      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)    &#125; else &#123;      // updates      vm.$el = vm.__patch__(prevVnode, vnode)    &#125;    restoreActiveInstance()    // update __vue__ reference    if (prevEl) &#123;      prevEl.__vue__ = null    &#125;    if (vm.$el) &#123;      vm.$el.__vue__ = vm    &#125;    // if parent is an HOC, update its $el as well    if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;      vm.$parent.$el = vm.$el    &#125;    // updated hook is called by the scheduler to ensure that children are    // updated in a parent&#x27;s updated hook.  &#125;



三、结论
new Vue的时候调用会调用_init方法

定义 $set、 $get 、$delete、$watch 等方法
定义 $on、$off、$emit、$off 等事件
定义 _update、$forceUpdate、$destroy生命周期


调用$mount进行页面的挂载

挂载的时候主要是通过mountComponent方法

定义updateComponent更新函数

执行render生成虚拟DOM

_update将虚拟DOM生成真实DOM结构，并且渲染到页面中


参考文献
https://www.cnblogs.com/gerry2019/p/12001661.html
https://github.com/vuejs/vue/tree/dev/src/core/instance 
https://vue3js.cn

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
</search>
