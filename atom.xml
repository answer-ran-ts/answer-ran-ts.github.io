<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BlogMind</title>
  
  <subtitle>思维的栖息地</subtitle>
  <link href="https://blogmind.cloud/atom.xml" rel="self"/>
  
  <link href="https://blogmind.cloud/"/>
  <updated>2025-02-07T08:24:37.855Z</updated>
  <id>https://blogmind.cloud/</id>
  
  <author>
    <name>Answer Ran</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何理性看待AI发展：一把双刃剑</title>
    <link href="https://blogmind.cloud/2025/02/06/ai-ai-development-perspective/"/>
    <id>https://blogmind.cloud/2025/02/06/ai-ai-development-perspective/</id>
    <published>2025-02-05T16:00:00.000Z</published>
    <updated>2025-02-07T08:24:37.855Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>人工智能(AI)正以前所未有的速度发展，从ChatGPT到DALL-E，从自动驾驶到智能医疗，AI技术正在重塑我们的生活方式和工作模式。作为21世纪最具革命性的技术之一，AI就像一把双刃剑，既能创造巨大价值，也可能带来意想不到的挑战。本文将深入分析AI发展的方方面面，帮助我们以更理性的态度看待AI技术的发展。</p><h2 id="AI发展的积极影响"><a href="#AI发展的积极影响" class="headerlink" title="AI发展的积极影响"></a>AI发展的积极影响</h2><h3 id="1-效率提升"><a href="#1-效率提升" class="headerlink" title="1. 效率提升"></a>1. 效率提升</h3><ul><li><p><strong>工作自动化</strong></p><ul><li>自动处理重复性文档工作，提高办公效率</li><li>智能客服24小时在线，提升服务质量</li><li>工业自动化生产，提高产能和精确度</li></ul></li><li><p><strong>决策优化</strong></p><ul><li>大数据分析辅助决策，降低决策风险</li><li>预测模型提供决策参考，提高准确率</li><li>实时数据处理，支持快速响应</li></ul></li><li><p><strong>资源配置</strong></p><ul><li>智能调度系统优化物流配送</li><li>能源使用智能管理，降低资源浪费</li><li>智能算法优化人力资源分配</li></ul></li></ul><h3 id="2-创新突破"><a href="#2-创新突破" class="headerlink" title="2. 创新突破"></a>2. 创新突破</h3><ul><li><p><strong>医疗健康</strong></p><ul><li>AI辅助诊断提高疾病识别准确率</li><li>药物研发周期大幅缩短</li><li>个性化治疗方案制定</li><li>远程医疗服务普及</li></ul></li><li><p><strong>科研进展</strong></p><ul><li>加速科学计算和模拟</li><li>发现新材料和新物质</li><li>气候变化预测更准确</li><li>空间探索取得新突破</li></ul></li><li><p><strong>产品创新</strong></p><ul><li>智能产品快速迭代</li><li>个性化定制更便捷</li><li>新产品研发周期缩短</li><li>用户体验持续优化</li></ul></li></ul><h3 id="3-生活改善"><a href="#3-生活改善" class="headerlink" title="3. 生活改善"></a>3. 生活改善</h3><ul><li><p><strong>智能家居</strong></p><ul><li>家电智能控制，提升生活便利性</li><li>能源使用更环保高效</li><li>居家安全保障增强</li><li>老人和儿童照护更周到</li></ul></li><li><p><strong>教育革新</strong></p><ul><li>个性化学习计划制定</li><li>教育资源普惠化</li><li>在线教育更加智能</li><li>终身学习更加便捷</li></ul></li><li><p><strong>娱乐体验</strong></p><ul><li>游戏体验更加真实</li><li>虚拟现实技术提升</li><li>内容创作更加丰富</li><li>个性化推荐更准确</li></ul></li></ul><h2 id="AI发展的潜在风险"><a href="#AI发展的潜在风险" class="headerlink" title="AI发展的潜在风险"></a>AI发展的潜在风险</h2><h3 id="1-就业冲击"><a href="#1-就业冲击" class="headerlink" title="1. 就业冲击"></a>1. 就业冲击</h3><ul><li><p><strong>岗位替代</strong></p><ul><li>基础性工作岗位加速消失</li><li>传统行业面临转型压力</li><li>就业结构急剧变化</li></ul></li><li><p><strong>技能挑战</strong></p><ul><li>现有技能快速过时</li><li>新技能学习压力增大</li><li>职业转型难度加大</li></ul></li><li><p><strong>就业市场变化</strong></p><ul><li>人才需求结构性失衡</li><li>就业竞争加剧</li><li>收入差距可能扩大</li></ul></li></ul><h3 id="2-伦理挑战"><a href="#2-伦理挑战" class="headerlink" title="2. 伦理挑战"></a>2. 伦理挑战</h3><ul><li><p><strong>隐私安全</strong></p><ul><li>个人数据被过度收集</li><li>隐私边界日益模糊</li><li>数据安全风险增加</li><li>个人信息滥用问题</li></ul></li><li><p><strong>算法公平</strong></p><ul><li>AI决策可能存在偏见</li><li>算法歧视问题</li><li>责任归属难以界定</li><li>社会公平受到挑战</li></ul></li><li><p><strong>人机关系</strong></p><ul><li>人类自主性可能受限</li><li>过度依赖AI的风险</li><li>人际关系疏离化</li><li>心理健康新挑战</li></ul></li></ul><h3 id="3-社会影响"><a href="#3-社会影响" class="headerlink" title="3. 社会影响"></a>3. 社会影响</h3><ul><li><p><strong>数字鸿沟</strong></p><ul><li>贫富差距可能扩大</li><li>教育资源获取不均</li><li>技术普及度差异</li><li>区域发展不平衡</li></ul></li><li><p><strong>社会结构</strong></p><ul><li>传统社会关系改变</li><li>社会价值观转变</li><li>文化传承面临挑战</li><li>社会治理新课题</li></ul></li></ul><h2 id="如何理性应对"><a href="#如何理性应对" class="headerlink" title="如何理性应对"></a>如何理性应对</h2><h3 id="1-个人层面"><a href="#1-个人层面" class="headerlink" title="1. 个人层面"></a>1. 个人层面</h3><ul><li><p><strong>终身学习</strong></p><ul><li>持续更新知识储备</li><li>培养跨领域能力</li><li>提升数字化素养</li><li>保持学习积极性</li></ul></li><li><p><strong>能力培养</strong></p><ul><li>强化创造性思维</li><li>提升批判性思考</li><li>发展情商和共情能力</li><li>培养人机协作能力</li></ul></li></ul><h3 id="2-社会层面"><a href="#2-社会层面" class="headerlink" title="2. 社会层面"></a>2. 社会层面</h3><ul><li><p><strong>制度建设</strong></p><ul><li>完善AI伦理准则</li><li>建立监管框架</li><li>保护个人权益</li><li>促进公平发展</li></ul></li><li><p><strong>教育改革</strong></p><ul><li>更新教育理念</li><li>改革课程体系</li><li>加强技能培训</li><li>普及AI教育</li></ul></li></ul><h3 id="3-发展方向"><a href="#3-发展方向" class="headerlink" title="3. 发展方向"></a>3. 发展方向</h3><ul><li><p><strong>以人为本</strong></p><ul><li>强调技术向善</li><li>注重人文关怀</li><li>维护人类尊严</li><li>促进共同发展</li></ul></li><li><p><strong>可持续发展</strong></p><ul><li>平衡效率与公平</li><li>注重环境保护</li><li>促进包容性增长</li><li>维护社会稳定</li></ul></li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>AI发展是一把真正的双刃剑，它既能带来前所未有的发展机遇，也可能产生难以预料的风险。关键在于我们如何趋利避害，在享受技术红利的同时，也要未雨绸缪，防范潜在风险。</p><p>我们需要以开放、包容但审慎的态度拥抱AI技术，在个人、企业和社会层面都要做好充分准备。只有正确认识和把握这把双刃剑，在发展中坚持以人为本，注重可持续发展，我们才能在AI时代走得更稳、走得更远。</p><p>让我们携手共建一个人机协作、互惠共赢的美好未来。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;人工智能(AI)正以前所未有的速度发展，从ChatGPT到DALL-E，从自动驾驶到智能医疗，AI技术正在重塑我们的生活方式和工作模式。作为</summary>
      
    
    
    
    <category term="AI" scheme="https://blogmind.cloud/categories/AI/"/>
    
    
    <category term="AI" scheme="https://blogmind.cloud/tags/AI/"/>
    
    <category term="人工智能" scheme="https://blogmind.cloud/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="技术发展" scheme="https://blogmind.cloud/tags/%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95/"/>
    
    <category term="AI伦理" scheme="https://blogmind.cloud/tags/AI%E4%BC%A6%E7%90%86/"/>
    
    <category term="未来发展" scheme="https://blogmind.cloud/tags/%E6%9C%AA%E6%9D%A5%E5%8F%91%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>你了解axios的原理吗？有看过它的源码吗？</title>
    <link href="https://blogmind.cloud/2025/02/03/vue-axiosCode/"/>
    <id>https://blogmind.cloud/2025/02/03/vue-axiosCode/</id>
    <published>2025-02-03T08:00:00.000Z</published>
    <updated>2025-02-08T06:49:30.105Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.vue-js.com/1564f7d0-4662-11eb-ab90-d9ae814b240d.png"></p><h2 id="一、axios的使用"><a href="#一、axios的使用" class="headerlink" title="一、axios的使用"></a>一、axios的使用</h2><p>关于<code>axios</code>的基本使用，上篇文章已经有所涉及，这里再稍微回顾下：</p><p><strong>发送请求</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">axios</span>(config) <span class="comment">// 直接传入配置</span></span><br><span class="line"><span class="title function_">axios</span>(url[, config]) <span class="comment">// 传入url和配置</span></span><br><span class="line">axios[method](url[, option]) <span class="comment">// 直接调用请求方式方法，传入url和配置</span></span><br><span class="line">axios[method](url[, data[, option]]) <span class="comment">// 直接调用请求方式方法，传入data、url和配置</span></span><br><span class="line">axios.<span class="title function_">request</span>(option) <span class="comment">// 调用 request 方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> axiosInstance = axios.<span class="title function_">create</span>(config)</span><br><span class="line"><span class="comment">// axiosInstance 也具有以上 axios 的能力</span></span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">all</span>([axiosInstance1, axiosInstance2]).<span class="title function_">then</span>(axios.<span class="title function_">spread</span>(response1, response2))</span><br><span class="line"><span class="comment">// 调用 all 和传入 spread 回调</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>请求拦截器</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里写发送请求前处理的代码</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里写发送请求错误相关的代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>响应拦截器</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里写得到响应数据后处理的代码</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里写得到错误响应处理的代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>取消请求</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CancelToken</span> = axios.<span class="property">CancelToken</span>;</span><br><span class="line"><span class="keyword">const</span> source = <span class="title class_">CancelToken</span>.<span class="title function_">source</span>();</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;xxxx&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">cancelToken</span>: source.<span class="property">token</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 取消请求 (请求原因是可选的)</span></span><br><span class="line">source.<span class="title function_">cancel</span>(<span class="string">&#x27;主动取消请求&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CancelToken</span> = axios.<span class="property">CancelToken</span>;</span><br><span class="line"><span class="keyword">let</span> cancel;</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;xxxx&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">cancelToken</span>: <span class="keyword">new</span> <span class="title class_">CancelToken</span>(<span class="keyword">function</span> <span class="title function_">executor</span>(<span class="params">c</span>) &#123;</span><br><span class="line">    cancel = c;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">cancel</span>(<span class="string">&#x27;主动取消请求&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="二、实现一个简易版axios"><a href="#二、实现一个简易版axios" class="headerlink" title="二、实现一个简易版axios"></a>二、实现一个简易版axios</h2><p>构建一个<code>Axios</code>构造函数，核心代码为<code>request</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Axios</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">request</span>(<span class="params">config</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123;url = <span class="string">&#x27;&#x27;</span>, method = <span class="string">&#x27;get&#x27;</span>, data = &#123;&#125;&#125; = config;</span><br><span class="line">            <span class="comment">// 发送ajax请求</span></span><br><span class="line">            <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">            xhr.<span class="title function_">open</span>(method, url, <span class="literal">true</span>);</span><br><span class="line">            xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>)</span><br><span class="line">                <span class="title function_">resolve</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            xhr.<span class="title function_">send</span>(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导出<code>axios</code>实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最终导出axios的方法，即实例的request方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">CreateAxiosFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> axios = <span class="keyword">new</span> <span class="title class_">Axios</span>();</span><br><span class="line">    <span class="keyword">let</span> req = axios.<span class="property">request</span>.<span class="title function_">bind</span>(axios);</span><br><span class="line">    <span class="keyword">return</span> req;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到最后的全局变量axios</span></span><br><span class="line"><span class="keyword">let</span> axios = <span class="title class_">CreateAxiosFn</span>();</span><br></pre></td></tr></table></figure><p>上述就已经能够实现<code>axios(&#123; &#125;)</code>这种方式的请求</p><p>下面是来实现下<code>axios.method()</code>这种形式的请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义get,post...方法，挂在到Axios原型上</span></span><br><span class="line"><span class="keyword">const</span> methodsArr = [<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;head&#x27;</span>, <span class="string">&#x27;options&#x27;</span>, <span class="string">&#x27;put&#x27;</span>, <span class="string">&#x27;patch&#x27;</span>, <span class="string">&#x27;post&#x27;</span>];</span><br><span class="line">methodsArr.<span class="title function_">forEach</span>(<span class="function"><span class="params">met</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>[met] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行&#x27;</span>+met+<span class="string">&#x27;方法&#x27;</span>);</span><br><span class="line">        <span class="comment">// 处理单个方法</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;head&#x27;</span>, <span class="string">&#x27;options&#x27;</span>].<span class="title function_">includes</span>(met)) &#123; <span class="comment">// 2个参数(url[, config])</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">                <span class="attr">method</span>: met,</span><br><span class="line">                <span class="attr">url</span>: <span class="variable language_">arguments</span>[<span class="number">0</span>],</span><br><span class="line">                ...<span class="variable language_">arguments</span>[<span class="number">1</span>] || &#123;&#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 3个参数(url[,data[,config]])</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">                <span class="attr">method</span>: met,</span><br><span class="line">                <span class="attr">url</span>: <span class="variable language_">arguments</span>[<span class="number">0</span>],</span><br><span class="line">                <span class="attr">data</span>: <span class="variable language_">arguments</span>[<span class="number">1</span>] || &#123;&#125;,</span><br><span class="line">                ...<span class="variable language_">arguments</span>[<span class="number">2</span>] || &#123;&#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>将<code>Axios.prototype</code>上的方法搬运到<code>request</code>上</p><p>首先实现个工具类，实现将<code>b</code>方法混入到<code>a</code>，并且修改<code>this</code>指向</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> utils = &#123;</span><br><span class="line">  <span class="title function_">extend</span>(<span class="params">a,b, context</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> b) &#123;</span><br><span class="line">      <span class="keyword">if</span> (b.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> b[key] === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">          a[key] = b[key].<span class="title function_">bind</span>(context);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          a[key] = b[key]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改导出的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">CreateAxiosFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> axios = <span class="keyword">new</span> <span class="title class_">Axios</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> req = axios.<span class="property">request</span>.<span class="title function_">bind</span>(axios);</span><br><span class="line">  <span class="comment">// 增加代码</span></span><br><span class="line">  utils.<span class="title function_">extend</span>(req, <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>, axios)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> req;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建拦截器的构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InterceptorsManage</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handlers</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">use</span>(<span class="params">fullfield, rejected</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">      fullfield,</span><br><span class="line">      rejected</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现<code>axios.interceptors.response.use</code>和<code>axios.interceptors.request.use</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Axios</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 新增代码</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">interceptors</span> = &#123;</span><br><span class="line">            <span class="attr">request</span>: <span class="keyword">new</span> <span class="title class_">InterceptorsManage</span>,</span><br><span class="line">            <span class="attr">response</span>: <span class="keyword">new</span> <span class="title class_">InterceptorsManage</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">request</span>(<span class="params">config</span>) &#123;</span><br><span class="line"> ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行语句<code>axios.interceptors.response.use</code>和<code>axios.interceptors.request.use</code>的时候，实现获取<code>axios</code>实例上的<code>interceptors</code>对象，然后再获取<code>response</code>或<code>request</code>拦截器，再执行对应的拦截器的<code>use</code>方法</p><p>把<code>Axios</code>上的方法和属性搬到<code>request</code>过去</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">CreateAxiosFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> axios = <span class="keyword">new</span> <span class="title class_">Axios</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> req = axios.<span class="property">request</span>.<span class="title function_">bind</span>(axios);</span><br><span class="line">  <span class="comment">// 混入方法， 处理axios的request方法，使之拥有get,post...方法</span></span><br><span class="line">  utils.<span class="title function_">extend</span>(req, <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>, axios)</span><br><span class="line">  <span class="comment">// 新增代码</span></span><br><span class="line">  utils.<span class="title function_">extend</span>(req, axios)</span><br><span class="line">  <span class="keyword">return</span> req;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在<code>request</code>也有了<code>interceptors</code>对象，在发送请求的时候，会先获取<code>request</code>拦截器的<code>handlers</code>的方法来执行</p><p>首先将执行<code>ajax</code>的请求封装成一个方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">request</span>(<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">sendAjax</span>(config)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sendAjax</span>(<span class="params">config</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;url = <span class="string">&#x27;&#x27;</span>, method = <span class="string">&#x27;get&#x27;</span>, data = &#123;&#125;&#125; = config;</span><br><span class="line">        <span class="comment">// 发送ajax请求</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(config);</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">        xhr.<span class="title function_">open</span>(method, url, <span class="literal">true</span>);</span><br><span class="line">        xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>)</span><br><span class="line">            <span class="title function_">resolve</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.<span class="title function_">send</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得<code>handlers</code>中的回调</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">request</span>(<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="comment">// 拦截器和请求组装队列</span></span><br><span class="line">    <span class="keyword">let</span> chain = [<span class="variable language_">this</span>.<span class="property">sendAjax</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="literal">undefined</span>] <span class="comment">// 成对出现的，失败回调暂时不处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求拦截</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="property">handlers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">interceptor</span> =&gt;</span> &#123;</span><br><span class="line">        chain.<span class="title function_">unshift</span>(interceptor.<span class="property">fullfield</span>, interceptor.<span class="property">rejected</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应拦截</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="property">handlers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">interceptor</span> =&gt;</span> &#123;</span><br><span class="line">        chain.<span class="title function_">push</span>(interceptor.<span class="property">fullfield</span>, interceptor.<span class="property">rejected</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行队列，每次执行一对，并给promise赋最新的值</span></span><br><span class="line">    <span class="keyword">let</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(config);</span><br><span class="line">    <span class="keyword">while</span>(chain.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        promise = promise.<span class="title function_">then</span>(chain.<span class="title function_">shift</span>(), chain.<span class="title function_">shift</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>chains</code>大概是<code>[&#39;fulfilled1&#39;,&#39;reject1&#39;,&#39;fulfilled2&#39;,&#39;reject2&#39;,&#39;this.sendAjax&#39;,&#39;undefined&#39;,&#39;fulfilled2&#39;,&#39;reject2&#39;,&#39;fulfilled1&#39;,&#39;reject1&#39;]</code>这种形式</p><p>这样就能够成功实现一个简易版<code>axios</code></p><h2 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h2><p>首先看看目录结构</p><p> <img src="https://static.vue-js.com/9d90eaa0-48b6-11eb-85f6-6fac77c0c9b3.png"></p><p><code>axios</code>发送请求有很多实现的方法，实现入口文件为<code>axios.js </code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createInstance</span>(<span class="params">defaultConfig</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> context = <span class="keyword">new</span> <span class="title class_">Axios</span>(defaultConfig);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// instance指向了request方法，且上下文指向context，所以可以直接以 instance(option) 方式调用 </span></span><br><span class="line">  <span class="comment">// Axios.prototype.request 内对第一个参数的数据类型判断，使我们能够以 instance(url, option) 方式调用</span></span><br><span class="line">  <span class="keyword">var</span> instance = <span class="title function_">bind</span>(<span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span>, context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把Axios.prototype上的方法扩展到instance对象上，</span></span><br><span class="line">  <span class="comment">// 并指定上下文为context，这样执行Axios原型链上的方法时，this会指向context</span></span><br><span class="line">  utils.<span class="title function_">extend</span>(instance, <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>, context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy context to instance</span></span><br><span class="line">  <span class="comment">// 把context对象上的自身属性和方法扩展到instance上</span></span><br><span class="line">  <span class="comment">// 注：因为extend内部使用的forEach方法对对象做for in 遍历时，只遍历对象本身的属性，而不会遍历原型链上的属性</span></span><br><span class="line">  <span class="comment">// 这样，instance 就有了  defaults、interceptors 属性。</span></span><br><span class="line">  utils.<span class="title function_">extend</span>(instance, context);</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the default instance to be exported 创建一个由默认配置生成的axios实例</span></span><br><span class="line"><span class="keyword">var</span> axios = <span class="title function_">createInstance</span>(defaults);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Factory for creating new instances 扩展axios.create工厂函数，内部也是 createInstance</span></span><br><span class="line">axios.<span class="property">create</span> = <span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">instanceConfig</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createInstance</span>(<span class="title function_">mergeConfig</span>(axios.<span class="property">defaults</span>, instanceConfig));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Expose all/spread</span></span><br><span class="line">axios.<span class="property">all</span> = <span class="keyword">function</span> <span class="title function_">all</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(promises);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">axios.<span class="property">spread</span> = <span class="keyword">function</span> <span class="title function_">spread</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">wrap</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> callback.<span class="title function_">apply</span>(<span class="literal">null</span>, arr);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = axios;</span><br></pre></td></tr></table></figure><p>主要核心是 <code>Axios.prototype.request</code>，各种请求方式的调用实现都是在 <code>request</code> 内部实现的， 简单看下 <code>request</code> 的逻辑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span> = <span class="keyword">function</span> <span class="title function_">request</span>(<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="comment">// Allow for axios(&#x27;example/url&#x27;[, config]) a la fetch API</span></span><br><span class="line">  <span class="comment">// 判断 config 参数是否是 字符串，如果是则认为第一个参数是 URL，第二个参数是真正的config</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> config === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    config = <span class="variable language_">arguments</span>[<span class="number">1</span>] || &#123;&#125;;</span><br><span class="line">    <span class="comment">// 把 url 放置到 config 对象中，便于之后的 mergeConfig</span></span><br><span class="line">    config.<span class="property">url</span> = <span class="variable language_">arguments</span>[<span class="number">0</span>];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 config 参数是否是 字符串，则整体都当做config</span></span><br><span class="line">    config = config || &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 合并默认配置和传入的配置</span></span><br><span class="line">  config = <span class="title function_">mergeConfig</span>(<span class="variable language_">this</span>.<span class="property">defaults</span>, config);</span><br><span class="line">  <span class="comment">// 设置请求方法</span></span><br><span class="line">  config.<span class="property">method</span> = config.<span class="property">method</span> ? config.<span class="property">method</span>.<span class="title function_">toLowerCase</span>() : <span class="string">&#x27;get&#x27;</span>;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    something... 此部分会在后续拦截器单独讲述</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Axios 原型上挂载 &#x27;delete&#x27;, &#x27;get&#x27;, &#x27;head&#x27;, &#x27;options&#x27; 且不传参的请求方法，实现内部也是 request</span></span><br><span class="line">utils.<span class="title function_">forEach</span>([<span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;head&#x27;</span>, <span class="string">&#x27;options&#x27;</span>], <span class="keyword">function</span> <span class="title function_">forEachMethodNoData</span>(<span class="params">method</span>) &#123;</span><br><span class="line">  <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>[method] = <span class="keyword">function</span>(<span class="params">url, config</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(utils.<span class="title function_">merge</span>(config || &#123;&#125;, &#123;</span><br><span class="line">      <span class="attr">method</span>: method,</span><br><span class="line">      <span class="attr">url</span>: url</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Axios 原型上挂载 &#x27;post&#x27;, &#x27;put&#x27;, &#x27;patch&#x27; 且传参的请求方法，实现内部同样也是 request</span></span><br><span class="line">utils.<span class="title function_">forEach</span>([<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;put&#x27;</span>, <span class="string">&#x27;patch&#x27;</span>], <span class="keyword">function</span> <span class="title function_">forEachMethodWithData</span>(<span class="params">method</span>) &#123;</span><br><span class="line">  <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>[method] = <span class="keyword">function</span>(<span class="params">url, data, config</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(utils.<span class="title function_">merge</span>(config || &#123;&#125;, &#123;</span><br><span class="line">      <span class="attr">method</span>: method,</span><br><span class="line">      <span class="attr">url</span>: url,</span><br><span class="line">      <span class="attr">data</span>: data</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>request</code>入口参数为<code>config</code>，可以说<code>config</code>贯彻了<code>axios</code>的一生</p><p><code>axios</code> 中的 <code>config </code>主要分布在这几个地方：</p><ul><li>默认配置 <code>defaults.js</code></li><li><code>config.method</code>默认为 <code>get</code></li><li>调用 <code>createInstance</code> 方法创建 <code>axios </code>实例，传入的<code>config</code></li><li>直接或间接调用 <code>request</code> 方法，传入的 <code>config</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// axios.js</span></span><br><span class="line"><span class="comment">// 创建一个由默认配置生成的axios实例</span></span><br><span class="line"><span class="keyword">var</span> axios = <span class="title function_">createInstance</span>(defaults);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展axios.create工厂函数，内部也是 createInstance</span></span><br><span class="line">axios.<span class="property">create</span> = <span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">instanceConfig</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createInstance</span>(<span class="title function_">mergeConfig</span>(axios.<span class="property">defaults</span>, instanceConfig));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Axios.js</span></span><br><span class="line"><span class="comment">// 合并默认配置和传入的配置</span></span><br><span class="line">config = <span class="title function_">mergeConfig</span>(<span class="variable language_">this</span>.<span class="property">defaults</span>, config);</span><br><span class="line"><span class="comment">// 设置请求方法</span></span><br><span class="line">config.<span class="property">method</span> = config.<span class="property">method</span> ? config.<span class="property">method</span>.<span class="title function_">toLowerCase</span>() : <span class="string">&#x27;get&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从源码中，可以看到优先级：默认配置对象<code>default</code> &lt; <code>method:get</code> &lt; <code>Axios</code>的实例属性<code>this.default</code> &lt; <code>request</code>参数</p><p>下面重点看看<code>request</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span> = <span class="keyword">function</span> <span class="title function_">request</span>(<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    先是 mergeConfig ... 等，不再阐述</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// Hook up interceptors middleware 创建拦截器链. dispatchRequest 是重中之重，后续重点</span></span><br><span class="line">  <span class="keyword">var</span> chain = [dispatchRequest, <span class="literal">undefined</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// push各个拦截器方法 注意：interceptor.fulfilled 或 interceptor.rejected 是可能为undefined</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> <span class="title function_">unshiftRequestInterceptors</span>(<span class="params">interceptor</span>) &#123;</span><br><span class="line">    <span class="comment">// 请求拦截器逆序 注意此处的 forEach 是自定义的拦截器的forEach方法</span></span><br><span class="line">    chain.<span class="title function_">unshift</span>(interceptor.<span class="property">fulfilled</span>, interceptor.<span class="property">rejected</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> <span class="title function_">pushResponseInterceptors</span>(<span class="params">interceptor</span>) &#123;</span><br><span class="line">    <span class="comment">// 响应拦截器顺序 注意此处的 forEach 是自定义的拦截器的forEach方法</span></span><br><span class="line">    chain.<span class="title function_">push</span>(interceptor.<span class="property">fulfilled</span>, interceptor.<span class="property">rejected</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化一个promise对象，状态为resolved，接收到的参数为已经处理合并过的config对象</span></span><br><span class="line">  <span class="keyword">var</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(config);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环拦截器的链</span></span><br><span class="line">  <span class="keyword">while</span> (chain.<span class="property">length</span>) &#123;</span><br><span class="line">    promise = promise.<span class="title function_">then</span>(chain.<span class="title function_">shift</span>(), chain.<span class="title function_">shift</span>()); <span class="comment">// 每一次向外弹出拦截器</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回 promise</span></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>拦截器<code>interceptors</code>是在构建<code>axios</code>实例化的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Axios</span>(<span class="params">instanceConfig</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">defaults</span> = instanceConfig;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">interceptors</span> = &#123;</span><br><span class="line">    <span class="attr">request</span>: <span class="keyword">new</span> <span class="title class_">InterceptorManager</span>(), <span class="comment">// 请求拦截</span></span><br><span class="line">    <span class="attr">response</span>: <span class="keyword">new</span> <span class="title class_">InterceptorManager</span>() <span class="comment">// 响应拦截</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>InterceptorManager</code>构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拦截器的初始化 其实就是一组钩子函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">InterceptorManager</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">handlers</span> = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用拦截器实例的use时就是往钩子函数中push方法</span></span><br><span class="line"><span class="title class_">InterceptorManager</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">use</span> = <span class="keyword">function</span> <span class="title function_">use</span>(<span class="params">fulfilled, rejected</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">fulfilled</span>: fulfilled,</span><br><span class="line">    <span class="attr">rejected</span>: rejected</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截器是可以取消的，根据use的时候返回的ID，把某一个拦截器方法置为null</span></span><br><span class="line"><span class="comment">// 不能用 splice 或者 slice 的原因是 删除之后 id 就会变化，导致之后的顺序或者是操作不可控</span></span><br><span class="line"><span class="title class_">InterceptorManager</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eject</span> = <span class="keyword">function</span> <span class="title function_">eject</span>(<span class="params">id</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">handlers</span>[id]) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handlers</span>[id] = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这就是在 Axios的request方法中 中循环拦截器的方法 forEach 循环执行钩子函数</span></span><br><span class="line"><span class="title class_">InterceptorManager</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span> = <span class="keyword">function</span> <span class="title function_">forEach</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  utils.<span class="title function_">forEach</span>(<span class="variable language_">this</span>.<span class="property">handlers</span>, <span class="keyword">function</span> <span class="title function_">forEachHandler</span>(<span class="params">h</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (h !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="title function_">fn</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求拦截器方法是被 <code>unshift</code>到拦截器中，响应拦截器是被<code>push</code>到拦截器中的。最终它们会拼接上一个叫<code>dispatchRequest</code>的方法被后续的 <code>promise</code> 顺序执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> utils = <span class="built_in">require</span>(<span class="string">&#x27;./../utils&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> transformData = <span class="built_in">require</span>(<span class="string">&#x27;./transformData&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> isCancel = <span class="built_in">require</span>(<span class="string">&#x27;../cancel/isCancel&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> defaults = <span class="built_in">require</span>(<span class="string">&#x27;../defaults&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> isAbsoluteURL = <span class="built_in">require</span>(<span class="string">&#x27;./../helpers/isAbsoluteURL&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> combineURLs = <span class="built_in">require</span>(<span class="string">&#x27;./../helpers/combineURLs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断请求是否已被取消，如果已经被取消，抛出已取消</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throwIfCancellationRequested</span>(<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (config.<span class="property">cancelToken</span>) &#123;</span><br><span class="line">    config.<span class="property">cancelToken</span>.<span class="title function_">throwIfRequested</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> <span class="title function_">dispatchRequest</span>(<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="title function_">throwIfCancellationRequested</span>(config);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果包含baseUrl, 并且不是config.url绝对路径，组合baseUrl以及config.url</span></span><br><span class="line">  <span class="keyword">if</span> (config.<span class="property">baseURL</span> &amp;&amp; !<span class="title function_">isAbsoluteURL</span>(config.<span class="property">url</span>)) &#123;</span><br><span class="line">    <span class="comment">// 组合baseURL与url形成完整的请求路径</span></span><br><span class="line">    config.<span class="property">url</span> = <span class="title function_">combineURLs</span>(config.<span class="property">baseURL</span>, config.<span class="property">url</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  config.<span class="property">headers</span> = config.<span class="property">headers</span> || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用/lib/defaults.js中的transformRequest方法，对config.headers和config.data进行格式化</span></span><br><span class="line">  <span class="comment">// 比如将headers中的Accept，Content-Type统一处理成大写</span></span><br><span class="line">  <span class="comment">// 比如如果请求正文是一个Object会格式化为JSON字符串，并添加application/json;charset=utf-8的Content-Type</span></span><br><span class="line">  <span class="comment">// 等一系列操作</span></span><br><span class="line">  config.<span class="property">data</span> = <span class="title function_">transformData</span>(</span><br><span class="line">    config.<span class="property">data</span>,</span><br><span class="line">    config.<span class="property">headers</span>,</span><br><span class="line">    config.<span class="property">transformRequest</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 合并不同配置的headers，config.headers的配置优先级更高</span></span><br><span class="line">  config.<span class="property">headers</span> = utils.<span class="title function_">merge</span>(</span><br><span class="line">    config.<span class="property">headers</span>.<span class="property">common</span> || &#123;&#125;,</span><br><span class="line">    config.<span class="property">headers</span>[config.<span class="property">method</span>] || &#123;&#125;,</span><br><span class="line">    config.<span class="property">headers</span> || &#123;&#125;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除headers中的method属性</span></span><br><span class="line">  utils.<span class="title function_">forEach</span>(</span><br><span class="line">    [<span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;head&#x27;</span>, <span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;put&#x27;</span>, <span class="string">&#x27;patch&#x27;</span>, <span class="string">&#x27;common&#x27;</span>],</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">cleanHeaderConfig</span>(<span class="params">method</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> config.<span class="property">headers</span>[method];</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果config配置了adapter，使用config中配置adapter的替代默认的请求方法</span></span><br><span class="line">  <span class="keyword">var</span> adapter = config.<span class="property">adapter</span> || defaults.<span class="property">adapter</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用adapter方法发起请求（adapter根据浏览器环境或者Node环境会有不同）</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">adapter</span>(config).<span class="title function_">then</span>(</span><br><span class="line">    <span class="comment">// 请求正确返回的回调</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">onAdapterResolution</span>(<span class="params">response</span>) &#123;</span><br><span class="line">      <span class="comment">// 判断是否以及取消了请求，如果取消了请求抛出以取消</span></span><br><span class="line">      <span class="title function_">throwIfCancellationRequested</span>(config);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 使用/lib/defaults.js中的transformResponse方法，对服务器返回的数据进行格式化</span></span><br><span class="line">      <span class="comment">// 例如，使用JSON.parse对响应正文进行解析</span></span><br><span class="line">      response.<span class="property">data</span> = <span class="title function_">transformData</span>(</span><br><span class="line">        response.<span class="property">data</span>,</span><br><span class="line">        response.<span class="property">headers</span>,</span><br><span class="line">        config.<span class="property">transformResponse</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 请求失败的回调</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">onAdapterRejection</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">isCancel</span>(reason)) &#123;</span><br><span class="line">        <span class="title function_">throwIfCancellationRequested</span>(config);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (reason &amp;&amp; reason.<span class="property">response</span>) &#123;</span><br><span class="line">          reason.<span class="property">response</span>.<span class="property">data</span> = <span class="title function_">transformData</span>(</span><br><span class="line">            reason.<span class="property">response</span>.<span class="property">data</span>,</span><br><span class="line">            reason.<span class="property">response</span>.<span class="property">headers</span>,</span><br><span class="line">            config.<span class="property">transformResponse</span></span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(reason);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再来看看<code>axios</code>是如何实现取消请求的，实现文件在<code>CancelToken.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">CancelToken</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> executor !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;executor must be a function.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在 CancelToken 上定义一个 pending 状态的 promise ，将 resolve 回调赋值给外部变量 resolvePromise</span></span><br><span class="line">  <span class="keyword">var</span> resolvePromise;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">promise</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> <span class="title function_">promiseExecutor</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">    resolvePromise = resolve;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> token = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 立即执行 传入的 executor函数，将真实的 cancel 方法通过参数传递出去。</span></span><br><span class="line">  <span class="comment">// 一旦调用就执行 resolvePromise 即前面的 promise 的 resolve，就更改promise的状态为 resolve。</span></span><br><span class="line">  <span class="comment">// 那么xhr中定义的 CancelToken.promise.then方法就会执行, 从而xhr内部会取消请求</span></span><br><span class="line">  <span class="title function_">executor</span>(<span class="keyword">function</span> <span class="title function_">cancel</span>(<span class="params">message</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断请求是否已经取消过，避免多次执行</span></span><br><span class="line">    <span class="keyword">if</span> (token.<span class="property">reason</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    token.<span class="property">reason</span> = <span class="keyword">new</span> <span class="title class_">Cancel</span>(message);</span><br><span class="line">    <span class="title function_">resolvePromise</span>(token.<span class="property">reason</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">CancelToken</span>.<span class="property">source</span> = <span class="keyword">function</span> <span class="title function_">source</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// source 方法就是返回了一个 CancelToken 实例，与直接使用 new CancelToken 是一样的操作</span></span><br><span class="line">  <span class="keyword">var</span> cancel;</span><br><span class="line">  <span class="keyword">var</span> token = <span class="keyword">new</span> <span class="title class_">CancelToken</span>(<span class="keyword">function</span> <span class="title function_">executor</span>(<span class="params">c</span>) &#123;</span><br><span class="line">    cancel = c;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 返回创建的 CancelToken 实例以及取消方法</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">token</span>: token,</span><br><span class="line">    <span class="attr">cancel</span>: cancel</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实际上取消请求的操作是在 <code>xhr.js</code> 中也有响应的配合的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (config.<span class="property">cancelToken</span>) &#123;</span><br><span class="line">    config.<span class="property">cancelToken</span>.<span class="property">promise</span>.<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">onCanceled</span>(<span class="params">cancel</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!request) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取消请求</span></span><br><span class="line">        request.<span class="title function_">abort</span>();</span><br><span class="line">        <span class="title function_">reject</span>(cancel);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>巧妙的地方在 <code>CancelToken</code>中 <code>executor</code> 函数，通过<code>resolve</code>函数的传递与执行，控制<code>promise</code>的状态</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p> <img src="https://static.vue-js.com/b1d2ebd0-48b6-11eb-ab90-d9ae814b240d.png"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6856706569263677447#heading-4">https://juejin.cn/post/6856706569263677447#heading-4</a></li><li><a href="https://juejin.cn/post/6844903907500490766">https://juejin.cn/post/6844903907500490766</a></li><li><a href="https://github.com/axios/axios">https://github.com/axios/axios</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://static.vue-js.com/1564f7d0-4662-11eb-ab90-d9ae814b240d.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、axios的使用&quot;&gt;&lt;a href=&quot;#一、axios的使用&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="Vue" scheme="https://blogmind.cloud/categories/Vue/"/>
    
    
    <category term="面试" scheme="https://blogmind.cloud/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://blogmind.cloud/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>双向数据绑定是什么</title>
    <link href="https://blogmind.cloud/2025/02/02/vue-bind/"/>
    <id>https://blogmind.cloud/2025/02/02/vue-bind/</id>
    <published>2025-02-02T08:00:00.000Z</published>
    <updated>2025-02-08T06:49:30.088Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.vue-js.com/cef7dcc0-3ac9-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1. 基本原理"></a>1. 基本原理</h2><p>双向绑定主要包含两个方向的数据同步：</p><ul><li>数据层（Model）到视图层（View）的绑定</li><li>视图层（View）到数据层（Model）的绑定</li></ul><h2 id="2-实现机制"><a href="#2-实现机制" class="headerlink" title="2. 实现机制"></a>2. 实现机制</h2><p>主要通过三个重要部分实现：</p><ol><li><strong>数据劫持（Observer）</strong></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 Object.defineProperty 实现数据劫持</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, val</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>();</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 依赖收集</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">        dep.<span class="title function_">addDep</span>(<span class="title class_">Dep</span>.<span class="property">target</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newVal === val) <span class="keyword">return</span>;</span><br><span class="line">      val = newVal;</span><br><span class="line">      <span class="comment">// 通知所有依赖进行更新</span></span><br><span class="line">      dep.<span class="title function_">notify</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>依赖收集器（Dep）</strong></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = []; <span class="comment">// 存储所有的依赖</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addDep</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 通知所有依赖更新</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">sub</span>) =&gt;</span> sub.<span class="title function_">update</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>观察者（Watcher）</strong></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">vm, key, cb</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = key;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cb</span> = cb;</span><br><span class="line">    <span class="comment">// 触发 getter，进行依赖收集</span></span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span>[<span class="variable language_">this</span>.<span class="property">key</span>];</span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 更新视图</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cb</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">vm</span>, <span class="variable language_">this</span>.<span class="property">vm</span>[<span class="variable language_">this</span>.<span class="property">key</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-工作流程"><a href="#3-工作流程" class="headerlink" title="3. 工作流程"></a>3. 工作流程</h2><ol><li><p><strong>初始化阶段</strong>：</p><ul><li>对数据进行劫持，设置 getter&#x2F;setter</li><li>编译模板，找到动态绑定的数据</li><li>创建 Watcher 实例</li></ul></li><li><p><strong>数据更新阶段</strong>：</p><ul><li>Model 更新：触发 setter → 通知依赖 → 更新 View</li><li>View 更新：触发事件 → 更新 Model → 触发 setter → 更新相关视图</li></ul></li></ol><h2 id="4-简单示例"><a href="#4-简单示例" class="headerlink" title="4. 简单示例"></a>4. 简单示例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">message</span>: <span class="string">&quot;Hello&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ol><li>当输入框的值改变时，会触发 setter，更新数据并通知相关依赖更新视图</li><li>当 message 数据改变时，会通过依赖通知机制更新显示的文本</li></ol><h2 id="5-Vue-3-的改进"><a href="#5-Vue-3-的改进" class="headerlink" title="5. Vue 3 的改进"></a>5. Vue 3 的改进</h2><p>Vue 3 使用 Proxy 替代了 Object.defineProperty，提供了更好的性能和功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue 3 的响应式实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">      <span class="comment">// 依赖收集</span></span><br><span class="line">      <span class="title function_">track</span>(target, key);</span><br><span class="line">      <span class="keyword">return</span> target[key];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, value</span>) &#123;</span><br><span class="line">      target[key] = value;</span><br><span class="line">      <span class="comment">// 触发更新</span></span><br><span class="line">      <span class="title function_">trigger</span>(target, key);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要优势：</p><ul><li>可以监听数组变化</li><li>可以监听对象属性的添加和删除</li><li>支持 Map、Set 等数据结构</li><li>性能更好，不需要递归遍历对象</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li><p>性能考虑：</p><ul><li>不要在大型数组或对象上使用双向绑定</li><li>使用 v-once 处理静态内容</li><li>合理使用计算属性和侦听器</li></ul></li><li><p>可能的问题：</p><ul><li>数据量大时可能会有性能问题</li><li>复杂的双向绑定可能导致数据流向难以追踪</li><li>需要考虑内存泄漏问题</li></ul></li></ol><p>理解双向绑定的原理对于更好地使用框架和优化应用性能非常重要。在实际开发中，我们通常不需要自己实现双向绑定，但了解其原理有助于我们更好地使用和调试应用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://static.vue-js.com/cef7dcc0-3ac9-11eb-85f6-6fac77c0c9b3.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-基本原理&quot;&gt;&lt;a href=&quot;#1-基本原理&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="Vue" scheme="https://blogmind.cloud/categories/Vue/"/>
    
    
    <category term="面试" scheme="https://blogmind.cloud/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://blogmind.cloud/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue3.0的设计目标是什么？做了哪些优化</title>
    <link href="https://blogmind.cloud/2025/01/31/vue3-goal/"/>
    <id>https://blogmind.cloud/2025/01/31/vue3-goal/</id>
    <published>2025-01-31T08:00:00.000Z</published>
    <updated>2025-02-08T06:49:30.106Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.vue-js.com/b93b49c0-5c58-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="一、设计目标"><a href="#一、设计目标" class="headerlink" title="一、设计目标"></a>一、设计目标</h2><p>不以解决实际业务痛点的更新都是耍流氓，下面我们来列举一下<code>Vue3</code>之前我们或许会面临的问题</p><ul><li><p>随着功能的增长，复杂组件的代码变得越来越难以维护</p></li><li><p>缺少一种比较「干净」的在多个组件之间提取和复用逻辑的机制</p></li><li><p>类型推断不够友好</p></li><li><p><code>bundle</code>的时间太久了</p></li></ul><p>而 <code>Vue3</code> 经过长达两三年时间的筹备，做了哪些事情？</p><p>我们从结果反推</p><ul><li>更小</li><li>更快</li><li>TypeScript支持</li><li>API设计一致性</li><li>提高自身可维护性</li><li>开放更多底层功能</li></ul><p>一句话概述，就是更小更快更友好了</p><h3 id="更小"><a href="#更小" class="headerlink" title="更小"></a>更小</h3><p><code>Vue3</code>移除一些不常用的 <code>API</code></p><p>引入<code>tree-shaking</code>，可以将无用模块“剪辑”，仅打包需要的，使打包的整体体积变小了</p><h3 id="更快"><a href="#更快" class="headerlink" title="更快"></a>更快</h3><p>主要体现在编译方面：</p><ul><li>diff算法优化</li><li>静态提升</li><li>事件监听缓存</li><li>SSR优化</li></ul><p>下篇文章我们会进一步介绍</p><h3 id="更友好"><a href="#更友好" class="headerlink" title="更友好"></a>更友好</h3><p><code>vue3</code>在兼顾<code>vue2</code>的<code>options API</code>的同时还推出了<code>composition API</code>，大大增加了代码的逻辑组织和代码复用能力</p><p>这里代码简单演示下：</p><p>存在一个获取鼠标位置的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toRefs, reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useMouse</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">update</span> = e=&gt;&#123;</span><br><span class="line">        state.<span class="property">x</span> = e.<span class="property">pageX</span>;</span><br><span class="line">        state.<span class="property">y</span> = e.<span class="property">pageY</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,update);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">onUnmounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,update);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">toRefs</span>(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要调用这个函数，即可获取<code>x</code>、<code>y</code>的坐标，完全不用关注实现过程</p><p>试想一下，如果很多类似的第三方库，我们只需要调用即可，不必关注实现过程，开发效率大大提高</p><p>同时，<code>VUE3</code>是基于<code>typescipt</code>编写的，可以享受到自动的类型定义提示</p><h2 id="三、优化方案"><a href="#三、优化方案" class="headerlink" title="三、优化方案"></a>三、优化方案</h2><p><code>vue3</code>从很多层面都做了优化，可以分成三个方面：</p><ul><li>源码</li><li>性能</li><li>语法 API</li></ul><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>源码可以从两个层面展开：</p><ul><li>源码管理</li><li>TypeScript</li></ul><h4 id="源码管理"><a href="#源码管理" class="headerlink" title="源码管理"></a>源码管理</h4><p><code>vue3</code>整个源码是通过 <code>monorepo </code>的方式维护的，根据功能将不同的模块拆分到<code>packages </code>目录下面不同的子目录中</p><p> <img src="https://static.vue-js.com/d7c32520-5c58-11eb-ab90-d9ae814b240d.png"></p><p>这样使得模块拆分更细化，职责划分更明确，模块之间的依赖关系也更加明确，开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性</p><p>另外一些 <code>package</code>（比如 <code>reactivity</code> 响应式库）是可以独立于 <code>Vue</code> 使用的，这样用户如果只想使用 <code>Vue3 </code>的响应式能力，可以单独依赖这个响应式库而不用去依赖整个 <code>Vue</code></p><h4 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h4><p><code>Vue3</code>是基于<code>typeScript</code>编写的，提供了更好的类型检查，能支持复杂的类型推导</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p><code>vue3</code>是从什么哪些方面对性能进行进一步优化呢？</p><ul><li>体积优化</li><li>编译优化</li><li>数据劫持优化</li></ul><p>这里讲述数据劫持：</p><p>在<code>vue2</code>中，数据劫持是通过<code>Object.defineProperty </code>，这个 API 有一些缺陷，并不能检测对象属性的添加和删除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, <span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// track</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// trigger</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>尽管<code> Vue</code>为了解决这个问题提供了 <code>set </code>和<code>delete </code>实例方法，但是对于用户来说，还是增加了一定的心智负担</p><p>同时在面对嵌套层级比较深的情况下，就存在性能问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: &#123;</span><br><span class="line">      <span class="attr">b</span>: &#123;</span><br><span class="line">          <span class="attr">c</span>: &#123;</span><br><span class="line">          <span class="attr">d</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比之下，<code>vue3</code>是通过<code>proxy</code>监听整个对象，那么对于删除还是监听当然也能监听到</p><p>同时<code>Proxy </code> 并不能监听到内部深层次的对象变化，而 <code>Vue3</code> 的处理方式是在<code> getter</code> 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归</p><h3 id="语法-API"><a href="#语法-API" class="headerlink" title="语法 API"></a>语法 API</h3><p>这里当然说的就是<code>composition API</code>，其两大显著的优化：</p><ul><li>优化逻辑组织</li><li>优化逻辑复用</li></ul><h4 id="逻辑组织"><a href="#逻辑组织" class="headerlink" title="逻辑组织"></a>逻辑组织</h4><p>一张图，我们可以很直观地感受到 <code>Composition API </code>在逻辑组织方面的优势</p><p> <img src="https://static.vue-js.com/e5804bc0-5c58-11eb-85f6-6fac77c0c9b3.png"></p><p>相同功能的代码编写在一块，而不像<code>options API</code>那样，各个功能的代码混成一块</p><h4 id="逻辑复用"><a href="#逻辑复用" class="headerlink" title="逻辑复用"></a>逻辑复用</h4><p>在<code>vue2</code>中，我们是通过<code>mixin</code>实现功能混合，如果多个<code>mixin</code>混合，会存在两个非常明显的问题：命名冲突和数据来源不清晰</p><p>而通过<code>composition</code>这种形式，可以将一些复用的代码抽离出来作为一个函数，只要的使用的地方直接进行调用即可</p><p>同样是上文的获取鼠标位置的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toRefs, reactive, onUnmounted, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useMouse</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">update</span> = e=&gt;&#123;</span><br><span class="line">        state.<span class="property">x</span> = e.<span class="property">pageX</span>;</span><br><span class="line">        state.<span class="property">y</span> = e.<span class="property">pageY</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,update);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">onUnmounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,update);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">toRefs</span>(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> useMousePosition <span class="keyword">from</span> <span class="string">&#x27;./mouse&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; x, y &#125; = <span class="title function_">useMousePosition</span>()</span><br><span class="line">        <span class="keyword">return</span> &#123; x, y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，整个数据来源清晰了，即使去编写更多的<code>hook</code>函数，也不会出现命名冲突的问题</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6850418112878575629#heading-5">https://juejin.cn/post/6850418112878575629#heading-5</a></li><li><a href="https://vue3js.cn/docs/zh">https://vue3js.cn/docs/zh</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://static.vue-js.com/b93b49c0-5c58-11eb-85f6-6fac77c0c9b3.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、设计目标&quot;&gt;&lt;a href=&quot;#一、设计目标&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="Vue" scheme="https://blogmind.cloud/categories/Vue/"/>
    
    
    <category term="面试" scheme="https://blogmind.cloud/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://blogmind.cloud/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</title>
    <link href="https://blogmind.cloud/2025/01/30/vue3-composition/"/>
    <id>https://blogmind.cloud/2025/01/30/vue3-composition/</id>
    <published>2025-01-30T08:00:00.000Z</published>
    <updated>2025-02-08T06:49:30.106Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="https://static.vue-js.com/8d6dd7b0-6048-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p><code>Composition API</code> 可以说是<code>Vue3</code>的最大特点，那么为什么要推出<code>Composition Api</code>，解决了什么问题？</p><p>通常使用<code>Vue2</code>开发的项目，普遍会存在以下问题：</p><ul><li>代码的可读性随着组件变大而变差</li><li>每一种代码复用的方式，都存在缺点</li><li>TypeScript支持有限</li></ul><p>以上通过使用<code>Composition Api</code>都能迎刃而解</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="一、Options-Api"><a href="#一、Options-Api" class="headerlink" title="一、Options Api"></a>一、Options Api</h3><p><code>Options API</code>，即大家常说的选项API，即以<code>vue</code>为后缀的文件，通过定义<code>methods</code>，<code>computed</code>，<code>watch</code>，<code>data</code>等属性与方法，共同处理页面逻辑</p><p>如下图：</p><p> <img src="https://static.vue-js.com/9bf6d9d0-6048-11eb-85f6-6fac77c0c9b3.png"></p><p>可以看到<code>Options</code>代码编写方式，如果是组件状态，则写在<code>data</code>属性上，如果是方法，则写在<code>methods</code>属性上…</p><p>用组件的选项 (<code>data</code>、<code>computed</code>、<code>methods</code>、<code>watch</code>) 组织逻辑在大多数情况下都有效</p><p>然而，当组件变得复杂，导致对应属性的列表也会增长，这可能会导致组件难以阅读和理解</p><h3 id="二、Composition-Api"><a href="#二、Composition-Api" class="headerlink" title="二、Composition Api"></a>二、Composition Api</h3><p>在 Vue3 Composition API 中，组件根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）</p><p>即使项目很大，功能很多，我们都能快速的定位到这个功能所用到的所有 API</p><p> <img src="https://static.vue-js.com/acee9200-6048-11eb-ab90-d9ae814b240d.png"></p><h3 id="三、对比"><a href="#三、对比" class="headerlink" title="三、对比"></a>三、对比</h3><p>下面对<code>Composition Api </code>与<code>Options Api</code>进行两大方面的比较</p><ul><li>逻辑组织</li><li>逻辑复用</li></ul><h4 id="逻辑组织"><a href="#逻辑组织" class="headerlink" title="逻辑组织"></a>逻辑组织</h4><h5 id="Options-API"><a href="#Options-API" class="headerlink" title="Options API"></a>Options API</h5><p>假设一个组件是一个大型组件，其内部有很多处理逻辑关注点（对应下图不用颜色）</p><p> <img src="https://static.vue-js.com/dc83d070-6048-11eb-ab90-d9ae814b240d.png"></p><p>可以看到，这种碎片化使得理解和维护复杂组件变得困难</p><p>选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块</p><h5 id="Compostion-API"><a href="#Compostion-API" class="headerlink" title="Compostion API"></a>Compostion API</h5><p>而<code>Compositon API</code>正是解决上述问题，将某个逻辑关注点相关的代码全都放在一个函数里，这样当需要修改一个功能时，就不再需要在文件中跳来跳去</p><p>下面举个简单例子，将处理<code>count</code>属性相关的代码放在同一个函数了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="title function_">ref</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> double = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count.<span class="property">value</span> * <span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleConut</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        count.<span class="property">value</span> = count.<span class="property">value</span> * <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        count,</span><br><span class="line">        double,</span><br><span class="line">        handleConut,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件上中使用<code>count</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; count, double, handleConut &#125; = <span class="title function_">useCount</span>();</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            count,</span><br><span class="line">            double,</span><br><span class="line">            handleConut</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>再来一张图进行对比，可以很直观地感受到 <code>Composition API </code>在逻辑组织方面的优势，以后修改一个属性功能的时候，只需要跳到控制该属性的方法中即可</p><p><img src="https://static.vue-js.com/e5804bc0-5c58-11eb-85f6-6fac77c0c9b3.png"></p><h4 id="逻辑复用"><a href="#逻辑复用" class="headerlink" title="逻辑复用"></a>逻辑复用</h4><p>在<code>Vue2</code>中，我们是用过<code>mixin</code>去复用相同的逻辑</p><p>下面举个例子，我们会另起一个<code>mixin.js</code>文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">MoveMixin</span> = &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">handleKeyup</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">code</span>);</span><br><span class="line">      <span class="comment">// 上下左右 x y</span></span><br><span class="line">      <span class="keyword">switch</span> (e.<span class="property">code</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowUp&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">y</span>--;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowDown&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">y</span>++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowLeft&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">x</span>--;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowRight&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">x</span>++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;keyup&quot;</span>, <span class="variable language_">this</span>.<span class="property">handleKeyup</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">unmounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;keyup&quot;</span>, <span class="variable language_">this</span>.<span class="property">handleKeyup</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在组件中使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> mousePositionMixin <span class="keyword">from</span> <span class="string">&#x27;./mouse&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">mixins</span>: [mousePositionMixin]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>使用单个<code>mixin</code>似乎问题不大，但是当我们一个组件混入大量不同的 <code>mixins</code> 的时候</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mixins</span>: [mousePositionMixin, fooMixin, barMixin, otherMixin]</span><br></pre></td></tr></table></figure><p>会存在两个非常明显的问题：</p><ul><li>命名冲突</li><li>数据来源不清晰</li></ul><p>现在通过<code>Compositon API</code>这种方式改写上面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onMounted, onUnmounted, reactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useMove</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> position = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleKeyup</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">code</span>);</span><br><span class="line">    <span class="comment">// 上下左右 x y</span></span><br><span class="line">    <span class="keyword">switch</span> (e.<span class="property">code</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowUp&quot;</span>:</span><br><span class="line">        <span class="comment">// y.value--;</span></span><br><span class="line">        position.<span class="property">y</span>--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowDown&quot;</span>:</span><br><span class="line">        <span class="comment">// y.value++;</span></span><br><span class="line">        position.<span class="property">y</span>++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowLeft&quot;</span>:</span><br><span class="line">        <span class="comment">// x.value--;</span></span><br><span class="line">        position.<span class="property">x</span>--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowRight&quot;</span>:</span><br><span class="line">        <span class="comment">// x.value++;</span></span><br><span class="line">        position.<span class="property">x</span>++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;keyup&quot;</span>, handleKeyup);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;keyup&quot;</span>, handleKeyup);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; position &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件中使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; useMove &#125; <span class="keyword">from</span> <span class="string">&quot;./useMove&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> &#123; position &#125; = <span class="title function_">useMove</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> &#123; x, y &#125; = <span class="title function_">toRefs</span>(position);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      x,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      y,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>可以看到，整个数据来源清晰了，即使去编写更多的 hook 函数，也不会出现命名冲突的问题</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>在逻辑组织和逻辑复用方面，<code>Composition API</code>是优于<code>Options  API</code></li><li>因为<code>Composition API</code>几乎是函数，会有更好的类型推断。</li><li><code>Composition API </code>对 <code>tree-shaking</code> 友好，代码也更容易压缩</li><li><code>Composition API</code>中见不到<code>this</code>的使用，减少了<code>this</code>指向不明的情况</li><li>如果是小型组件，可以继续使用<code>Options API</code>，也是十分友好的</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;https://static.vue-js.com/8d6dd7b0-6048-11eb-85f6-6fac77c0c9b3.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Vue" scheme="https://blogmind.cloud/categories/Vue/"/>
    
    
    <category term="面试" scheme="https://blogmind.cloud/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://blogmind.cloud/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>用Vue3.0 写过组件吗？如果想实现一个 Modal你会怎么设计？</title>
    <link href="https://blogmind.cloud/2025/01/22/vue3-modal-component/"/>
    <id>https://blogmind.cloud/2025/01/22/vue3-modal-component/</id>
    <published>2025-01-22T08:00:00.000Z</published>
    <updated>2025-02-08T06:49:30.106Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="https://static.vue-js.com/e294c660-6370-11eb-ab90-d9ae814b240d.png"></p><h2 id="一、组件设计"><a href="#一、组件设计" class="headerlink" title="一、组件设计"></a>一、组件设计</h2><p>组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式</p><p>现在有一个场景，点击新增与编辑都弹框出来进行填写，功能上大同小异，可能只是标题内容或者是显示的主体内容稍微不同</p><p>这时候就没必要写两个组件，只需要根据传入的参数不同，组件显示不同内容即可</p><p>这样，下次开发相同界面程序时就可以写更少的代码，意义着更高的开发效率，更少的 <code>Bug </code>和更少的程序体积</p><h2 id="二、需求分析"><a href="#二、需求分析" class="headerlink" title="二、需求分析"></a>二、需求分析</h2><p>实现一个<code>Modal</code>组件，首先确定需要完成的内容：</p><ul><li><p>遮罩层</p></li><li><p>标题内容</p></li><li><p>主体内容</p></li><li><p>确定和取消按钮</p></li></ul><p>主体内容需要灵活，所以可以是字符串，也可以是一段 <code>html</code> 代码</p><p>特点是它们在当前<code>vue</code>实例之外独立存在，通常挂载于<code>body</code>之上</p><p>除了通过引入<code>import</code>的形式，我们还可通过<code>API</code>的形式进行组件的调用</p><p>还可以包括配置全局样式、国际化、与<code>typeScript</code>结合</p><h2 id="三、实现流程"><a href="#三、实现流程" class="headerlink" title="三、实现流程"></a>三、实现流程</h2><p>首先看看大致流程：</p><ul><li><p>目录结构</p></li><li><p>组件内容</p></li><li><p>实现 API 形式</p></li><li><p>事件处理</p></li><li><p>其他完善</p></li></ul><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p><code>Modal</code>组件相关的目录结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">├── plugins</span><br><span class="line">│   └── modal</span><br><span class="line">│       ├── Content.tsx // 维护 Modal 的内容，用于 h 函数和 jsx 语法</span><br><span class="line">│       ├── Modal.vue // 基础组件</span><br><span class="line">│       ├── config.ts // 全局默认配置</span><br><span class="line">│       ├── index.ts // 入口</span><br><span class="line">│       ├── locale // 国际化相关</span><br><span class="line">│       │   ├── index.ts</span><br><span class="line">│       │   └── lang</span><br><span class="line">│       │       ├── en-US.ts</span><br><span class="line">│       │       ├── zh-CN.ts</span><br><span class="line">│       │       └── zh-TW.ts</span><br><span class="line">│       └── modal.type.ts // ts类型声明相关</span><br></pre></td></tr></table></figure><p>因为 Modal 会被 <code>app.use(Modal)</code> 调用作为一个插件，所以都放在<code>plugins</code>目录下</p><h3 id="组件内容"><a href="#组件内容" class="headerlink" title="组件内容"></a>组件内容</h3><p>首先实现<code>modal.vue</code>的主体显示内容大致如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Teleport</span> <span class="attr">to</span>=<span class="string">&quot;body&quot;</span> <span class="attr">:disabled</span>=<span class="string">&quot;!isTeleport&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;modelValue&quot;</span> <span class="attr">class</span>=<span class="string">&quot;modal&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">             <span class="attr">class</span>=<span class="string">&quot;mask&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">:style</span>=<span class="string">&quot;style&quot;</span></span></span><br><span class="line"><span class="tag">             @<span class="attr">click</span>=<span class="string">&quot;maskClose &amp;&amp; !loading &amp;&amp; handleCancel()&quot;</span></span></span><br><span class="line"><span class="tag">             &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal__main&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal__title line line--b&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; title || t(&quot;r.title&quot;) &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">v-if</span>=<span class="string">&quot;close&quot;</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">:title</span>=<span class="string">&quot;t(&#x27;r.close&#x27;)&quot;</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">class</span>=<span class="string">&quot;close&quot;</span></span></span><br><span class="line"><span class="tag">                      @<span class="attr">click</span>=<span class="string">&quot;!loading &amp;&amp; handleCancel()&quot;</span></span></span><br><span class="line"><span class="tag">                      &gt;</span>✕&lt;/span</span><br><span class="line">                    &gt;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal__content&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Content</span> <span class="attr">v-if</span>=<span class="string">&quot;typeof content === &#x27;function&#x27;&quot;</span> <span class="attr">:render</span>=<span class="string">&quot;content&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">                    &#123;&#123; content &#125;&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal__btns line line--t&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">:disabled</span>=<span class="string">&quot;loading&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handleConfirm&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;loading&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;loading&quot;</span>&gt;</span> ❍ <span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#123;&#123; t(&quot;r.confirm&quot;) &#125;&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;!loading &amp;&amp; handleCancel()&quot;</span>&gt;</span></span><br><span class="line">                    &#123;&#123; t(&quot;r.cancel&quot;) &#125;&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Teleport</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最外层上通过Vue3 <code>Teleport</code> 内置组件进行包裹，其相当于传送门，将里面的内容传送至<code>body</code>之上</p><p>并且从<code>DOM</code>结构上来看，把<code>modal</code>该有的内容（遮罩层、标题、内容、底部按钮）都实现了</p><p>关于主体内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal__content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Content</span> <span class="attr">v-if</span>=<span class="string">&quot;typeof content===&#x27;function&#x27;&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">:render</span>=<span class="string">&quot;content&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">        &#123;&#123;content&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到根据传入<code>content</code>的类型不同，对应显示不同得到内容</p><p>最常见的则是通过调用字符串和默认插槽的形式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 默认插槽</span><br><span class="line"><span class="tag">&lt;<span class="name">Modal</span> <span class="attr">v-model</span>=<span class="string">&quot;show&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">title</span>=<span class="string">&quot;演示 slot&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello world~<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Modal</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 字符串</span><br><span class="line"><span class="tag">&lt;<span class="name">Modal</span> <span class="attr">v-model</span>=<span class="string">&quot;show&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">title</span>=<span class="string">&quot;演示 content&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">content</span>=<span class="string">&quot;hello world~&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>通过 API 形式调用<code>Modal</code>组件的时候，<code>content</code>可以使用下面两种</p><ul><li>h 函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$modal.<span class="title function_">show</span>(&#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;演示 h 函数&#x27;</span>,</span><br><span class="line">  <span class="title function_">content</span>(<span class="params">h</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">h</span>(</span><br><span class="line">      <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">style</span>: <span class="string">&#x27;color:red;&#x27;</span>,</span><br><span class="line">        <span class="attr">onClick</span>: <span class="function">(<span class="params">$event: Event</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;clicked&#x27;</span>, $event.<span class="property">target</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&#x27;hello world ~&#x27;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>JSX</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$modal.<span class="title function_">show</span>(&#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;演示 jsx 语法&#x27;</span>,</span><br><span class="line">  <span class="title function_">content</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClick</span>=<span class="string">&#123;($event:</span> <span class="attr">Event</span>) =&gt;</span> console.log(&#x27;clicked&#x27;, $event.target)&#125;</span></span><br><span class="line"><span class="language-xml">      &gt;</span></span><br><span class="line"><span class="language-xml">        hello world ~</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="实现-API-形式"><a href="#实现-API-形式" class="headerlink" title="实现 API 形式"></a>实现 API 形式</h3><p>那么组件如何实现<code>API</code>形式调用<code>Modal</code>组件呢？</p><p>在<code>Vue2</code>中，我们可以借助<code>Vue</code>实例以及<code>Vue.extend</code>的方式获得组件实例，然后挂载到<code>body</code>上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Modal</span> <span class="keyword">from</span> <span class="string">&#x27;./Modal.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ComponentClass</span> = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(<span class="title class_">Modal</span>);</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">ComponentClass</span>(&#123; <span class="attr">el</span>: <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>) &#125;);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(instance.<span class="property">$el</span>);</span><br></pre></td></tr></table></figure><p>虽然<code>Vue3</code>移除了<code>Vue.extend</code>方法，但可以通过<code>createVNode</code>实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Modal</span> <span class="keyword">from</span> <span class="string">&#x27;./Modal.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> vnode = <span class="title function_">createVNode</span>(<span class="title class_">Modal</span>);</span><br><span class="line"><span class="title function_">render</span>(vnode, container);</span><br><span class="line"><span class="keyword">const</span> instance = vnode.<span class="property">component</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(container);</span><br></pre></td></tr></table></figure><p>在<code>Vue2</code>中，可以通过<code>this</code>的形式调用全局 API</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">install</span>(<span class="params">vue</span>) &#123;</span><br><span class="line">       vue.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$create</span> = create</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在 Vue3 的 <code>setup</code> 中已经没有 <code>this </code>概念了，需要调用<code>app.config.globalProperties</code>挂载到全局</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">install</span>(<span class="params">app</span>) &#123;</span><br><span class="line">        app.<span class="property">config</span>.<span class="property">globalProperties</span>.<span class="property">$create</span> = create</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>下面再看看看<code>Modal</code>组件内部是如何处理「确定」「取消」事件的，既然是<code>Vue3</code>，当然采用<code>Compositon API</code> 形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Modal.vue</span></span><br><span class="line"><span class="title function_">setup</span>(<span class="params">props, ctx</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="title function_">getCurrentInstance</span>(); <span class="comment">// 获得当前组件实例</span></span><br><span class="line">  <span class="title function_">onBeforeMount</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    instance.<span class="property">_hub</span> = &#123;</span><br><span class="line">      <span class="string">&#x27;on-cancel&#x27;</span>: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">      <span class="string">&#x27;on-confirm&#x27;</span>: <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleConfirm</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    ctx.<span class="title function_">emit</span>(<span class="string">&#x27;on-confirm&#x27;</span>);</span><br><span class="line">    instance.<span class="property">_hub</span>[<span class="string">&#x27;on-confirm&#x27;</span>]();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleCancel</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    ctx.<span class="title function_">emit</span>(<span class="string">&#x27;on-cancel&#x27;</span>);</span><br><span class="line">    ctx.<span class="title function_">emit</span>(<span class="string">&#x27;update:modelValue&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">    instance.<span class="property">_hub</span>[<span class="string">&#x27;on-cancel&#x27;</span>]();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    handleConfirm,</span><br><span class="line">    handleCancel</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中，可以看得到除了使用传统<code>emit</code>的形式使父组件监听，还可通过<code>_hub</code>属性中添加 <code>on-cancel</code>，<code>on-confirm</code>方法实现在<code>API</code>中进行监听</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="property">config</span>.<span class="property">globalProperties</span>.<span class="property">$modal</span> = &#123;</span><br><span class="line">   <span class="title function_">show</span>(<span class="params">&#123;&#125;</span>) &#123;</span><br><span class="line">     <span class="comment">/* 监听 确定、取消 事件 */</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面再来目睹下<code>_hub</code>是如何实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.ts</span></span><br><span class="line">app.<span class="property">config</span>.<span class="property">globalProperties</span>.<span class="property">$modal</span> = &#123;</span><br><span class="line">    <span class="title function_">show</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">        /* 其他选项 */</span></span><br><span class="line"><span class="params">        onConfirm,</span></span><br><span class="line"><span class="params">        onCancel</span></span><br><span class="line"><span class="params">    &#125;</span>) &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> &#123; props, _hub &#125; = instance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">_closeModal</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">            props.<span class="property">modelValue</span> = <span class="literal">false</span>;</span><br><span class="line">            container.<span class="property">parentNode</span>!.<span class="title function_">removeChild</span>(container);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 往 _hub 新增事件的具体实现</span></span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">assign</span>(_hub, &#123;</span><br><span class="line">            <span class="keyword">async</span> <span class="string">&#x27;on-confirm&#x27;</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> (onConfirm) &#123;</span><br><span class="line">                <span class="keyword">const</span> fn = <span class="title function_">onConfirm</span>();</span><br><span class="line">                <span class="comment">// 当方法返回为 Promise</span></span><br><span class="line">                <span class="keyword">if</span> (fn &amp;&amp; fn.<span class="property">then</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        props.<span class="property">loading</span> = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">await</span> fn;</span><br><span class="line">                        props.<span class="property">loading</span> = <span class="literal">false</span>;</span><br><span class="line">                        <span class="title function_">_closeModal</span>();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                        <span class="comment">// 发生错误时，不关闭弹框</span></span><br><span class="line">                        <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">                        props.<span class="property">loading</span> = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="title function_">_closeModal</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">_closeModal</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">            <span class="string">&#x27;on-cancel&#x27;</span>() &#123;</span><br><span class="line">                onCancel &amp;&amp; <span class="title function_">onCancel</span>();</span><br><span class="line">                <span class="title function_">_closeModal</span>();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="其他完善"><a href="#其他完善" class="headerlink" title="其他完善"></a>其他完善</h3><p>关于组件实现国际化、与<code>typsScript</code>结合，大家可以根据自身情况在此基础上进行更改</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://segmentfault.com/a/1190000038928664">https://segmentfault.com/a/1190000038928664</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;https://static.vue-js.com/e294c660-6370-11eb-ab90-d9ae814b240d.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、组件设计&quot;&gt;&lt;a href=&quot;#一、组件设计&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Vue" scheme="https://blogmind.cloud/categories/Vue/"/>
    
    
    <category term="面试" scheme="https://blogmind.cloud/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://blogmind.cloud/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue中组件和插件有什么区别？</title>
    <link href="https://blogmind.cloud/2025/01/21/vue-components-plugin/"/>
    <id>https://blogmind.cloud/2025/01/21/vue-components-plugin/</id>
    <published>2025-01-21T08:00:00.000Z</published>
    <updated>2025-02-08T06:49:30.090Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.vue-js.com/683475e0-3acc-11eb-ab90-d9ae814b240d.png" alt="image.png"></p><h2 id="一、组件是什么"><a href="#一、组件是什么" class="headerlink" title="一、组件是什么"></a>一、组件是什么</h2><p>回顾以前对组件的定义：</p><p>组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在<code>Vue</code>中每一个<code>.vue</code>文件都可以视为一个组件</p><p>组件的优势</p><ul><li><p>降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现</p></li><li><p>调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单</p></li><li><p>提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级</p></li></ul><h2 id="二、插件是什么"><a href="#二、插件是什么" class="headerlink" title="二、插件是什么"></a>二、插件是什么</h2><p>插件通常用来为 <code>Vue</code> 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：</p><ul><li>添加全局方法或者属性。如: <code>vue-custom-element</code></li><li>添加全局资源：指令&#x2F;过滤器&#x2F;过渡等。如 <code>vue-touch</code></li><li>通过全局混入来添加一些组件选项。如<code> vue-router</code></li><li>添加 <code>Vue</code> 实例方法，通过把它们添加到 <code>Vue.prototype</code> 上实现。</li><li>一个库，提供自己的 <code>API</code>，同时提供上面提到的一个或多个功能。如<code> vue-router</code></li></ul><h2 id="三、两者的区别"><a href="#三、两者的区别" class="headerlink" title="三、两者的区别"></a>三、两者的区别</h2><p>两者的区别主要表现在以下几个方面：</p><ul><li>编写形式</li><li>注册形式</li><li>使用场景</li></ul><h3 id="编写形式"><a href="#编写形式" class="headerlink" title="编写形式"></a>编写形式</h3><h4 id="编写组件"><a href="#编写组件" class="headerlink" title="编写组件"></a>编写组件</h4><p>编写一个组件，可以有很多方式，我们最常见的就是<code>vue</code>单文件的这种格式，每一个<code>.vue</code>文件我们都可以看成是一个组件</p><p><code>vue</code>文件标准格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>我们还可以通过<code>template</code>属性来编写一个组件，如果组件内容多，我们可以在外部定义<code>template</code>组件内容，如果组件内容并不多，我们可直接写在<code>template</code>属性上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template id=<span class="string">&quot;testComponent&quot;</span>&gt;     <span class="comment">// 组件显示的内容</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>component!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>   </span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;componentA&#x27;</span>,&#123; </span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;#testComponent&#x27;</span>  </span><br><span class="line">    <span class="attr">template</span>: <span class="string">`&lt;div&gt;component&lt;/div&gt;`</span>  <span class="comment">// 组件内容少可以通过这种形式</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="编写插件"><a href="#编写插件" class="headerlink" title="编写插件"></a>编写插件</h4><p><code>vue</code>插件的实现应该暴露一个 <code>install</code> 方法。这个方法的第一个参数是 <code>Vue</code> 构造器，第二个参数是一个可选的选项对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MyPlugin</span>.<span class="property">install</span> = <span class="keyword">function</span> (<span class="params">Vue, options</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 添加全局方法或 property</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property">myGlobalMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 添加全局资源</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;my-directive&#x27;</span>, &#123;</span><br><span class="line">    <span class="title function_">bind</span> (el, binding, vnode, oldVnode) &#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 注入组件选项</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">    <span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myMethod</span> = <span class="keyword">function</span> (<span class="params">methodOptions</span>) &#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册形式"><a href="#注册形式" class="headerlink" title="注册形式"></a>注册形式</h3><h4 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h4><p><code>vue</code>组件注册主要分为全局注册与局部注册</p><p>全局注册通过<code>Vue.component</code>方法，第一个参数为组件的名称，第二个参数为传入的配置项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;my-component-name&#x27;</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br></pre></td></tr></table></figure><p>局部注册只需在用到的地方通过<code>components</code>属性注册一个组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> component1 = &#123;...&#125; <span class="comment">// 定义一个组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="attr">components</span>:&#123;</span><br><span class="line">component1   <span class="comment">// 局部注册</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插件注册"><a href="#插件注册" class="headerlink" title="插件注册"></a>插件注册</h4><p>插件的注册通过<code>Vue.use()</code>的方式进行注册（安装），第一个参数为插件的名字，第二个参数是可选择的配置项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(插件名字,&#123; <span class="comment">/* ... */</span>&#125; )</span><br></pre></td></tr></table></figure><p>注意的是：</p><p>注册插件的时候，需要在调用 <code>new Vue()</code> 启动应用之前完成</p><p><code>Vue.use</code>会自动阻止多次注册相同插件，只会注册一次</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>具体的其实在插件是什么章节已经表述了，这里在总结一下</p><p>组件 <code>(Component)</code> 是用来构成你的 <code>App</code> 的业务模块，它的目标是 <code>App.vue</code></p><p>插件 <code>(Plugin)</code> 是用来增强你的技术栈的功能模块，它的目标是 <code>Vue</code> 本身</p><p>简单来说，插件就是指对<code>Vue</code>的功能的增强或补充</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://vue3js.cn/docs/zh">https://vue3js.cn/docs/zh</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://static.vue-js.com/683475e0-3acc-11eb-ab90-d9ae814b240d.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、组件是什么&quot;&gt;&lt;a href=&quot;#一、组件是什么&quot; cl</summary>
      
    
    
    
    <category term="Vue" scheme="https://blogmind.cloud/categories/Vue/"/>
    
    
    <category term="面试" scheme="https://blogmind.cloud/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://blogmind.cloud/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue组件之间的通信方式都有哪些？</title>
    <link href="https://blogmind.cloud/2025/01/18/vue-communication/"/>
    <id>https://blogmind.cloud/2025/01/18/vue-communication/</id>
    <published>2025-01-18T08:00:00.000Z</published>
    <updated>2025-02-08T06:49:33.443Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.vue-js.com/7de50d20-3aca-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="一、组件间通信的概念"><a href="#一、组件间通信的概念" class="headerlink" title="一、组件间通信的概念"></a>一、组件间通信的概念</h2><p>开始之前，我们把<strong>组件间通信</strong>这个词进行拆分</p><ul><li>组件</li><li>通信</li></ul><p>都知道组件是<code>vue</code>最强大的功能之一，<code>vue</code>中每一个<code>.vue</code>我们都可以视之为一个组件通信指的是发送者通过某种媒体以某种格式来传递信息到收信者以达到某个目的。广义上，任何信息的交通都是通信<strong>组件间通信</strong>即指组件(<code>.vue</code>)通过某种方式来传递信息以达到某个目的举个栗子我们在使用<code>UI</code>框架中的<code>table</code>组件，可能会往<code>table</code>组件中传入某些数据，这个本质就形成了组件之间的通信</p><h2 id="二、组件间通信解决了什么"><a href="#二、组件间通信解决了什么" class="headerlink" title="二、组件间通信解决了什么"></a>二、组件间通信解决了什么</h2><p>在古代，人们通过驿站、飞鸽传书、烽火报警、符号、语言、眼神、触碰等方式进行信息传递，到了今天，随着科技水平的飞速发展，通信基本完全利用有线或无线电完成，相继出现了有线电话、固定电话、无线电话、手机、互联网甚至视频电话等各种通信方式从上面这段话，我们可以看到通信的本质是信息同步，共享回到<code>vue</code>中，每个组件之间的都有独自的作用域，组件间的数据是无法共享的但实际开发工作中我们常常需要让组件之间共享数据，这也是组件通信的目的要让它们互相之间能进行通讯，这样才能构成一个有机的完整系统</p><h2 id="二、组件间通信的分类"><a href="#二、组件间通信的分类" class="headerlink" title="二、组件间通信的分类"></a>二、组件间通信的分类</h2><p>组件间通信的分类可以分成以下</p><ul><li>父子组件之间的通信</li><li>兄弟组件之间的通信</li><li>祖孙与后代组件之间的通信</li><li>非关系组件间之间的通信</li></ul><p>关系图:</p><p> <img src="https://static.vue-js.com/85b92400-3aca-11eb-ab90-d9ae814b240d.png"></p><h2 id="三、组件间通信的方案"><a href="#三、组件间通信的方案" class="headerlink" title="三、组件间通信的方案"></a>三、组件间通信的方案</h2><p>整理<code>vue</code>中8种常规的通信方案</p><ol><li>通过 props 传递</li><li>通过 $emit 触发自定义事件</li><li>使用 ref</li><li>EventBus</li><li>$parent 或$root</li><li>attrs 与 listeners</li><li>Provide 与 Inject</li><li>Vuex</li></ol><h3 id="props传递数据"><a href="#props传递数据" class="headerlink" title="props传递数据"></a>props传递数据</h3><p> <img src="https://static.vue-js.com/8f80a670-3aca-11eb-ab90-d9ae814b240d.png"></p><ul><li>适用场景：父组件传递数据给子组件</li><li>子组件设置<code>props</code>属性，定义接收父组件传递过来的参数</li><li>父组件在使用子组件标签中通过字面量来传递值</li></ul><p><code>Children.vue</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">props</span>:&#123;  </span><br><span class="line">    <span class="comment">// 字符串形式  </span></span><br><span class="line"> <span class="attr">name</span>:<span class="title class_">String</span> <span class="comment">// 接收的类型参数  </span></span><br><span class="line">    <span class="comment">// 对象形式  </span></span><br><span class="line">    <span class="attr">age</span>:&#123;    </span><br><span class="line">        <span class="attr">type</span>:<span class="title class_">Number</span>, <span class="comment">// 接收的类型为数值  </span></span><br><span class="line">        <span class="attr">defaule</span>:<span class="number">18</span>,  <span class="comment">// 默认值为18  </span></span><br><span class="line">       <span class="attr">require</span>:<span class="literal">true</span> <span class="comment">// age属性必须传递  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><code>Father.vue</code>组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Children</span> name=<span class="string">&quot;jack&quot;</span> age=<span class="number">18</span> /&gt;  </span><br></pre></td></tr></table></figure><h3 id="emit-触发自定义事件"><a href="#emit-触发自定义事件" class="headerlink" title="$emit 触发自定义事件"></a>$emit 触发自定义事件</h3><ul><li>适用场景：子组件传递数据给父组件</li><li>子组件通过<code>$emit触发</code>自定义事件，<code>$emit</code>第二个参数为传递的数值</li><li>父组件绑定监听器获取到子组件传递过来的参数</li></ul><p><code>Chilfen.vue</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;add&#x27;</span>, good)  </span><br></pre></td></tr></table></figure><p><code>Father.vue</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Children</span> @add=<span class="string">&quot;cartAdd($event)&quot;</span> /&gt;  </span><br></pre></td></tr></table></figure><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><ul><li>父组件在使用子组件的时候设置<code>ref</code></li><li>父组件通过设置子组件<code>ref</code>来获取数据</li></ul><p>父组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Children</span> ref=<span class="string">&quot;foo&quot;</span> /&gt;  </span><br><span class="line">  </span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">foo</span>  <span class="comment">// 获取子组件实例，通过子组件实例我们就能拿到对应的数据  </span></span><br></pre></td></tr></table></figure><h3 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h3><ul><li>使用场景：兄弟组件传值</li><li>创建一个中央事件总线<code>EventBus</code></li><li>兄弟组件通过<code>$emit</code>触发自定义事件，<code>$emit</code>第二个参数为传递的数值</li><li>另一个兄弟组件通过<code>$on</code>监听自定义事件</li></ul><p><code>Bus.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个中央时间总线类  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> &#123;  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callbacks</span> = &#123;&#125;;   <span class="comment">// 存放事件的名字  </span></span><br><span class="line">  &#125;  </span><br><span class="line">  $on(name, fn) &#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callbacks</span>[name] = <span class="variable language_">this</span>.<span class="property">callbacks</span>[name] || [];  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callbacks</span>[name].<span class="title function_">push</span>(fn);  </span><br><span class="line">  &#125;  </span><br><span class="line">  $emit(name, args) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">callbacks</span>[name]) &#123;  </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">callbacks</span>[name].<span class="title function_">forEach</span>(<span class="function">(<span class="params">cb</span>) =&gt;</span> <span class="title function_">cb</span>(args));  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// main.js  </span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="keyword">new</span> <span class="title class_">Bus</span>() <span class="comment">// 将$bus挂载到vue实例的原型上  </span></span><br><span class="line"><span class="comment">// 另一种方式  </span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>() <span class="comment">// Vue已经实现了Bus的功能  </span></span><br></pre></td></tr></table></figure><p><code>Children1.vue</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$bus</span>.$emit(<span class="string">&#x27;foo&#x27;</span>)  </span><br></pre></td></tr></table></figure><p><code>Children2.vue</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$bus</span>.$on(<span class="string">&#x27;foo&#x27;</span>, <span class="variable language_">this</span>.<span class="property">handle</span>)  </span><br></pre></td></tr></table></figure><h3 id="parent-或-root"><a href="#parent-或-root" class="headerlink" title="$parent 或$ root"></a>$parent 或$ root</h3><ul><li>通过共同祖辈<code>$parent</code>或者<code>$root</code>搭建通信桥连</li></ul><p>兄弟组件</p><p><code>this.$parent.on(&#39;add&#39;,this.add)   </code></p><p>另一个兄弟组件</p><p><code>this.$parent.emit(&#39;add&#39;)   </code></p><h3 id="attrs-与-listeners"><a href="#attrs-与-listeners" class="headerlink" title="$attrs  与$ listeners"></a>$attrs  与$ listeners</h3><ul><li>适用场景：祖先传递数据给子孙</li><li>设置批量向下传属性<code>$attrs</code>和 <code>$listeners</code></li><li>包含了父级作用域中不作为 <code>prop</code> 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。</li><li>可以通过 <code>v-bind=&quot;$attrs&quot;</code> 传⼊内部组件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// child：并未在props中声明foo  </span></span><br><span class="line">&lt;p&gt;&#123;&#123;$attrs.<span class="property">foo</span>&#125;&#125;&lt;/p&gt;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// parent  </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">HelloWorld</span> <span class="attr">foo</span>=<span class="string">&quot;foo&quot;</span>/&gt;</span></span>  </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给Grandson隔代传值，communication/index.vue  </span></span><br><span class="line">&lt;<span class="title class_">Child2</span> msg=<span class="string">&quot;lalala&quot;</span> @some-event=<span class="string">&quot;onSomeEvent&quot;</span>&gt;&lt;/<span class="title class_">Child2</span>&gt;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Child2做展开  </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Grandson</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span> <span class="attr">v-on</span>=<span class="string">&quot;$listeners&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Grandson</span>&gt;</span></span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Grandson使⽤  </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;$emit(&#x27;some-event&#x27;, &#x27;msg from grandson&#x27;)&quot;</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">&#123;&#123;msg&#125;&#125;  </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  </span><br></pre></td></tr></table></figure><h3 id="provide-与-inject"><a href="#provide-与-inject" class="headerlink" title="provide 与 inject"></a>provide 与 inject</h3><ul><li>在祖先组件定义<code>provide</code>属性，返回传递的值</li><li>在后代组件通过<code>inject</code>接收组件传递过来的值</li></ul><p>祖先组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">provide</span>(<span class="params"></span>)&#123;  </span><br><span class="line">    <span class="keyword">return</span> &#123;  </span><br><span class="line">        <span class="attr">foo</span>:<span class="string">&#x27;foo&#x27;</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>后代组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject</span>:[<span class="string">&#x27;foo&#x27;</span>] <span class="comment">// 获取到祖先组件传递过来的值  </span></span><br></pre></td></tr></table></figure><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a><code>vuex</code></h3><ul><li><p>适用场景: 复杂关系的组件数据传递</p></li><li><p><code>Vuex</code>作用相当于一个用来存储共享变量的容器<br> <img src="https://static.vue-js.com/fa207cd0-3aca-11eb-ab90-d9ae814b240d.png"></p></li><li><p><code>state</code>用来存放共享变量的地方</p></li><li><p><code>getter</code>，可以增加一个<code>getter</code>派生状态，(相当于<code>store</code>中的计算属性），用来获得共享变量的值</p></li><li><p><code>mutations</code>用来存放修改<code>state</code>的方法。</p></li><li><p><code>actions</code>也是用来存放修改state的方法，不过<code>action</code>是在<code>mutations</code>的基础上进行。常用来做一些异步操作</p></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>父子关系的组件数据传递选择 <code>props</code>  与 <code>$emit</code>进行传递，也可选择<code>ref</code></li><li>兄弟关系的组件数据传递可选择<code>$bus</code>，其次可以选择<code>$parent</code>进行传递</li><li>祖先与后代组件数据传递可选择<code>attrs</code>与<code>listeners</code>或者 <code>Provide</code>与 <code>Inject</code></li><li>复杂关系的组件数据传递可以通过<code>vuex</code>存放共享的变量</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6844903990052782094#heading-0">https://juejin.cn/post/6844903990052782094#heading-0</a></li><li><a href="https://zh.wikipedia.org/wiki//%E9/%80/%9A/%E4/%BF/%A1">https://zh.wikipedia.org/wiki/\%E9\%80\%9A\%E4\%BF\%A1</a></li><li><a href="https://vue3js.cn/docs/zh">https://vue3js.cn/docs/zh</a></li></ul><p>面试官VUE系列总进度：5／33</p><p><a href="http://mp.weixin.qq.com/s?__biz=MzU1OTgxNDQ1Nw==&mid=2247484101&idx=1&sn=83b0983f0fca7d7c556e4cb0bff8c9b8&chksm=fc10c093cb674985ef3bd2966f66fc28c5eb70b0037e4be1af4bf54fb6fa9571985abd31d52f&scene=21#wechat_redirect">面试官：说说你对vue的理解?</a>  </p><p><a href="http://mp.weixin.qq.com/s?__biz=MzU1OTgxNDQ1Nw==&mid=2247484119&idx=1&sn=d171b28a00d42549d279498944a98519&chksm=fc10c081cb6749976814aaeda6a6433db418223cec57edda7e15b9e5a0ca69ad549655639c61&scene=21#wechat_redirect">面试官：说说你对SPA（单页应用）的理解?</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzU1OTgxNDQ1Nw==&mid=2247484167&idx=1&sn=7b00b4333ab2722f25f12586b70667ca&chksm=fc10c151cb6748476008dab2f4e6c6264f5d19678305955c85cec1b619e56e8f7457b7357fb9&scene=21#wechat_redirect">面试官：说说你对双向绑定的理解?</a>  </p><p><a href="http://mp.weixin.qq.com/s?__biz=MzU1OTgxNDQ1Nw==&mid=2247484176&idx=1&sn=5623421ed2678046ed9e438aadf6e26f&chksm=fc10c146cb67485015f24f7e9f5862c4c685fc33485fe30e1b375a534b4031978439c554e0c0&scene=21#wechat_redirect">面试官：说说你对Vue生命周期的理解?</a>  </p><p> <img src="https://static.vue-js.com/821b87b0-3ac6-11eb-ab90-d9ae814b240d.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://static.vue-js.com/7de50d20-3aca-11eb-85f6-6fac77c0c9b3.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、组件间通信的概念&quot;&gt;&lt;a href=&quot;#一、组件间通信的概念&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="Vue" scheme="https://blogmind.cloud/categories/Vue/"/>
    
    
    <category term="面试" scheme="https://blogmind.cloud/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://blogmind.cloud/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue项目中有封装过axios吗？主要是封装哪方面的？</title>
    <link href="https://blogmind.cloud/2025/01/16/vue-axios/"/>
    <id>https://blogmind.cloud/2025/01/16/vue-axios/</id>
    <published>2025-01-16T08:00:00.000Z</published>
    <updated>2025-02-08T06:49:30.105Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.vue-js.com/2bf1e460-45a7-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="一、axios是什么"><a href="#一、axios是什么" class="headerlink" title="一、axios是什么"></a>一、axios是什么</h2><p><code>axios</code> 是一个轻量的 <code>HTTP</code>客户端</p><p>基于 <code>XMLHttpRequest</code> 服务来执行 <code>HTTP</code> 请求，支持丰富的配置，支持 <code>Promise</code>，支持浏览器端和 <code>Node.js</code> 端。自<code>Vue</code>2.0起，尤大宣布取消对 <code>vue-resource</code> 的官方推荐，转而推荐 <code>axios</code>。现在 <code>axios</code> 已经成为大部分 <code>Vue</code> 开发者的首选</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>从浏览器中创建 <code>XMLHttpRequests</code></li><li>从 <code>node.js</code> 创建 <code>http</code>请求</li><li>支持 <code>Promise</code> API</li><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换<code> JSON</code> 数据</li><li>客户端支持防御<code>XSRF</code></li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>安装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 项目中安装</span></span><br><span class="line">npm install axios --S</span><br><span class="line"><span class="comment">// cdn 引入</span></span><br><span class="line">&lt;script src=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>导入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br></pre></td></tr></table></figure><p>发送请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;        </span><br><span class="line">  <span class="attr">url</span>:<span class="string">&#x27;xxx&#x27;</span>,    <span class="comment">// 设置请求的地址</span></span><br><span class="line">  <span class="attr">method</span>:<span class="string">&quot;GET&quot;</span>, <span class="comment">// 设置请求方法</span></span><br><span class="line">  <span class="attr">params</span>:&#123;      <span class="comment">// get请求使用params进行参数凭借,如果是post请求用data</span></span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">page</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;  </span><br><span class="line">  <span class="comment">// res为后端返回的数据</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);   </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>并发请求<code>axios.all([])</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getUserAccount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;/user/12345&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getUserPermissions</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;/user/12345/permissions&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">all</span>([<span class="title function_">getUserAccount</span>(), <span class="title function_">getUserPermissions</span>()])</span><br><span class="line">    .<span class="title function_">then</span>(axios.<span class="title function_">spread</span>(<span class="keyword">function</span> (<span class="params">res1, res2</span>) &#123; </span><br><span class="line">    <span class="comment">// res1第一个请求的返回的内容，res2第二个请求返回的内容</span></span><br><span class="line">    <span class="comment">// 两个请求都执行完成才会执行</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h2 id="二、为什么要封装"><a href="#二、为什么要封装" class="headerlink" title="二、为什么要封装"></a>二、为什么要封装</h2><p><code>axios</code> 的 API 很友好，你完全可以很轻松地在项目中直接使用。</p><p>不过随着项目规模增大，如果每发起一次<code>HTTP</code>请求，就要把这些比如设置超时时间、设置请求头、根据项目环境判断使用哪个请求地址、错误处理等等操作，都需要写一遍</p><p>这种重复劳动不仅浪费时间，而且让代码变得冗余不堪，难以维护。为了提高我们的代码质量，我们应该在项目中二次封装一下 <code>axios</code> 再使用</p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(<span class="string">&#x27;http://localhost:3000/data&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 配置代码</span></span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">1000</span>,</span><br><span class="line">  <span class="attr">withCredentials</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    <span class="title class_">Authorization</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">transformRequest</span>: [<span class="keyword">function</span> (<span class="params">data, headers</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="comment">// 其他请求配置...</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// todo: 真正业务逻辑代码</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 错误处理代码  </span></span><br><span class="line">  <span class="keyword">if</span> (err.<span class="property">response</span>.<span class="property">status</span> === <span class="number">401</span>) &#123;</span><br><span class="line">  <span class="comment">// handle authorization error</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (err.<span class="property">response</span>.<span class="property">status</span> === <span class="number">403</span>) &#123;</span><br><span class="line">  <span class="comment">// handle server forbidden error</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 其他错误处理.....</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果每个页面都发送类似的请求，都要写一堆的配置与错误处理，就显得过于繁琐了</p><p>这时候我们就需要对<code>axios</code>进行二次封装，让使用更为便利</p><h2 id="三、如何封装"><a href="#三、如何封装" class="headerlink" title="三、如何封装"></a>三、如何封装</h2><p>封装的同时，你需要和 后端协商好一些约定，请求头，状态码，请求超时时间…….</p><p>设置接口请求前缀：根据开发、测试、生产环境的不同，前缀需要加以区分</p><p>请求头 :  来实现一些具体的业务，必须携带一些参数才可以请求(例如：会员业务)</p><p>状态码:   根据接口返回的不同<code>status</code> ， 来执行不同的业务，这块需要和后端约定好</p><p>请求方法：根据<code>get</code>、<code>post</code>等方法进行一个再次封装，使用起来更为方便</p><p>请求拦截器:  根据请求的请求头设定，来决定哪些请求可以访问</p><p>响应拦截器： 这块就是根据 后端&#96;返回来的状态码判定执行不同业务</p><h3 id="设置接口请求前缀"><a href="#设置接口请求前缀" class="headerlink" title="设置接口请求前缀"></a>设置接口请求前缀</h3><p>利用<code>node</code>环境变量来作判断，用来区分开发、测试、生产环境</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span>) &#123;</span><br><span class="line">  axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;http://dev.xxx.com&#x27;</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">  axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;http://prod.xxx.com&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本地调试的时候，还需要在<code>vue.config.js</code>文件中配置<code>devServer</code>实现代理转发，从而实现跨域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/proxyApi&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://dev.xxx.com&#x27;</span>,</span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;/proxyApi&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="设置请求头与超时时间"><a href="#设置请求头与超时时间" class="headerlink" title="设置请求头与超时时间"></a>设置请求头与超时时间</h3><p>大部分情况下，请求头都是固定的，只有少部分情况下，会需要一些特殊的请求头，这里将普适性的请求头作为基础配置。当需要特殊请求头时，将特殊请求头作为参数传入，覆盖基础配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> service = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">30000</span>,  <span class="comment">// 请求 30s 超时</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="attr">get</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded;charset=utf-8&#x27;</span></span><br><span class="line">          <span class="comment">// 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">post</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json;charset=utf-8&#x27;</span></span><br><span class="line">          <span class="comment">// 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来</span></span><br><span class="line">        &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="封装请求方法"><a href="#封装请求方法" class="headerlink" title="封装请求方法"></a>封装请求方法</h3><p>先引入封装好的方法，在要调用的接口重新封装成一个方法暴露出去</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get 请求</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">httpGet</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  url,</span></span><br><span class="line"><span class="params">  params = &#123;&#125;</span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    axios.<span class="title function_">get</span>(url, &#123;</span><br><span class="line">      params</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(res.<span class="property">data</span>)</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(err)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// post</span></span><br><span class="line"><span class="comment">// post请求</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">httpPost</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  url,</span></span><br><span class="line"><span class="params">  data = &#123;&#125;,</span></span><br><span class="line"><span class="params">  params = &#123;&#125;</span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">axios</span>(&#123;</span><br><span class="line">      url,</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">      <span class="attr">transformRequest</span>: [<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> ret = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> it <span class="keyword">in</span> data) &#123;</span><br><span class="line">          ret += <span class="built_in">encodeURIComponent</span>(it) + <span class="string">&#x27;=&#x27;</span> + <span class="built_in">encodeURIComponent</span>(data[it]) + <span class="string">&#x27;&amp;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">      &#125;],</span><br><span class="line">      <span class="comment">// 发送的数据</span></span><br><span class="line">      data,</span><br><span class="line">      <span class="comment">// url参数</span></span><br><span class="line">      params</span><br><span class="line"></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(res.<span class="property">data</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把封装的方法放在一个<code>api.js</code>文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; httpGet, httpPost &#125; <span class="keyword">from</span> <span class="string">&#x27;./http&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getorglist</span> = (<span class="params">params = &#123;&#125;</span>) =&gt; <span class="title function_">httpGet</span>(&#123; <span class="attr">url</span>: <span class="string">&#x27;apps/api/org/list&#x27;</span>, params &#125;)</span><br></pre></td></tr></table></figure><p>页面中就能直接调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .vue</span></span><br><span class="line"><span class="keyword">import</span> &#123; getorglist &#125; <span class="keyword">from</span> <span class="string">&#x27;@/assets/js/api&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">getorglist</span>(&#123; <span class="attr">id</span>: <span class="number">200</span> &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样可以把<code>api</code>统一管理起来，以后维护修改只需要在<code>api.js</code>文件操作即可</p><h3 id="请求拦截器"><a href="#请求拦截器" class="headerlink" title="请求拦截器"></a>请求拦截器</h3><p>请求拦截器可以在每个请求里加上token，做了统一处理后维护起来也方便</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 每次发送请求之前判断是否存在token</span></span><br><span class="line">    <span class="comment">// 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况，此处token一般是用户完成登录后储存到localstorage里的</span></span><br><span class="line">    token &amp;&amp; (config.<span class="property">headers</span>.<span class="property">Authorization</span> = token)</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">error</span>(error)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h3 id="响应拦截器"><a href="#响应拦截器" class="headerlink" title="响应拦截器"></a>响应拦截器</h3><p>响应拦截器可以在接收到响应后先做一层操作，如根据状态码判断登录状态、授权</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据</span></span><br><span class="line">  <span class="comment">// 否则的话抛出错误</span></span><br><span class="line">  <span class="keyword">if</span> (response.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (response.<span class="property">data</span>.<span class="property">code</span> === <span class="number">511</span>) &#123;</span><br><span class="line">      <span class="comment">// 未授权调取授权接口</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response.<span class="property">data</span>.<span class="property">code</span> === <span class="number">510</span>) &#123;</span><br><span class="line">      <span class="comment">// 未登录跳转登录页</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(response)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(response)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 我们可以在这里对异常状态作统一处理</span></span><br><span class="line">  <span class="keyword">if</span> (error.<span class="property">response</span>.<span class="property">status</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理请求失败的情况</span></span><br><span class="line">    <span class="comment">// 对不同返回码对相应处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error.<span class="property">response</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>封装是编程中很有意义的手段，简单的<code>axios</code>封装，就可以让我们可以领略到它的魅力</li><li>封装 <code>axios</code> 没有一个绝对的标准，只要你的封装可以满足你的项目需求，并且用起来方便，那就是一个好的封装方案</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.html.cn/qa/vue-js/20544.html">https://www.html.cn/qa/vue-js/20544.html</a></li><li><a href="https://juejin.cn/post/6844904033782611976">https://juejin.cn/post/6844904033782611976</a></li><li><a href="https://juejin.cn/post/6844903801451708429">https://juejin.cn/post/6844903801451708429</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://static.vue-js.com/2bf1e460-45a7-11eb-85f6-6fac77c0c9b3.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、axios是什么&quot;&gt;&lt;a href=&quot;#一、axios是什么&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="Vue" scheme="https://blogmind.cloud/categories/Vue/"/>
    
    
    <category term="面试" scheme="https://blogmind.cloud/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://blogmind.cloud/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？</title>
    <link href="https://blogmind.cloud/2025/01/14/vue3-proxy/"/>
    <id>https://blogmind.cloud/2025/01/14/vue3-proxy/</id>
    <published>2025-01-14T08:00:00.000Z</published>
    <updated>2025-02-08T06:49:30.106Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="https://static.vue-js.com/57aa5c80-5f7f-11eb-ab90-d9ae814b240d.png"></p><h2 id="一、Object-defineProperty"><a href="#一、Object-defineProperty" class="headerlink" title="一、Object.defineProperty"></a>一、Object.defineProperty</h2><p>定义：<code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象</p><h5 id="为什么能实现响应式"><a href="#为什么能实现响应式" class="headerlink" title="为什么能实现响应式"></a>为什么能实现响应式</h5><p>通过<code>defineProperty</code> 两个属性，<code>get</code>及<code>set</code></p><ul><li>get</li></ul><p>属性的 getter 函数，当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值</p><ul><li>set</li></ul><p>属性的 setter 函数，当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。默认为 undefined</p><p>下面通过代码展示：</p><p>定义一个响应式函数<code>defineReactive</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    app.<span class="property">innerText</span> = obj.<span class="property">foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, val</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`get <span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">                val = newVal</span><br><span class="line">                <span class="title function_">update</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>defineReactive</code>，数据发生变化触发<code>update</code>方法，实现数据响应式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="title function_">defineReactive</span>(obj, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    obj.<span class="property">foo</span> = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toLocaleTimeString</span>()</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>在对象存在多个<code>key</code>情况下，需要进行遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">defineReactive</span>(obj, key, obj[key])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果存在嵌套对象的情况，还需要在<code>defineReactive</code>中进行递归</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, val</span>) &#123;</span><br><span class="line">    <span class="title function_">observe</span>(val)</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`get <span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">                val = newVal</span><br><span class="line">                <span class="title function_">update</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当给<code>key</code>赋值为对象的时候，还需要在<code>set</code>属性中进行递归</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">        <span class="title function_">observe</span>(newVal) <span class="comment">// 新值是对象的情况</span></span><br><span class="line">        <span class="title function_">notifyUpdate</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子能够实现对一个对象的基本响应式，但仍然存在诸多问题</p><p>现在对一个对象进行删除与添加属性操作，无法劫持到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="string">&quot;bar&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">observe</span>(obj)</span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">foo</span> <span class="comment">// no ok</span></span><br><span class="line">obj.<span class="property">jar</span> = <span class="string">&#x27;xxx&#x27;</span> <span class="comment">// no ok</span></span><br></pre></td></tr></table></figure><p>当我们对一个数组进行监听的时候，并不那么好使了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrData = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arrData.<span class="title function_">forEach</span>(<span class="function">(<span class="params">val,index</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">defineProperty</span>(arrData,index,val)</span><br><span class="line">&#125;)</span><br><span class="line">arrData.<span class="title function_">push</span>() <span class="comment">// no ok</span></span><br><span class="line">arrData.<span class="title function_">pop</span>()  <span class="comment">// no ok</span></span><br><span class="line">arrDate[<span class="number">0</span>] = <span class="number">99</span> <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>可以看到数据的<code>api</code>无法劫持到，从而无法实现数据响应式，</p><p>所以在<code>Vue2</code>中，增加了<code>set</code>、<code>delete</code> API，并且对数组<code>api</code>方法进行一个重写</p><p>还有一个问题则是，如果存在深层的嵌套对象关系，需要深层的进行监听，造成了性能的极大问题</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>检测不到对象属性的添加和删除</li><li>数组<code>API</code>方法无法监听到</li><li>需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题</li></ul><h2 id="二、proxy"><a href="#二、proxy" class="headerlink" title="二、proxy"></a>二、proxy</h2><p><code>Proxy</code>的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性了</p><p>在<code>ES6</code>系列中，我们详细讲解过<code>Proxy</code>的使用，就不再述说了</p><p>下面通过代码进行展示：</p><p>定义一个响应式方法<code>reactive</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Proxy相当于在对象外层加拦截</span></span><br><span class="line">    <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`设置<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">deleteProperty</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`删除<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> observed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下简单数据的操作，发现都能劫持</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1.获取</span></span><br><span class="line">state.<span class="property">foo</span> <span class="comment">// ok</span></span><br><span class="line"><span class="comment">// 2.设置已存在属性</span></span><br><span class="line">state.<span class="property">foo</span> = <span class="string">&#x27;fooooooo&#x27;</span> <span class="comment">// ok</span></span><br><span class="line"><span class="comment">// 3.设置不存在属性</span></span><br><span class="line">state.<span class="property">dong</span> = <span class="string">&#x27;dong&#x27;</span> <span class="comment">// ok</span></span><br><span class="line"><span class="comment">// 4.删除属性</span></span><br><span class="line"><span class="keyword">delete</span> state.<span class="property">dong</span> <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>再测试嵌套对象情况，这时候发现就不那么 OK 了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">bar</span>: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置嵌套对象属性</span></span><br><span class="line">state.<span class="property">bar</span>.<span class="property">a</span> = <span class="number">10</span> <span class="comment">// no ok</span></span><br></pre></td></tr></table></figure><p>如果要解决，需要在<code>get</code>之上再进行一层代理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Proxy相当于在对象外层加拦截</span></span><br><span class="line">    <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">isObject</span>(res) ? <span class="title function_">reactive</span>(res) : res</span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="keyword">return</span> observed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p><code>Object.defineProperty</code>只能遍历对象属性进行劫持</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">defineReactive</span>(obj, key, obj[key])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Proxy</code>直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Proxy相当于在对象外层加拦截</span></span><br><span class="line">    <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`设置<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">deleteProperty</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`删除<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> observed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Proxy</code>可以直接监听数组的变化（<code>push</code>、<code>shift</code>、<code>splice</code>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> proxtObj = <span class="title function_">reactive</span>(obj)</span><br><span class="line">obj.<span class="title function_">psuh</span>(<span class="number">4</span>) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p><code>Proxy</code>有多达13种拦截方法,不限于<code>apply</code>、<code>ownKeys</code>、<code>deleteProperty</code>、<code>has</code>等等，这是<code>Object.defineProperty</code>不具备的</p><p>正因为<code>defineProperty</code>自身的缺陷，导致<code>Vue2</code>在实现响应式过程需要实现其他的方法辅助（如重写数组方法、增加额外<code>set</code>、<code>delete</code>方法）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组重写</span></span><br><span class="line"><span class="keyword">const</span> originalProto = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="title class_">Object</span>.<span class="title function_">create</span>(originalProto)</span><br><span class="line">[<span class="string">&#x27;push&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;shift&#x27;</span>, <span class="string">&#x27;unshift&#x27;</span>, <span class="string">&#x27;splice&#x27;</span>, <span class="string">&#x27;reverse&#x27;</span>, <span class="string">&#x27;sort&#x27;</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">  arrayProto[method] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    originalProto[method].<span class="title function_">apply</span>(<span class="variable language_">this</span>.<span class="property">arguments</span>)</span><br><span class="line">    dep.<span class="title function_">notice</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set、delete</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">set</span>(obj,<span class="string">&#x27;bar&#x27;</span>,<span class="string">&#x27;newbar&#x27;</span>)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">delete</span>(obj),<span class="string">&#x27;bar&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>Proxy</code> 不兼容IE，也没有 <code>polyfill</code>, <code>defineProperty</code> 能支持到IE9</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;https://static.vue-js.com/57aa5c80-5f7f-11eb-ab90-d9ae814b240d.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、Object-defineProperty&quot;&gt;&lt;a href=&quot;#一、Object-d</summary>
      
    
    
    
    <category term="Vue" scheme="https://blogmind.cloud/categories/Vue/"/>
    
    
    <category term="面试" scheme="https://blogmind.cloud/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://blogmind.cloud/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue3.0性能提升主要是通过哪几方面体现的？</title>
    <link href="https://blogmind.cloud/2025/01/13/vue3-performance/"/>
    <id>https://blogmind.cloud/2025/01/13/vue3-performance/</id>
    <published>2025-01-13T08:00:00.000Z</published>
    <updated>2025-02-08T06:49:30.110Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="https://static.vue-js.com/2aac1020-5ed0-11eb-ab90-d9ae814b240d.png"></p><h2 id="一、编译阶段"><a href="#一、编译阶段" class="headerlink" title="一、编译阶段"></a>一、编译阶段</h2><p>回顾<code>Vue2</code>，我们知道每个组件实例都对应一个 <code>watcher</code> 实例，它会在组件渲染的过程中把用到的数据<code>property</code>记录为依赖，当依赖发生改变，触发<code>setter</code>，则会通知<code>watcher</code>，从而使关联的组件重新渲染</p><p> <img src="https://static.vue-js.com/39066120-5ed0-11eb-85f6-6fac77c0c9b3.png"></p><p>试想一下，一个组件结构如下图</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>静态文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>静态文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>静态文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>静态文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，组件内部只有一个动态节点，剩余一堆都是静态节点，所以这里很多 <code>diff</code> 和遍历其实都是不需要的，造成性能浪费</p><p>因此，<code>Vue3</code>在编译阶段，做了进一步优化。主要有如下：</p><ul><li>diff算法优化</li><li>静态提升</li><li>事件监听缓存</li><li>SSR优化</li></ul><h4 id="diff算法优化"><a href="#diff算法优化" class="headerlink" title="diff算法优化"></a>diff算法优化</h4><p><code>vue3</code>在<code>diff</code>算法中相比<code>vue2</code>增加了静态标记</p><p>关于这个静态标记，其作用是为了会发生变化的地方添加一个<code>flag</code>标记，下次发生变化的时候直接找该地方进行比较</p><p>下图这里，已经标记静态节点的<code>p</code>标签在<code>diff</code>过程中则不会比较，把性能进一步提高</p><p> <img src="https://static.vue-js.com/c732e150-5c58-11eb-ab90-d9ae814b240d.png"></p><p>关于静态类型枚举如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> enum <span class="title class_">PatchFlags</span> &#123;</span><br><span class="line">  <span class="variable constant_">TEXT</span> = <span class="number">1</span>,<span class="comment">// 动态的文本节点</span></span><br><span class="line">  <span class="variable constant_">CLASS</span> = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,  <span class="comment">// 2 动态的 class</span></span><br><span class="line">  <span class="variable constant_">STYLE</span> = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,  <span class="comment">// 4 动态的 style</span></span><br><span class="line">  <span class="variable constant_">PROPS</span> = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,  <span class="comment">// 8 动态属性，不包括类名和样式</span></span><br><span class="line">  <span class="variable constant_">FULL_PROPS</span> = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,  <span class="comment">// 16 动态 key，当 key 变化时需要完整的 diff 算法做比较</span></span><br><span class="line">  <span class="variable constant_">HYDRATE_EVENTS</span> = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,  <span class="comment">// 32 表示带有事件监听器的节点</span></span><br><span class="line">  <span class="variable constant_">STABLE_FRAGMENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,   <span class="comment">// 64 一个不会改变子节点顺序的 Fragment</span></span><br><span class="line">  <span class="variable constant_">KEYED_FRAGMENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">7</span>, <span class="comment">// 128 带有 key 属性的 Fragment</span></span><br><span class="line">  <span class="variable constant_">UNKEYED_FRAGMENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">8</span>, <span class="comment">// 256 子节点没有 key 的 Fragment</span></span><br><span class="line">  <span class="variable constant_">NEED_PATCH</span> = <span class="number">1</span> &lt;&lt; <span class="number">9</span>,   <span class="comment">// 512</span></span><br><span class="line">  <span class="variable constant_">DYNAMIC_SLOTS</span> = <span class="number">1</span> &lt;&lt; <span class="number">10</span>,  <span class="comment">// 动态 solt</span></span><br><span class="line">  <span class="variable constant_">HOISTED</span> = -<span class="number">1</span>,  <span class="comment">// 特殊标志是负整数表示永远不会用作 diff</span></span><br><span class="line">  <span class="variable constant_">BAIL</span> = -<span class="number">2</span> <span class="comment">// 一个特殊的标志，指代差异算法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态提升"><a href="#静态提升" class="headerlink" title="静态提升"></a>静态提升</h4><p><code>Vue3</code>中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用</p><p>这样就免去了重复的创建节点，大型应用会受益于这个改动，免去了重复的创建操作，优化了运行时候的内存占用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;你好&lt;/span&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>没有做静态提升之前</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createBlock</span>(_Fragment, <span class="literal">null</span>, [</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;你好&quot;</span>),</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, <span class="title function_">_toDisplayString</span>(_ctx.<span class="property">message</span>), <span class="number">1</span> <span class="comment">/* TEXT */</span>)</span><br><span class="line">  ], <span class="number">64</span> <span class="comment">/* STABLE_FRAGMENT */</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做了静态提升之后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _hoisted_1 = <span class="comment">/*#__PURE__*/</span><span class="title function_">_createVNode</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;你好&quot;</span>, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createBlock</span>(_Fragment, <span class="literal">null</span>, [</span><br><span class="line">    _hoisted_1,</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, <span class="title function_">_toDisplayString</span>(_ctx.<span class="property">message</span>), <span class="number">1</span> <span class="comment">/* TEXT */</span>)</span><br><span class="line">  ], <span class="number">64</span> <span class="comment">/* STABLE_FRAGMENT */</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the console for the AST</span></span><br></pre></td></tr></table></figure><p>静态内容<code>_hoisted_1</code>被放置在<code>render</code> 函数外，每次渲染的时候只要取 <code>_hoisted_1</code> 即可</p><p>同时 <code>_hoisted_1</code> 被打上了 <code>PatchFlag</code> ，静态标记值为 -1 ，特殊标志是负整数表示永远不会用于 Diff</p><h4 id="事件监听缓存"><a href="#事件监听缓存" class="headerlink" title="事件监听缓存"></a>事件监听缓存</h4><p>默认情况下绑定事件行为会被视为动态绑定，所以每次都会去追踪它的变化</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;button @click = &#x27;onClick&#x27;&gt;点我&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>没开启事件监听器缓存</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> render = <span class="comment">/*#__PURE__*/</span><span class="title function_">_withId</span>(<span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createBlock</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">&quot;button&quot;</span>, &#123; <span class="attr">onClick</span>: _ctx.<span class="property">onClick</span> &#125;, <span class="string">&quot;点我&quot;</span>, <span class="number">8</span> <span class="comment">/* PROPS */</span>, [<span class="string">&quot;onClick&quot;</span>])</span><br><span class="line">                                             <span class="comment">// PROPS=1&lt;&lt;3,// 8 //动态属性，但不包含类名和样式</span></span><br><span class="line">  ]))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>开启事件侦听器缓存后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createBlock</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">&quot;button&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">onClick</span>: _cache[<span class="number">1</span>] || (_cache[<span class="number">1</span>] = <span class="function">(<span class="params">...args</span>) =&gt;</span> (_ctx.<span class="title function_">onClick</span>(...args)))</span><br><span class="line">    &#125;, <span class="string">&quot;点我&quot;</span>)</span><br><span class="line">  ]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述发现开启了缓存后，没有了静态标记。也就是说下次<code>diff</code>算法的时候直接使用</p><h4 id="SSR优化"><a href="#SSR优化" class="headerlink" title="SSR优化"></a>SSR优化</h4><p>当静态内容大到一定量级时候，会用<code>createStaticVNode</code>方法在客户端去生成一个static node，这些静态<code>node</code>，会被直接<code>innerHtml</code>，就不需要创建对象，然后根据对象渲染</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">...  <span class="comment">// 很多个静态属性</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>编译后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mergeProps <span class="keyword">as</span> _mergeProps &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ssrRenderAttrs <span class="keyword">as</span> _ssrRenderAttrs, ssrInterpolate <span class="keyword">as</span> _ssrInterpolate &#125; <span class="keyword">from</span> <span class="string">&quot;@vue/server-renderer&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">ssrRender</span>(<span class="params">_ctx, _push, _parent, _attrs, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> _cssVars = &#123; <span class="attr">style</span>: &#123; <span class="attr">color</span>: _ctx.<span class="property">color</span> &#125;&#125;</span><br><span class="line">  <span class="title function_">_push</span>(<span class="string">`&lt;div<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">    _ssrRenderAttrs(_mergeProps(_attrs, _cssVars))</span></span></span><br><span class="line"><span class="subst"><span class="string">  &#125;</span>&gt;&lt;div&gt;&lt;span&gt;你好&lt;/span&gt;...&lt;div&gt;&lt;span&gt;你好&lt;/span&gt;&lt;div&gt;&lt;span&gt;<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">    _ssrInterpolate(_ctx.message)</span></span></span><br><span class="line"><span class="subst"><span class="string">  &#125;</span>&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、源码体积"><a href="#二、源码体积" class="headerlink" title="二、源码体积"></a>二、源码体积</h2><p>相比<code>Vue2</code>，<code>Vue3</code>整体体积变小了，除了移出一些不常用的API，再重要的是<code>Tree shanking</code></p><p>任何一个函数，如<code>ref</code>、<code>reavtived</code>、<code>computed</code>等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed, defineComponent, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> age = <span class="title function_">ref</span>(<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> readOnlyAge = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> age.<span class="property">value</span>++) <span class="comment">// 19</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            age,</span><br><span class="line">            state,</span><br><span class="line">            readOnlyAge</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="三、响应式系统"><a href="#三、响应式系统" class="headerlink" title="三、响应式系统"></a>三、响应式系统</h2><p><code>vue2</code>中采用 <code>defineProperty</code>来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加<code>getter</code>和<code>setter</code>，实现响应式</p><p><code>vue3</code>采用<code>proxy</code>重写了响应式系统，因为<code>proxy</code>可以对整个对象进行监听，所以不需要深度遍历</p><ul><li>可以监听动态属性的添加</li><li>可以监听到数组的索引和数组<code>length</code>属性</li><li>可以监听删除属性</li></ul><p>关于这两个 API 具体的不同，我们下篇文章会进行一个更加详细的介绍</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6903171037211557895">https://juejin.cn/post/6903171037211557895</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;https://static.vue-js.com/2aac1020-5ed0-11eb-ab90-d9ae814b240d.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、编译阶段&quot;&gt;&lt;a href=&quot;#一、编译阶段&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Vue" scheme="https://blogmind.cloud/categories/Vue/"/>
    
    
    <category term="面试" scheme="https://blogmind.cloud/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://blogmind.cloud/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>说说Vue 3.0中Treeshaking特性？举例说明一下？</title>
    <link href="https://blogmind.cloud/2025/01/12/vue3-treeshaking/"/>
    <id>https://blogmind.cloud/2025/01/12/vue3-treeshaking/</id>
    <published>2025-01-12T08:00:00.000Z</published>
    <updated>2025-02-08T06:49:30.109Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="https://static.vue-js.com/5e8bf1d0-6097-11eb-ab90-d9ae814b240d.png"></p><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p><code>Tree shaking</code> 是一种通过清除多余代码方式来优化项目打包体积的技术，专业术语叫 <code>Dead code elimination</code></p><p>简单来讲，就是在保持代码运行结果不变的前提下，去除无用的代码</p><p>如果把代码打包比作制作蛋糕，传统的方式是把鸡蛋（带壳）全部丢进去搅拌，然后放入烤箱，最后把（没有用的）蛋壳全部挑选并剔除出去</p><p>而<code>treeshaking</code>则是一开始就把有用的蛋白蛋黄（import）放入搅拌，最后直接作出蛋糕</p><p>也就是说 ，<code>tree shaking</code> 其实是找出使用的代码</p><p>在<code>Vue2</code>中，无论我们使用什么功能，它们最终都会出现在生产代码中。主要原因是<code>Vue</code>实例在项目中是单例的，捆绑程序无法检测到该对象的哪些属性在代码中被使用到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p>而<code>Vue3</code>源码引入<code>tree shaking</code>特性，将全局 API 进行分块。如果您不使用其某些功能，它们将不会包含在您的基础包中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nextTick, observable &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><h2 id="二、如何做"><a href="#二、如何做" class="headerlink" title="二、如何做"></a>二、如何做</h2><p><code>Tree shaking</code>是基于<code>ES6</code>模板语法（<code>import</code>与<code>exports</code>），主要是借助<code>ES6</code>模块的静态编译思想，在编译时就能确定模块的依赖关系，以及输入和输出的变量</p><p><code>Tree shaking</code>无非就是做了两件事：</p><ul><li>编译阶段利用<code>ES6 Module</code>判断哪些模块已经加载</li><li>判断那些模块和变量未被使用或者引用，进而删除对应代码</li></ul><p>下面就来举个例子：</p><p>通过脚手架<code>vue-cli</code>安装<code>Vue2</code>与<code>Vue3</code>项目</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create vue-demo</span><br></pre></td></tr></table></figure><h3 id="Vue2-项目"><a href="#Vue2-项目" class="headerlink" title="Vue2 项目"></a>Vue2 项目</h3><p>组件中使用<code>data</code>属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data: () =&gt; (&#123;</span><br><span class="line">            count: 1,</span><br><span class="line">        &#125;),</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>对项目进行打包，体积如下图</p><p><img src="https://static.vue-js.com/6bd2aff0-6097-11eb-85f6-6fac77c0c9b3.png"></p><p>为组件设置其他属性（<code>compted</code>、<code>watch</code>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">        <span class="attr">question</span>:<span class="string">&quot;&quot;</span>, </span><br><span class="line">        <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="attr">computed</span>: &#123;</span><br><span class="line">        <span class="attr">double</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span> * <span class="number">2</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">watch</span>: &#123;</span><br><span class="line">        <span class="attr">question</span>: <span class="keyword">function</span> (<span class="params">newQuestion, oldQuestion</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">answer</span> = <span class="string">&#x27;xxxx&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再一次打包，发现打包出来的体积并没有变化</p><p><img src="https://static.vue-js.com/7c29e260-6097-11eb-ab90-d9ae814b240d.png"></p><h3 id="Vue3-项目"><a href="#Vue3-项目" class="headerlink" title="Vue3 项目"></a>Vue3 项目</h3><p>组件中简单使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, defineComponent &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      state,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>将项目进行打包</p><p><img src="https://static.vue-js.com/95df0000-6097-11eb-85f6-6fac77c0c9b3.png"></p><p>在组件中引入<code>computed</code>和<code>watch</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, defineComponent, computed, watch &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> double = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">count</span> * <span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">watch</span>(</span><br><span class="line">      <span class="function">() =&gt;</span> state.<span class="property">count</span>,</span><br><span class="line">      <span class="function">(<span class="params">count, preCount</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(preCount);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      state,</span><br><span class="line">      double,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>再次对项目进行打包，可以看到在引入<code>computer</code>和<code>watch</code>之后，项目整体体积变大了</p><p> <img src="https://static.vue-js.com/b36a7a00-6097-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="三、作用"><a href="#三、作用" class="headerlink" title="三、作用"></a>三、作用</h2><p>通过<code>Tree shaking</code>，<code>Vue3</code>给我们带来的好处是：</p><ul><li>减少程序体积（更小）</li><li>减少程序执行时间（更快）</li><li>便于将来对程序架构进行优化（更友好）</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://segmentfault.com/a/1190000038962700">https://segmentfault.com/a/1190000038962700</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;https://static.vue-js.com/5e8bf1d0-6097-11eb-ab90-d9ae814b240d.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、是什么&quot;&gt;&lt;a href=&quot;#一、是什么&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="Vue" scheme="https://blogmind.cloud/categories/Vue/"/>
    
    
    <category term="面试" scheme="https://blogmind.cloud/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://blogmind.cloud/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>面试官：vue3有了解过吗？能说说跟vue2的区别吗？</title>
    <link href="https://blogmind.cloud/2025/01/12/vue3-vue3-vue2/"/>
    <id>https://blogmind.cloud/2025/01/12/vue3-vue3-vue2/</id>
    <published>2025-01-12T08:00:00.000Z</published>
    <updated>2025-02-08T06:49:30.109Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="https://static.vue-js.com/774b6950-5087-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="一、Vue3介绍"><a href="#一、Vue3介绍" class="headerlink" title="一、Vue3介绍"></a>一、Vue3介绍</h2><p>关于<code>vue3</code>的重构背景，尤大是这样说的：</p><p>「Vue 新版本的理念成型于 2018 年末，当时 Vue 2 的代码库已经有两岁半了。比起通用软件的生命周期来这好像也没那么久，但在这段时期，前端世界已经今昔非比了</p><p>在我们更新（和重写）Vue 的主要版本时，主要考虑两点因素：首先是新的 JavaScript 语言特性在主流浏览器中的受支持水平；其次是当前代码库中随时间推移而逐渐暴露出来的一些设计和架构问题」</p><p>简要就是：</p><ul><li>利用新的语言特性(es6)</li><li>解决架构问题</li></ul><h2 id="哪些变化"><a href="#哪些变化" class="headerlink" title="哪些变化"></a>哪些变化</h2><p> <img src="https://static.vue-js.com/9169a900-5087-11eb-85f6-6fac77c0c9b3.png"></p><p>从上图中，我们可以概览<code>Vue3</code>的新特性，如下：</p><ul><li>速度更快</li><li>体积减少</li><li>更易维护</li><li>更接近原生</li><li>更易使用</li></ul><h3 id="速度更快"><a href="#速度更快" class="headerlink" title="速度更快"></a>速度更快</h3><p><code>vue3</code>相比<code>vue2</code></p><ul><li><p>重写了虚拟<code>Dom</code>实现</p></li><li><p>编译模板的优化</p></li><li><p>更高效的组件初始化</p></li><li><p><code>undate</code>性能提高1.3~2倍</p></li><li><p><code>SSR</code>速度提高了2~3倍</p></li></ul><p> <img src="https://static.vue-js.com/ac1d23d0-5087-11eb-ab90-d9ae814b240d.png"></p><h3 id="体积更小"><a href="#体积更小" class="headerlink" title="体积更小"></a>体积更小</h3><p>通过<code>webpack</code>的<code>tree-shaking</code>功能，可以将无用模块“剪辑”，仅打包需要的</p><p>能够<code>tree-shaking</code>，有两大好处：</p><ul><li><p>对开发人员，能够对<code>vue</code>实现更多其他的功能，而不必担忧整体体积过大</p></li><li><p>对使用者，打包出来的包体积变小了</p></li></ul><p><code>vue</code>可以开发出更多其他的功能，而不必担忧<code>vue</code>打包出来的整体体积过多</p><p> <img src="https://static.vue-js.com/c01af010-5087-11eb-85f6-6fac77c0c9b3.png"> </p><h3 id="更易维护"><a href="#更易维护" class="headerlink" title="更易维护"></a>更易维护</h3><h4 id="compositon-Api"><a href="#compositon-Api" class="headerlink" title="compositon Api"></a>compositon Api</h4><ul><li>可与现有的<code>Options API</code>一起使用</li><li>灵活的逻辑组合与复用</li><li><code>Vue3</code>模块可以和其他框架搭配使用</li></ul><p><img src="https://static.vue-js.com/c5c919b0-5087-11eb-ab90-d9ae814b240d.png"> </p><h4 id="更好的Typescript支持"><a href="#更好的Typescript支持" class="headerlink" title="更好的Typescript支持"></a>更好的Typescript支持</h4><p><code>VUE3</code>是基于<code>typescipt</code>编写的，可以享受到自动的类型定义提示</p><p><img src="https://static.vue-js.com/cc688120-5087-11eb-ab90-d9ae814b240d.png"></p><h4 id="编译器重写"><a href="#编译器重写" class="headerlink" title="编译器重写"></a>编译器重写</h4><p><img src="https://static.vue-js.com/fcd33800-5087-11eb-85f6-6fac77c0c9b3.png"></p><h3 id="更接近原生"><a href="#更接近原生" class="headerlink" title="更接近原生"></a>更接近原生</h3><p>可以自定义渲染 API</p><p><img src="https://static.vue-js.com/0c7d88a0-5088-11eb-ab90-d9ae814b240d.png"></p><h3 id="更易使用"><a href="#更易使用" class="headerlink" title="更易使用"></a>更易使用</h3><p>响应式 <code>Api</code> 暴露出来</p><p><img src="https://static.vue-js.com/26070260-5088-11eb-ab90-d9ae814b240d.png"></p><p>轻松识别组件重新渲染原因</p><p><img src="https://static.vue-js.com/43b2fcb0-5088-11eb-ab90-d9ae814b240d.png"></p><h2 id="二、Vue3新增特性"><a href="#二、Vue3新增特性" class="headerlink" title="二、Vue3新增特性"></a>二、Vue3新增特性</h2><p>Vue 3 中需要关注的一些新功能包括：</p><ul><li>framents</li><li>Teleport</li><li>composition Api</li><li>createRenderer</li></ul><h3 id="framents"><a href="#framents" class="headerlink" title="framents"></a>framents</h3><p>在 <code>Vue3.x</code> 中，组件现在支持有多个根节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- <span class="title class_">Layout</span>.<span class="property">vue</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">header</span>&gt;</span>...<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">main</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span>...<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h3><p><code>Teleport</code> 是一种能够将我们的模板移动到 <code>DOM</code> 中 <code>Vue app</code> 之外的其他位置的技术，就有点像哆啦A梦的“任意门”</p><p>在<code>vue2</code>中，像 <code>modals</code>,<code>toast</code> 等这样的元素，如果我们嵌套在 <code>Vue</code> 的某个组件内部，那么处理嵌套组件的定位、<code>z-index</code> 和样式就会变得很困难</p><p>通过<code>Teleport</code>，我们可以在组件的逻辑位置写模板代码，然后在 <code>Vue</code> 应用范围之外渲染它</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showToast&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>打开 toast<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- to 属性就是目标位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;#teleport-target&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;visible&quot;</span> <span class="attr">class</span>=<span class="string">&quot;toast-wrap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;toast-msg&quot;</span>&gt;</span>我是一个 Toast 文案<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="createRenderer"><a href="#createRenderer" class="headerlink" title="createRenderer"></a>createRenderer</h3><p>通过<code>createRenderer</code>，我们能够构建自定义渲染器，我们能够将 <code>vue</code> 的开发模型扩展到其他平台</p><p>我们可以将其生成在<code>canvas</code>画布上</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da4437845ec54eb3829313c92fc81afe~tplv-k3u1fbpfcp-watermark.image"></p><p>关于<code>createRenderer</code>，我们了解下基本使用，就不展开讲述了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRenderer &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/runtime-core&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; render, createApp &#125; = <span class="title function_">createRenderer</span>(&#123;</span><br><span class="line">  patchProp,</span><br><span class="line">  insert,</span><br><span class="line">  remove,</span><br><span class="line">  createElement,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; render, createApp &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;@vue/runtime-core&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="composition-Api"><a href="#composition-Api" class="headerlink" title="composition Api"></a>composition Api</h3><p>composition Api，也就是组合式<code>api</code>，通过这种形式，我们能够更加容易维护我们的代码，将相同功能的变量进行一个集中式的管理</p><p> <img src="https://static.vue-js.com/5e0bfb70-5088-11eb-ab90-d9ae814b240d.png"></p><p>关于<code>compositon api</code>的使用，这里以下图展开</p><p><img src="https://static.vue-js.com/6f67a590-5088-11eb-85f6-6fac77c0c9b3.png"></p><p>简单使用:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">const</span> double = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> count.<span class="property">value</span> * <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">            count.<span class="property">value</span>++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;component mounted!&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            count,</span><br><span class="line">            double,</span><br><span class="line">            increment</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、非兼容变更"><a href="#三、非兼容变更" class="headerlink" title="三、非兼容变更"></a>三、非兼容变更</h3><h3 id="Global-API"><a href="#Global-API" class="headerlink" title="Global API"></a>Global API</h3><ul><li>全局 <code>Vue API</code> 已更改为使用应用程序实例</li><li>全局和内部 <code>API</code> 已经被重构为可 <code>tree-shakable</code></li></ul><h3 id="模板指令"><a href="#模板指令" class="headerlink" title="模板指令"></a>模板指令</h3><ul><li>组件上 <code>v-model</code> 用法已更改</li><li><code>&lt;template v-for&gt;</code>和 非 <code>v-for</code>节点上<code>key</code>用法已更改</li><li>在同一元素上使用的 <code>v-if</code> 和 <code>v-for</code> 优先级已更改</li><li><code>v-bind=&quot;object&quot;</code> 现在排序敏感</li><li><code>v-for</code> 中的 <code>ref</code> 不再注册 <code>ref</code> 数组</li></ul><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ul><li>只能使用普通函数创建功能组件</li><li><code>functional</code> 属性在单文件组件 <code>(SFC) </code></li><li>异步组件现在需要 <code>defineAsyncComponent</code> 方法来创建</li></ul><h3 id="渲染函数"><a href="#渲染函数" class="headerlink" title="渲染函数"></a>渲染函数</h3><ul><li>渲染函数<code>API</code>改变</li><li><code>$scopedSlots</code> property 已删除，所有插槽都通过 <code>$slots</code> 作为函数暴露</li><li>自定义指令 API 已更改为与组件生命周期一致</li><li>一些转换 <code>class</code> 被重命名了：<ul><li><code>v-enter</code> -&gt; <code>v-enter-from</code></li><li><code>v-leave</code> -&gt; <code>v-leave-from</code></li></ul></li><li>组件 <code>watch</code> 选项和实例方法 <code>$watch</code>不再支持点分隔字符串路径，请改用计算函数作为参数</li><li>在 <code>Vue 2.x</code> 中，应用根容器的 <code>outerHTML</code> 将替换为根组件模板 (如果根组件没有模板&#x2F;渲染选项，则最终编译为模板)。<code>VUE3.x</code> 现在使用应用程序容器的 <code>innerHTML</code>。</li></ul><h3 id="其他小改变"><a href="#其他小改变" class="headerlink" title="其他小改变"></a>其他小改变</h3><ul><li><code>destroyed</code> 生命周期选项被重命名为 <code>unmounted</code></li><li><code>beforeDestroy</code> 生命周期选项被重命名为 <code>beforeUnmount</code></li><li><code>[prop default</code>工厂函数不再有权访问 <code>this</code> 是上下文</li><li>自定义指令 API 已更改为与组件生命周期一致</li><li><code>data</code> 应始终声明为函数</li><li>来自 <code>mixin</code> 的 <code>data</code> 选项现在可简单地合并</li><li><code>attribute</code> 强制策略已更改</li><li>一些过渡 <code>class</code> 被重命名</li><li>组建 watch 选项和实例方法 <code>$watch</code>不再支持以点分隔的字符串路径。请改用计算属性函数作为参数。</li><li><code>&lt;template&gt;</code> 没有特殊指令的标记 (<code>v-if/else-if/else</code>、<code>v-for</code> 或 <code>v-slot</code>) 现在被视为普通元素，并将生成原生的 <code>&lt;template&gt;</code> 元素，而不是渲染其内部内容。</li><li>在<code> Vue 2.x</code> 中，应用根容器的 <code>outerHTML</code> 将替换为根组件模板 (如果根组件没有模板&#x2F;渲染选项，则最终编译为模板)。<code>Vue 3.x</code> 现在使用应用容器的 <code>innerHTML</code>，这意味着容器本身不再被视为模板的一部分。</li></ul><h3 id="移除-API"><a href="#移除-API" class="headerlink" title="移除 API"></a>移除 API</h3><ul><li><code>keyCode</code> 支持作为 <code>v-on</code> 的修饰符</li><li><code>$on</code>，<code>$off </code>和<code> $once</code> 实例方法</li><li>过滤<code>filter</code></li><li>内联模板 <code>attribute</code></li><li><code>$destroy</code> 实例方法。用户不应再手动管理单个<code> Vue</code> 组件的生命周期。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://vue3js.cn/docs/zh/guide/migration/introduction.html#%E6%A8%A1%E6%9D%BF%E6%8C%87%E4%BB%A4">https://vue3js.cn/docs/zh/guide/migration/introduction.html#%E6%A8%A1%E6%9D%BF%E6%8C%87%E4%BB%A4</a></li><li><a href="https://composition-api.vuejs.org/zh/#api-%E4%BB%8B%E7%BB%8D">https://composition-api.vuejs.org/zh/#api-%E4%BB%8B%E7%BB%8D</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;https://static.vue-js.com/774b6950-5087-11eb-85f6-6fac77c0c9b3.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、Vue3介绍&quot;&gt;&lt;a href=&quot;#一、Vue3介绍&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Vue" scheme="https://blogmind.cloud/categories/Vue/"/>
    
    
    <category term="面试" scheme="https://blogmind.cloud/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://blogmind.cloud/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue项目中你是如何解决跨域的呢？</title>
    <link href="https://blogmind.cloud/2025/01/11/vue-cors/"/>
    <id>https://blogmind.cloud/2025/01/11/vue-cors/</id>
    <published>2025-01-11T08:00:00.000Z</published>
    <updated>2025-02-08T06:49:30.105Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.vue-js.com/db3045b0-4e31-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="一、跨域是什么"><a href="#一、跨域是什么" class="headerlink" title="一、跨域是什么"></a>一、跨域是什么</h2><p>跨域本质是浏览器基于<strong>同源策略</strong>的一种安全手段</p><p>同源策略（Sameoriginpolicy），是一种约定，它是浏览器最核心也最基本的安全功能</p><p>所谓同源（即指在同一个域）具有以下三个相同点</p><ul><li>协议相同（protocol）</li><li>主机相同（host）</li><li>端口相同（port）</li></ul><p>反之非同源请求，也就是协议、端口、主机其中一项不相同的时候，这时候就会产生跨域</p><blockquote><p>一定要注意跨域是浏览器的限制，你用抓包工具抓取接口数据，是可以看到接口已经把数据返回回来了，只是浏览器的限制，你获取不到数据。用postman请求接口能够请求到数据。这些再次印证了跨域是浏览器的限制。</p></blockquote><h2 id="二、如何解决"><a href="#二、如何解决" class="headerlink" title="二、如何解决"></a>二、如何解决</h2><p>解决跨域的方法有很多，下面列举了三种：</p><ul><li>JSONP</li><li>CORS</li><li>Proxy</li></ul><p>而在<code>vue</code>项目中，我们主要针对<code>CORS</code>或<code>Proxy</code>这两种方案进行展开</p><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS （Cross-Origin Resource Sharing，跨域资源共享）是一个系统，它由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应</p><p><code>CORS</code> 实现起来非常方便，只需要增加一些 <code>HTTP</code> 头，让服务器能声明允许的访问来源</p><p>只要后端实现了 <code>CORS</code>，就实现了跨域</p><p> <img src="https://static.vue-js.com/140deb80-4e32-11eb-ab90-d9ae814b240d.png"></p><p>以<code> koa</code>框架举例</p><p>添加中间件，直接设置<code>Access-Control-Allow-Origin</code>响应头</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next)=&gt; &#123;</span><br><span class="line">  ctx.<span class="title function_">set</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  ctx.<span class="title function_">set</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild&#x27;</span>);</span><br><span class="line">  ctx.<span class="title function_">set</span>(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;PUT, POST, GET, DELETE, OPTIONS&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (ctx.<span class="property">method</span> == <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">    ctx.<span class="property">body</span> = <span class="number">200</span>; </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>ps: <code>Access-Control-Allow-Origin</code> 设置为*其实意义不大，可以说是形同虚设，实际应用中，上线前我们会将<code>Access-Control-Allow-Origin</code> 值设为我们目标<code>host</code></p><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>代理（Proxy）也称网络代理，是一种特殊的网络服务，允许一个（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击</p><p><strong>方案一</strong></p><p>如果是通过<code>vue-cli</code>脚手架工具搭建项目，我们可以通过<code>webpack</code>为我们起一个本地服务器作为请求的代理对象</p><p>通过该服务器转发请求至目标服务器，得到结果再转发给前端，但是最终发布上线时如果web应用和接口服务器不在一起仍会跨域</p><p>在<code>vue.config.js</code>文件，新增以下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">amodule.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="number">8084</span>,</span><br><span class="line">        <span class="attr">open</span>: <span class="literal">true</span>,<span class="comment">// vue项目启动时自动打开浏览器</span></span><br><span class="line">        <span class="attr">proxy</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123; <span class="comment">// &#x27;/api&#x27;是代理标识，用于告诉node，url前面是/api的就是使用代理的</span></span><br><span class="line">                <span class="attr">target</span>: <span class="string">&quot;http://xxx.xxx.xx.xx:8080&quot;</span>, <span class="comment">//目标地址，一般是指后台服务器地址</span></span><br><span class="line">                <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">//是否跨域</span></span><br><span class="line">                <span class="attr">pathRewrite</span>: &#123; <span class="comment">// pathRewrite 的作用是把实际Request Url中的&#x27;/api&#x27;用&quot;&quot;代替</span></span><br><span class="line">                    <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&quot;&quot;</span> </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>axios</code>发送请求中，配置请求的根路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;/api&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>方案二</strong></p><p>此外，还可通过服务端实现代理请求转发</p><p>以<code>express</code>框架为例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(__dirname + <span class="string">&#x27;/&#x27;</span>))</span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/api&#x27;</span>, <span class="title function_">proxy</span>(&#123; <span class="attr">target</span>: <span class="string">&#x27;http://localhost:4000&#x27;</span>, <span class="attr">changeOrigin</span>: <span class="literal">false</span></span><br><span class="line">                      &#125;));</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = app</span><br></pre></td></tr></table></figure><p><strong>方案三</strong></p><p>通过配置<code>nginx</code>实现代理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen    <span class="number">80</span>;</span><br><span class="line">    # server_name www.<span class="property">josephxia</span>.<span class="property">com</span>;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root  /<span class="keyword">var</span>/www/html;</span><br><span class="line">        index  index.<span class="property">html</span> index.<span class="property">htm</span>;</span><br><span class="line">        try_files $uri $uri/ /index.<span class="property">html</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    location /api &#123;</span><br><span class="line">        proxy_pass  <span class="attr">http</span>:<span class="comment">//127.0.0.1:3000;</span></span><br><span class="line">        proxy_redirect   off;</span><br><span class="line">        proxy_set_header  <span class="title class_">Host</span>       $host;</span><br><span class="line">        proxy_set_header  X-<span class="title class_">Real</span>-<span class="variable constant_">IP</span>     $remote_addr;</span><br><span class="line">        proxy_set_header  X-<span class="title class_">Forwarded</span>-<span class="title class_">For</span>  $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://static.vue-js.com/db3045b0-4e31-11eb-85f6-6fac77c0c9b3.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、跨域是什么&quot;&gt;&lt;a href=&quot;#一、跨域是什么&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="Vue" scheme="https://blogmind.cloud/categories/Vue/"/>
    
    
    <category term="面试" scheme="https://blogmind.cloud/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://blogmind.cloud/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>动态给vue的data添加一个新的属性时会发生什么？怎样解决？</title>
    <link href="https://blogmind.cloud/2025/01/01/vue-data-object-add-attrs/"/>
    <id>https://blogmind.cloud/2025/01/01/vue-data-object-add-attrs/</id>
    <published>2025-01-01T08:00:00.000Z</published>
    <updated>2025-02-08T06:49:30.099Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.vue-js.com/a502dde0-3acc-11eb-ab90-d9ae814b240d.png" alt="image.png"></p><h2 id="一、直接添加属性的问题"><a href="#一、直接添加属性的问题" class="headerlink" title="一、直接添加属性的问题"></a>一、直接添加属性的问题</h2><p>我们从一个例子开始</p><p>定义一个<code>p</code>标签，通过<code>v-for</code>指令进行遍历</p><p>然后给<code>botton</code>标签绑定点击事件，我们预期点击按钮时，数据新增一个属性，界面也 新增一行</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;(value,key) in item&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;key&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addProperty&quot;</span>&gt;</span>动态添加新属性<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实例化一个<code>vue</code>实例，定义<code>data</code>属性和<code>methods</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">   <span class="attr">data</span>:<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="attr">item</span>:&#123;</span><br><span class="line">            <span class="attr">oldProperty</span>:<span class="string">&quot;旧属性&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="title function_">addProperty</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">newProperty</span> = <span class="string">&quot;新属性&quot;</span>  <span class="comment">// 为items添加新属性</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">items</span>)  <span class="comment">// 输出带有newProperty的items</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>点击按钮，发现结果不及预期，数据虽然更新了（<code>console</code>打印出了新属性），但页面并没有更新</p><h2 id="二、原理分析"><a href="#二、原理分析" class="headerlink" title="二、原理分析"></a>二、原理分析</h2><p>为什么产生上面的情况呢？</p><p>下面来分析一下</p><p><code>vue2</code>是用过<code>Object.defineProperty</code>实现数据响应式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;foo&#x27;</span>, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`get foo:<span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`set foo:<span class="subst">$&#123;newVal&#125;</span>`</span>);</span><br><span class="line">                val = newVal</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们访问<code>foo</code>属性或者设置<code>foo</code>值的时候都能够触发<code>setter</code>与<code>getter</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="property">foo</span>   </span><br><span class="line">obj.<span class="property">foo</span> = <span class="string">&#x27;new&#x27;</span></span><br></pre></td></tr></table></figure><p>但是我们为<code>obj</code>添加新属性的时候，却无法触发事件属性的拦截</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="property">bar</span>  = <span class="string">&#x27;新属性&#x27;</span></span><br></pre></td></tr></table></figure><p>原因是一开始<code>obj</code>的<code>foo</code>属性被设成了响应式数据，而<code>bar</code>是后面新增的属性，并没有通过<code>Object.defineProperty</code>设置成响应式数据</p><h2 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h2><p><code>Vue</code> 不允许在已经创建的实例上动态添加新的响应式属性</p><p>若想实现数据与视图同步更新，可采取下面三种解决方案：</p><ul><li>Vue.set()</li><li>Object.assign()</li><li>$forcecUpdated()</li></ul><h3 id="Vue-set"><a href="#Vue-set" class="headerlink" title="Vue.set()"></a>Vue.set()</h3><p>Vue.set( target, propertyName&#x2F;index, value )</p><p>参数</p><ul><li><code>&#123;Object | Array&#125; target</code></li><li><code>&#123;string | number&#125; propertyName/index</code></li><li><code>&#123;any&#125; value</code></li></ul><p>返回值：设置的值</p><p>通过<code>Vue.set</code>向响应式对象中添加一个<code>property</code>，并确保这个新 <code>property </code>同样是响应式的，且触发视图更新</p><p>关于<code>Vue.set</code>源码（省略了很多与本节不相关的代码）</p><p>源码位置：<code>src\core\observer\index.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">set</span> (<span class="params">target: <span class="built_in">Array</span>&lt;any&gt; | <span class="built_in">Object</span>, key: any, val: any</span>): any &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="title function_">defineReactive</span>(ob.<span class="property">value</span>, key, val)</span><br><span class="line">  ob.<span class="property">dep</span>.<span class="title function_">notify</span>()</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里无非再次调用<code>defineReactive</code>方法，实现新增属性的响应式</p><p>关于<code>defineReactive</code>方法，内部还是通过<code>Object.defineProperty</code>实现属性拦截</p><p>大致代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, val</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`get <span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`set <span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;newVal&#125;</span>`</span>);</span><br><span class="line">                val = newVal</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p>直接使用<code>Object.assign()</code>添加到对象的新属性不会触发更新</p><p>应创建一个新的对象，合并原对象和混入对象的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">someObject</span> = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;,<span class="variable language_">this</span>.<span class="property">someObject</span>,&#123;<span class="attr">newProperty1</span>:<span class="number">1</span>,<span class="attr">newProperty2</span>:<span class="number">2</span> ...&#125;)</span><br></pre></td></tr></table></figure><h3 id="forceUpdate"><a href="#forceUpdate" class="headerlink" title="$forceUpdate"></a>$forceUpdate</h3><p>如果你发现你自己需要在 <code>Vue </code>中做一次强制更新，99.9% 的情况，是你在某个地方做错了事</p><p><code>$forceUpdate</code>迫使<code> Vue</code> 实例重新渲染</p><p>PS：仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><p>如果为对象添加少量的新属性，可以直接采用<code>Vue.set()</code></p></li><li><p>如果需要为新对象添加大量的新属性，则通过<code>Object.assign()</code>创建新对象</p></li><li><p>如果你实在不知道怎么操作时，可采取<code>$forceUpdate()</code>进行强制刷新 (不建议)</p></li></ul><p>PS：<code>vue3</code>是用过<code>proxy</code>实现数据响应式的，直接动态添加新属性仍可以实现数据响应式</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://cn.vuejs.org/v2/api/#Vue-set">https://cn.vuejs.org/v2/api/#Vue-set</a></li><li><a href="https://vue3js.cn/docs/zh">https://vue3js.cn/docs/zh</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://static.vue-js.com/a502dde0-3acc-11eb-ab90-d9ae814b240d.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、直接添加属性的问题&quot;&gt;&lt;a href=&quot;#一、直接添加属</summary>
      
    
    
    
    <category term="Vue" scheme="https://blogmind.cloud/categories/Vue/"/>
    
    
    <category term="面试" scheme="https://blogmind.cloud/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Vue" scheme="https://blogmind.cloud/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>对WebSocket的理解？应用场景</title>
    <link href="https://blogmind.cloud/2024/12/30/http-WebSocket/"/>
    <id>https://blogmind.cloud/2024/12/30/http-WebSocket/</id>
    <published>2024-12-29T16:00:00.000Z</published>
    <updated>2025-02-10T16:27:14.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对WebSocket的理解？应用场景？"><a href="#对WebSocket的理解？应用场景？" class="headerlink" title="对WebSocket的理解？应用场景？"></a>对WebSocket的理解？应用场景？</h1><p> <img src="https://static.vue-js.com/a358a8c0-c0f1-11eb-ab90-d9ae814b240d.png"></p><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>WebSocket，是一种网络传输协议，位于<code>OSI</code>模型的应用层。可在单个<code>TCP</code>连接上进行全双工通信，能更好的节省服务器资源和带宽并达到实时通迅</p><p>客户端和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输</p><p> <img src="https://static.vue-js.com/ad386e20-c0f1-11eb-85f6-6fac77c0c9b3.png"></p><p>从上图可见，<code>websocket</code>服务器与客户端通过握手连接，连接成功后，两者都能主动的向对方发送或接受数据</p><p>而在<code>websocket</code>出现之前，开发实时<code>web</code>应用的方式为轮询</p><p>不停地向服务器发送 HTTP 请求，问有没有数据，有数据的话服务器就用响应报文回应。如果轮询的频率比较高，那么就可以近似地实现“实时通信”的效果</p><p>轮询的缺点也很明显，反复发送无效查询请求耗费了大量的带宽和 <code>CPU </code>资源</p><h2 id="二、特点"><a href="#二、特点" class="headerlink" title="二、特点"></a>二、特点</h2><h3 id="全双工"><a href="#全双工" class="headerlink" title="全双工"></a>全双工</h3><p>通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合</p><p>例如指 A→B 的同时 B→A ，是瞬时同步的</p><h3 id="二进制帧"><a href="#二进制帧" class="headerlink" title="二进制帧"></a>二进制帧</h3><p>采用了二进制帧结构，语法、语义与 HTTP 完全不兼容，相比<code>http/2</code>，<code>WebSocket </code>更侧重于“实时通信”，而<code>HTTP/2</code> 更侧重于提高传输效率，所以两者的帧结构也有很大的区别</p><p>不像 <code>HTTP/2</code> 那样定义流，也就不存在多路复用、优先级等特性</p><p>自身就是全双工，也不需要服务器推送</p><h3 id="协议名"><a href="#协议名" class="headerlink" title="协议名"></a>协议名</h3><p>引入<code>ws</code>和<code>wss</code>分别代表明文和密文的<code>websocket</code>协议，且默认端口使用80或443，几乎与<code>http</code>一致</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws://www.chrono.com</span><br><span class="line">ws://www.chrono.com:8080/srv</span><br><span class="line">wss://www.chrono.com:445/im?user_id=xxx</span><br></pre></td></tr></table></figure><h3 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h3><p><code>WebSocket </code>也要有一个握手过程，然后才能正式收发数据</p><p>客户端发送数据格式如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/chat</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>server.example.com</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span><span class="punctuation">: </span>dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://example.com</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span><span class="punctuation">: </span>chat, superchat</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span><span class="punctuation">: </span>13</span><br></pre></td></tr></table></figure><ul><li>Connection：必须设置Upgrade，表示客户端希望连接升级</li><li>Upgrade：必须设置Websocket，表示希望升级到Websocket协议</li><li>Sec-WebSocket-Key：客户端发送的一个 base64 编码的密文，用于简单的认证秘钥。要求服务端必须返回一个对应加密的“Sec-WebSocket-Accept应答，否则客户端会抛出错误，并关闭连接</li><li>Sec-WebSocket-Version ：表示支持的Websocket版本</li></ul><p>服务端返回的数据格式：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span><span class="punctuation">: </span>s3pPLMBiTxaQ9kYGzzhZRbK+xOo=Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure><ul><li>HTTP&#x2F;1.1 101 Switching Protocols：表示服务端接受 WebSocket 协议的客户端连接</li><li>Sec-WebSocket-Accep：验证客户端请求报文，同样也是为了防止误连接。具体做法是把请求头里“Sec-WebSocket-Key”的值，加上一个专用的 UUID，再计算摘要</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>较少的控制开销：数据包头部协议较小，不同于http每次请求需要携带完整的头部</li><li>更强的实时性：相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少</li><li>保持创连接状态：创建通信后，可省略状态信息，不同于HTTP每次请求需要携带身份验证</li><li>更好的二进制支持：定义了二进制帧，更好处理二进制内容</li><li>支持扩展：用户可以扩展websocket协议、实现部分自定义的子协议</li><li>更好的压缩效果：Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率</li></ul><h2 id="二、应用场景"><a href="#二、应用场景" class="headerlink" title="二、应用场景"></a>二、应用场景</h2><p>基于<code>websocket</code>的事实通信的特点，其存在的应用场景大概有：</p><ul><li>弹幕</li><li>媒体聊天</li><li>协同编辑</li><li>基于位置的应用</li><li>体育实况更新</li><li>股票基金报价实时更新</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zh.wikipedia.org/wiki/WebSocket">https://zh.wikipedia.org/wiki/WebSocket</a></li><li><a href="https://www.oschina.net/translate/9-killer-uses-for-websockets">https://www.oschina.net/translate/9-killer-uses-for-websockets</a></li><li><a href="https://vue3js.cn/interview">https://vue3js.cn/interview</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;对WebSocket的理解？应用场景？&quot;&gt;&lt;a href=&quot;#对WebSocket的理解？应用场景？&quot; class=&quot;headerlink&quot; title=&quot;对WebSocket的理解？应用场景？&quot;&gt;&lt;/a&gt;对WebSocket的理解？应用场景？&lt;/h1&gt;&lt;p&gt; &lt;</summary>
      
    
    
    
    <category term="网络" scheme="https://blogmind.cloud/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="https://blogmind.cloud/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>如何理解UDP 和 TCP? 区别? 应用场景?</title>
    <link href="https://blogmind.cloud/2024/12/29/http-UDP-TCP/"/>
    <id>https://blogmind.cloud/2024/12/29/http-UDP-TCP/</id>
    <published>2024-12-28T16:00:00.000Z</published>
    <updated>2025-02-10T16:25:12.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何理解UDP-和-TCP-区别-应用场景"><a href="#如何理解UDP-和-TCP-区别-应用场景" class="headerlink" title="如何理解UDP 和 TCP? 区别? 应用场景?"></a>如何理解UDP 和 TCP? 区别? 应用场景?</h1><p> <img src="https://static.vue-js.com/85ad65b0-b393-11eb-ab90-d9ae814b240d.png"></p><h2 id="一、UDP"><a href="#一、UDP" class="headerlink" title="一、UDP"></a>一、UDP</h2><p>UDP（User Datagram Protocol），用户数据包协议，是一个简单的<strong>面向数据报的通信协议</strong>，即对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层</p><p>也就是说无论应用层交给<code>UDP</code>多长的报文，它统统发送，一次发送一个报文</p><p>而对接收方，接到后直接去除首部，交给上面的应用层就完成任务</p><p><code>UDP</code>报头包括4个字段，每个字段占用2个字节（即16个二进制位），标题短，开销小</p><p> <img src="https://static.vue-js.com/928e5d20-b393-11eb-ab90-d9ae814b240d.png"></p><p>特点如下：</p><ul><li>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务</li><li>传输途中出现丢包，UDP 也不负责重发</li><li>当包的到达顺序出现乱序时，UDP没有纠正的功能。</li><li>并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为</li></ul><h2 id="二、TCP"><a href="#二、TCP" class="headerlink" title="二、TCP"></a>二、TCP</h2><p>TCP（Transmission Control Protocol），传输控制协议，是一种可靠、<strong>面向字节流的通信协议</strong>，把上面应用层交下来的数据看成无结构的字节流来发送</p><p>可以想象成流水形式的，发送方TCP会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着，TCP会根据当前网络的拥塞状态来确定每个报文段的大小</p><p><code>TCP</code>报文首部有20个字节，额外开销大</p><p> <img src="https://static.vue-js.com/a0010d40-b393-11eb-ab90-d9ae814b240d.png"></p><p>特点如下：</p><ul><li>TCP充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。</li><li>此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</li><li>根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）</li></ul><h2 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h2><p><code>UDP</code>与<code>TCP</code>两者的都位于传输层，如下图所示：</p><p> <img src="https://static.vue-js.com/a92bda80-b393-11eb-ab90-d9ae814b240d.png"></p><p>两者区别如下表所示：</p><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>可靠性</td><td>可靠</td><td>不可靠</td></tr><tr><td>连接性</td><td>面向连接</td><td>无连接</td></tr><tr><td>报文</td><td>面向字节流</td><td>面向报文</td></tr><tr><td>效率</td><td>传输效率低</td><td>传输效率高</td></tr><tr><td>双共性</td><td>全双工</td><td>一对一、一对多、多对一、多对多</td></tr><tr><td>流量控制</td><td>滑动窗口</td><td>无</td></tr><tr><td>拥塞控制</td><td>慢开始、拥塞避免、快重传、快恢复</td><td>无</td></tr><tr><td>传输效率</td><td>慢</td><td>快</td></tr></tbody></table><ul><li><p>TCP 是面向连接的协议，建立连接3次握手、断开连接四次挥手，UDP是面向无连接，数据传输前后不连接连接，发送端只负责将数据发送到网络，接收端从消息队列读取</p></li><li><p>TCP 提供可靠的服务，传输过程采用流量控制、编号与确认、计时器等手段确保数据无差错，不丢失。UDP 则尽可能传递数据，但不保证传递交付给对方</p></li><li><p>TCP 面向字节流，将应用层报文看成一串无结构的字节流，分解为多个TCP报文段传输后，在目的站重新装配。UDP协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用</p></li><li><p>TCP 只能点对点全双工通信。UDP 支持一对一、一对多、多对一和多对多的交互通信</p></li></ul><p>两者应用场景如下图：</p><p> <img src="https://static.vue-js.com/b6cdd800-b393-11eb-ab90-d9ae814b240d.png"></p><p>可以看到，TCP 应用场景适用于对效率要求低，对准确性要求高或者要求有链接的场景，而UDP 适用场景为对效率要求高，对准确性要求低的场景</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zh.wikipedia.org/">https://zh.wikipedia.org</a></li><li><a href="https://www.shangmayuan.com/a/a1e3ceb218284cefb95de7fd.html">https://www.shangmayuan.com/a/a1e3ceb218284cefb95de7fd.html</a></li><li><a href="https://segmentfault.com/a/1190000021815671">https://segmentfault.com/a/1190000021815671</a></li><li><a href="https://vue3js.cn/interview">https://vue3js.cn/interview</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何理解UDP-和-TCP-区别-应用场景&quot;&gt;&lt;a href=&quot;#如何理解UDP-和-TCP-区别-应用场景&quot; class=&quot;headerlink&quot; title=&quot;如何理解UDP 和 TCP? 区别? 应用场景?&quot;&gt;&lt;/a&gt;如何理解UDP 和 TCP? 区别? 应</summary>
      
    
    
    
    <category term="网络" scheme="https://blogmind.cloud/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="https://blogmind.cloud/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>如何理解TCP/IP协议?</title>
    <link href="https://blogmind.cloud/2024/12/28/http-TCP-IP/"/>
    <id>https://blogmind.cloud/2024/12/28/http-TCP-IP/</id>
    <published>2024-12-27T16:00:00.000Z</published>
    <updated>2025-02-10T16:25:03.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何理解TCP-IP协议"><a href="#如何理解TCP-IP协议" class="headerlink" title="如何理解TCP&#x2F;IP协议?"></a>如何理解TCP&#x2F;IP协议?</h1><p> <img src="https://static.vue-js.com/4f69a930-b647-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>TCP&#x2F;IP，<strong>传输控制协议</strong>&#x2F;<strong>网际协议</strong>，是指能够在多个不同网络间实现信息传输的协议簇</p><ul><li>TCP（传输控制协议）</li></ul><p>一种面向连接的、可靠的、基于字节流的传输层通信协议</p><ul><li>IP（网际协议）</li></ul><p>用于封包交换数据网络的协议</p><p>TCP&#x2F;IP协议不仅仅指的是<code>TCP </code>和<code>IP</code>两个协议，而是指一个由<code>FTP</code>、<code>SMTP</code>、<code>TCP</code>、<code>UDP</code>、<code>IP</code>等协议构成的协议簇，</p><p>只是因为在<code>TCP/IP</code>协议中<code>TCP</code>协议和<code>IP</code>协议最具代表性，所以通称为TCP&#x2F;IP协议族（英语：TCP&#x2F;IP Protocol Suite，或TCP&#x2F;IP Protocols）</p><h2 id="二、划分"><a href="#二、划分" class="headerlink" title="二、划分"></a>二、划分</h2><p>TCP&#x2F;IP协议族按层次分别了五层体系或者四层体系</p><p>五层体系的协议结构是综合了 OSI 和 TCP&#x2F;IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层</p><p>五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP&#x2F;IP 四层体系结构，包括应用层、传输层、网络层（网际互联层）、网络接口层</p><p>如下图所示：</p><p> <img src="https://static.vue-js.com/5bb93610-b647-11eb-85f6-6fac77c0c9b3.png"></p><h3 id="五层体系"><a href="#五层体系" class="headerlink" title="五层体系"></a>五层体系</h3><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p><code>TCP/IP</code> 模型将 <code>OSI </code>参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务</p><p>如：<code>FTP</code>、<code>Telnet</code>、<code>DNS</code>、<code>SMTP</code> 等</p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能</p><p>传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）</p><p>其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输</p><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>负责为分组网络中的不同主机提供通信服务，并通过选择合适的路由将数据传递到目标主机</p><p>在发送数据时，网络层把运输层产生的报文段或用户数据封装成分组或包进行传送</p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>数据链路层在两个相邻节点传输数据时，将网络层交下来的IP数据报组装成帧，在两个相邻节点之间的链路上传送帧</p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境</p><h3 id="四层体系"><a href="#四层体系" class="headerlink" title="四层体系"></a>四层体系</h3><p>TCP&#x2F;IP 的四层结构则如下表所示：</p><table><thead><tr><th>层次名称</th><th>单位</th><th>功 能</th><th>协 议</th></tr></thead><tbody><tr><td>网络接口层</td><td>帧</td><td>负责实际数据的传输，对应OSI参考模型的下两层</td><td>HDLC（高级链路控制协议）PPP（点对点协议） SLIP（串行线路接口协议）</td></tr><tr><td>网络层</td><td>数据报</td><td>负责网络间的寻址数据传输，对应OSI参考模型的第三层</td><td>IP（网际协议） ICMP（网际控制消息协议）ARP（地址解析协议） RARP（反向地址解析协议）</td></tr><tr><td>传输层</td><td>报文段</td><td>负责提供可靠的传输服务，对应OSI参考模型的第四层</td><td>TCP（控制传输协议） UDP（用户数据报协议）</td></tr><tr><td>应用层</td><td></td><td>负责实现一切与应用程序相关的功能，对应OSI参考模型的上三层</td><td>FTP（文件传输协议） HTTP（超文本传输协议） DNS（域名服务器协议）SMTP（简单邮件传输协议）NFS（网络文件系统协议）</td></tr></tbody></table><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>OSI 参考模型与 TCP&#x2F;IP 参考模型区别如下：</p><p>相同点：</p><ul><li>OSI 参考模型与 TCP&#x2F;IP 参考模型都采用了层次结构</li><li>都能够提供面向连接和无连接两种通信服务机制</li></ul><p>不同点：</p><ul><li><p>OSI 采用的七层模型； TCP&#x2F;IP 是四层或五层结构</p></li><li><p>TCP&#x2F;IP 参考模型没有对网络接口层进行细分，只是一些概念性的描述； OSI 参考模型对服务和协议做了明确的区分</p></li><li><p>OSI 参考模型虽然网络划分为七层，但实现起来较困难。TCP&#x2F;IP 参考模型作为一种简化的分层结构是可以的</p></li><li><p>TCP&#x2F;IP协议去掉表示层和会话层的原因在于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的，这也就造成 <code>OSI</code> 设想中的应用程序维度的分层是无法实现的</p></li></ul><p>三种模型对应关系如下图所示：</p><p><img src="https://static.vue-js.com/3fbff4d0-b647-11eb-ab90-d9ae814b240d.png"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F">https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F</a></li><li><a href="https://zhuanlan.zhihu.com/p/103162095">https://zhuanlan.zhihu.com/p/103162095</a></li><li><a href="https://segmentfault.com/a/1190000039204681">https://segmentfault.com/a/1190000039204681</a></li><li><a href="https://leetcode-cn.com/leetbook/detail/networks-interview-highlights/">https://leetcode-cn.com/leetbook/detail/networks-interview-highlights/</a></li><li><a href="https://vue3js.cn/interview">https://vue3js.cn/interview</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何理解TCP-IP协议&quot;&gt;&lt;a href=&quot;#如何理解TCP-IP协议&quot; class=&quot;headerlink&quot; title=&quot;如何理解TCP&amp;#x2F;IP协议?&quot;&gt;&lt;/a&gt;如何理解TCP&amp;#x2F;IP协议?&lt;/h1&gt;&lt;p&gt; &lt;img src=&quot;https:/</summary>
      
    
    
    
    <category term="网络" scheme="https://blogmind.cloud/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="https://blogmind.cloud/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>为什么说HTTPS比HTTP安全? HTTPS是如何保证安全的？</title>
    <link href="https://blogmind.cloud/2024/12/26/http-HTTPS/"/>
    <id>https://blogmind.cloud/2024/12/26/http-HTTPS/</id>
    <published>2024-12-25T16:00:00.000Z</published>
    <updated>2025-02-10T16:24:40.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么说HTTPS比HTTP安全-HTTPS是如何保证安全的？"><a href="#为什么说HTTPS比HTTP安全-HTTPS是如何保证安全的？" class="headerlink" title="为什么说HTTPS比HTTP安全? HTTPS是如何保证安全的？"></a>为什么说HTTPS比HTTP安全? HTTPS是如何保证安全的？</h1><p> <img src="https://static.vue-js.com/b5512250-b2ff-11eb-ab90-d9ae814b240d.png"></p><h2 id="一、安全特性"><a href="#一、安全特性" class="headerlink" title="一、安全特性"></a>一、安全特性</h2><p>在上篇文章中，我们了解到<code>HTTP</code>在通信过程中，存在以下问题：</p><ul><li>通信使用明文（不加密），内容可能被窃听</li><li>不验证通信方的身份，因此有可能遭遇伪装</li></ul><p>而<code>HTTPS</code>的出现正是解决这些问题，<code>HTTPS</code>是建立在<code>SSL</code>之上，其安全性由<code>SSL</code>来保证</p><p>在采用<code>SSL</code>后，<code>HTTP</code>就拥有了<code>HTTPS</code>的加密、证书和完整性保护这些功能</p><blockquote><p>SSL(Secure Sockets Layer 安全套接字协议),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议</p></blockquote><p> <img src="https://static.vue-js.com/cb559400-b2ff-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="二、如何做"><a href="#二、如何做" class="headerlink" title="二、如何做"></a>二、如何做</h2><p><code>SSL </code>的实现这些功能主要依赖于三种手段：</p><ul><li>对称加密：采用协商的密钥对数据加密</li><li>非对称加密：实现身份认证和密钥协商</li><li>摘要算法：验证信息的完整性</li><li>数字签名：身份验证</li></ul><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密指的是加密和解密使用的秘钥都是同一个，是对称的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性</p><p> <img src="https://static.vue-js.com/e3f040f0-b2ff-11eb-ab90-d9ae814b240d.png"></p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>非对称加密，存在两个秘钥，一个叫公钥，一个叫私钥。两个秘钥是不同的，公钥可以公开给任何人使用，私钥则需要保密</p><p>公钥和私钥都可以用来加密解密，但公钥加密后只能用私钥解<br>密，反过来，私钥加密后也只能用公钥解密</p><p> <img src="https://static.vue-js.com/d9603e60-b2ff-11eb-ab90-d9ae814b240d.png"></p><h3 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h3><p>在<code>HTTPS</code>通信过程中，采用的是对称加密+非对称加密，也就是混合加密</p><p>在对称加密中讲到，如果能够保证了密钥的安全，那整个通信过程就可以说具有了机密性</p><p>而<code>HTTPS</code>采用非对称加密解决秘钥交换的问题</p><p>具体做法是发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”</p><p> <img src="https://static.vue-js.com/f375f290-b2ff-11eb-85f6-6fac77c0c9b3.png"></p><p>这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信</p><h4 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h4><p>网站秘密保管私钥，在网上任意分发公钥，你想要登录网站只要用公钥加密就行了，密文只能由私钥持有者才能解密。而黑客因为没有私钥，所以就无法破解密文</p><p>上述的方法解决了数据加密，在网络传输过程中，数据有可能被篡改，并且黑客可以伪造身份发布公钥，如果你获取到假的公钥，那么混合加密也并无多大用处，你的数据扔被黑客解决</p><p>因此，在上述加密的基础上仍需加上完整性、身份验证的特性，来实现真正的安全，实现这一功能则是摘要算法</p><h3 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h3><p>实现完整性的手段主要是摘要算法，也就是常说的散列函数、哈希函数</p><p>可以理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”</p><p> <img src="https://static.vue-js.com/12798da0-b300-11eb-85f6-6fac77c0c9b3.png"></p><p>摘要算法保证了“数字摘要”和原文是完全等价的。所以，我们只要在原文后附上它的摘要，就能够保证数据的完整性</p><p>比如，你发了条消息：“转账 1000 元”，然后再加上一个 SHA-2 的摘要。网站收到后也计算一下消息的摘要，把这两份“指纹”做个对比，如果一致，就说明消息是完整可信的，没有被修改</p><p> <img src="https://static.vue-js.com/023790e0-b300-11eb-ab90-d9ae814b240d.png"></p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名</p><p>原理其实很简单，就是用私钥加密，公钥解密</p><p>签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的</p><p> <img src="https://static.vue-js.com/21aa6880-b300-11eb-85f6-6fac77c0c9b3.png"></p><p>和消息本身一样，因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段，也就是说，怎么判断这个公钥就是你的公钥</p><p>这时候就需要一个第三方，就是证书验证机构</p><h3 id="CA验证机构"><a href="#CA验证机构" class="headerlink" title="CA验证机构"></a>CA验证机构</h3><p>数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场</p><p>CA 对公钥的签名认证要求包括序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“数字证书”</p><p>流程如下图：</p><p> <img src="https://static.vue-js.com/395648a0-b300-11eb-85f6-6fac77c0c9b3.png"></p><ul><li>服务器的运营人员向数字证书认证机构提出公开密钥的申请</li><li>数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名</li><li>然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起</li><li>服务器会将这份由数字证书认证机构颁发的数字证书发送给客户端，以进行非对称加密方式通信</li></ul><p>接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，则证明：</p><ul><li>认证服务器的公开密钥的是真实有效的数字证书认证机构</li><li>服务器的公开密钥是值得信赖的</li></ul><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>可以看到，<code>HTTPS</code>与<code>HTTP</code>虽然只差一个<code>SSL</code>，但是通信安全得到了大大的保障，通信的四大特性都以解决，解决方式如下：</p><ul><li>机密性：混合算法</li><li>完整性：摘要算法</li><li>身份认证：数字签名</li><li>不可否定：数字签名</li></ul><p>同时引入第三方证书机构，确保公开秘钥的安全性</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/100657391">https://zhuanlan.zhihu.com/p/100657391</a></li><li><a href="https://juejin.cn/post/6844903830987997197#heading-7">https://juejin.cn/post/6844903830987997197#heading-7</a></li><li><a href="https://cloud.tencent.com/developer/article/1748862">https://cloud.tencent.com/developer/article/1748862</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么说HTTPS比HTTP安全-HTTPS是如何保证安全的？&quot;&gt;&lt;a href=&quot;#为什么说HTTPS比HTTP安全-HTTPS是如何保证安全的？&quot; class=&quot;headerlink&quot; title=&quot;为什么说HTTPS比HTTP安全? HTTPS是如何保证安全</summary>
      
    
    
    
    <category term="网络" scheme="https://blogmind.cloud/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="https://blogmind.cloud/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>如何理解OSI七层模型?</title>
    <link href="https://blogmind.cloud/2024/12/26/http-OSI/"/>
    <id>https://blogmind.cloud/2024/12/26/http-OSI/</id>
    <published>2024-12-25T16:00:00.000Z</published>
    <updated>2025-02-10T16:24:47.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何理解OSI七层模型"><a href="#如何理解OSI七层模型" class="headerlink" title="如何理解OSI七层模型?"></a>如何理解OSI七层模型?</h1><p> <img src="https://static.vue-js.com/e2e1b910-b61e-11eb-ab90-d9ae814b240d.png"></p><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>OSI （Open System Interconnect）模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架</p><p><code>OSI </code>将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。即每一层扮演固定的角色，互不打扰</p><h2 id="二、划分"><a href="#二、划分" class="headerlink" title="二、划分"></a>二、划分</h2><p><code>OSI</code>主要划分了七层，如下图所示：</p><p> <img src="https://static.vue-js.com/eb1b2170-b61e-11eb-ab90-d9ae814b240d.png"></p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层位于 OSI 参考模型的第七层，其作用是通过应用程序间的交互来完成特定的网络应用</p><p>该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统 <code>DNS</code>，支持万维网应用的 <code>HTTP</code> 协议，电子邮件系统采用的 <code>SMTP </code>协议等</p><p>在应用层交互的数据单元我们称之为报文</p><h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p>表示层的作用是使通信的应用程序能够解释交换数据的含义，其位于 <code>OSI </code>参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务</p><p>该层提供的服务主要包括数据压缩，数据加密以及数据描述，使应用程序不必担心在各台计算机中表示和存储的内部格式差异</p><h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p>会话层就是负责建立、管理和终止表示层实体之间的通信会话</p><p>该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>传输层的主要任务是为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其他一些关键传输问题</p><p>传输层向高层屏蔽了下层数据通信的细节。因此，它是计算机通信体系结构中关键的一层</p><p>其中，主要的传输层协议是<code>TCP</code>和<code>UDP</code></p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网</p><p>网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送</p><p>在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包，向下传输到数据链路层</p><p>在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议</p><p>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 <code>IP </code>数据报组装成帧，在两个相邻节点间的链路上传送帧</p><p>每一帧的数据可以分成：报头<code>head</code>和数据<code>data</code>两部分:</p><ul><li>head 标明数据发送者、接受者、数据类型，如 MAC地址</li><li>data 存储了计算机之间交互的数据</li></ul><p>通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源</p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>作为<code> OSI</code> 参考模型中最低的一层，物理层的作用是实现计算机节点之间比特流的透明传送</p><p>该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）</p><p>该层主要是和硬件有关，与软件关系不大</p><h2 id="三、传输过程"><a href="#三、传输过程" class="headerlink" title="三、传输过程"></a>三、传输过程</h2><p>数据在各层之间的传输如下图所示：</p><p> <img src="https://static.vue-js.com/f3a89d40-b61e-11eb-85f6-6fac77c0c9b3.png"></p><ul><li>应用层报文被传送到运输层</li><li>在最简单的情况下，运输层收取到报文并附上附加信息，该首部将被接收端的运输层使用</li><li>应用层报文和运输层首部信息一道构成了运输层报文段。附加的信息可能包括：允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端能够判断报文中的比特是否在途中已被改变</li><li>运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报</li><li>网络层数据报接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧</li><li>在物理层数据帧被封装成比特流，之后通过传输介质传送到对端</li><li>对端再一步步解开封装，获取到传送的数据</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B">https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B</a></li><li><a href="https://zhuanlan.zhihu.com/p/32059190">https://zhuanlan.zhihu.com/p/32059190</a></li><li><a href="https://leetcode-cn.com/leetbook/detail/networks-interview-highlights/">https://leetcode-cn.com/leetbook/detail/networks-interview-highlights/</a></li><li><a href="https://vue3js.cn/interview">https://vue3js.cn/interview</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何理解OSI七层模型&quot;&gt;&lt;a href=&quot;#如何理解OSI七层模型&quot; class=&quot;headerlink&quot; title=&quot;如何理解OSI七层模型?&quot;&gt;&lt;/a&gt;如何理解OSI七层模型?&lt;/h1&gt;&lt;p&gt; &lt;img src=&quot;https://static.vue-js</summary>
      
    
    
    
    <category term="网络" scheme="https://blogmind.cloud/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="https://blogmind.cloud/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
